###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         07/Apr/2021  11:05:09
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\SdBaseFile.cpp
#    Command line =  
#        -f C:\Users\PLT\AppData\Local\Temp\EW93B6.tmp
#        (C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\SdBaseFile.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lC
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lA
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Src\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/l6474\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/MotorControl\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino/avr\
#        -I C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc/Logo\ -Om --c++
#        --no_exceptions --no_rtti -I "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I "D:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List\SdBaseFile.lst
#    Object file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj\SdBaseFile.o
#
###############################################################################

C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\SdBaseFile.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * Arduino SdFat Library
     25           * Copyright (C) 2009 by William Greiman
     26           *
     27           * This file is part of the Arduino Sd2Card Library
     28           */
     29          
     30          #include "Marlin.h"

    #define SDSS   18
            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\pins_MKS_ROBIN_LITE.h",161  Warning[Pa181]: 
          incompatible redefinition of macro "SDSS" (declared at line 62)

  #define UNUSED(x) ((void)(x))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pa181]: 
          incompatible redefinition of macro "UNUSED" (declared at line 88 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\macros.h")

   \                                 In section .text, align 2
   \   __interwork __softfp void MarlinSerial::write(uint8_t)
   \                     _ZN12MarlinSerial5writeEh: (+1)
   \        0x0   0xB502             PUSH     {R1,LR}
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x.... 0x....      BL       BSP_UartIfQueueTxData
   \        0xA   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void MarlinSerial::write(char const *)
   \                     _ZN12MarlinSerial5writeEPKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      BL       strlen
   \        0xC   0x4602             MOV      R2,R0
   \        0xE   0xB2D2             UXTB     R2,R2
   \       0x10   0x4629             MOV      R1,R5
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x18   0x.... 0x....      B.W      BSP_UartIfQueueTxData

   \                                 In section .text, align 4
   \   __interwork __softfp void MarlinSerial::print(char const *)
   \                     _ZN12MarlinSerial5printEPKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      BL       strlen
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD013             BEQ.N    ??print_1
   \       0x10   0x480A             LDR.N    R0,??print_0
   \       0x12   0x7800             LDRB     R0,[R0, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??print_2
   \       0x18   0x4629             MOV      R1,R5
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x20   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEPKc
   \                     ??print_2: (+1)
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x.... 0x....      BL       strlen
   \       0x2A   0x4602             MOV      R2,R0
   \       0x2C   0x4629             MOV      R1,R5
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x34   0x.... 0x....      B.W      package_to_wifi
   \                     ??print_1: (+1)
   \       0x38   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \       0x3A   0xBF00             Nop      
   \                     ??print_0:
   \       0x3C   0x....'....        DC32     from_wifi_flag

  #define PRINT_LED_PIN         PDout(2)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\BSP\STM32MKS-3dPrinter\mks_fastio.h",14  Warning[Pa181]: 
          incompatible redefinition of macro "PRINT_LED_PIN" (declared at line
          146 of "C:\Users\PLT\Desktop\mksRobinLite_nano\Inc\main.h")
     31          #include "mks_reprint.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t DIR_IS_LONG_NAME(dir_t const *)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f16DIR_IS_LONG_NAMEEPK14directoryEntry: (+1)
   \        0x0   0x7AC0             LDRB     R0,[R0, #+11]
   \        0x2   0xF000 0x003F      AND      R0,R0,#0x3F
   \        0x6   0x280F             CMP      R0,#+15
   \        0x8   0xD101             BNE.N    ??DIR_IS_LONG_NAME_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x4770             BX       LR
   \                     ??DIR_IS_LONG_NAME_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t DIR_IS_FILE(dir_t const *)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f11DIR_IS_FILEEPK14directoryEntry: (+1)
   \        0x0   0x7AC0             LDRB     R0,[R0, #+11]
   \        0x2   0xF000 0x0018      AND      R0,R0,#0x18
   \        0x6   0x1E40             SUBS     R0,R0,#+1
   \        0x8   0x4180             SBCS     R0,R0,R0
   \        0xA   0x0FC0             LSRS     R0,R0,#+31
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t DIR_IS_SUBDIR(dir_t const *)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f13DIR_IS_SUBDIREPK14directoryEntry: (+1)
   \        0x0   0x7AC0             LDRB     R0,[R0, #+11]
   \        0x2   0xF000 0x0018      AND      R0,R0,#0x18
   \        0x6   0x2810             CMP      R0,#+16
   \        0x8   0xD101             BNE.N    ??DIR_IS_SUBDIR_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x4770             BX       LR
   \                     ??DIR_IS_SUBDIR_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t DIR_IS_FILE_OR_SUBDIR(dir_t const *)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f21DIR_IS_FILE_OR_SUBDIREPK14directoryEntry: (+1)
   \        0x0   0x7AC0             LDRB     R0,[R0, #+11]
   \        0x2   0x08C0             LSRS     R0,R0,#+3
   \        0x4   0xF000 0x0001      AND      R0,R0,#0x1
   \        0x8   0xF080 0x0001      EOR      R0,R0,#0x1
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t SdVolume::fatType() const
   \                     _ZNK8SdVolume7fatTypeEv: (+1)
   \        0x0   0xF890 0x0020      LDRB     R0,[R0, #+32]
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t SdVolume::rootDirEntryCount() const
   \                     _ZNK8SdVolume17rootDirEntryCountEv: (+1)
   \        0x0   0x8C40             LDRH     R0,[R0, #+34]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t SdVolume::rootDirStart() const
   \                     _ZNK8SdVolume12rootDirStartEv: (+1)
   \        0x0   0x6A40             LDR      R0,[R0, #+36]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t SdVolume::blockOfCluster(uint32_t) const
   \                     _ZNK8SdVolume14blockOfClusterEj: (+1)
   \        0x0   0x7900             LDRB     R0,[R0, #+4]
   \        0x2   0x1E40             SUBS     R0,R0,#+1
   \        0x4   0xEA10 0x2151      ANDS     R1,R0,R1, LSR #+9
   \        0x8   0x4608             MOV      R0,R1
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t SdVolume::clusterStartBlock(uint32_t) const
   \                     _ZNK8SdVolume17clusterStartBlockEj: (+1)
   \        0x0   0x6942             LDR      R2,[R0, #+20]
   \        0x2   0x1E89             SUBS     R1,R1,#+2
   \        0x4   0x7C00             LDRB     R0,[R0, #+16]
   \        0x6   0x4081             LSLS     R1,R1,R0
   \        0x8   0x1889             ADDS     R1,R1,R2
   \        0xA   0x4608             MOV      R0,R1
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp cache_t *SdVolume::cache()
   \                     _ZN8SdVolume5cacheEv: (+1)
   \        0x0   0x4800             LDR.N    R0,??cache_0
   \        0x2   0x4770             BX       LR               ;; return
   \                     ??cache_0:
   \        0x4   0x....'....        DC32     _ZN8SdVolume12cacheBuffer_E

   \                                 In section .text, align 4
   \   __interwork __softfp uint32_t SdVolume::cacheBlockNumber()
   \                     _ZN8SdVolume16cacheBlockNumberEv: (+1)
   \        0x0   0x4801             LDR.N    R0,??cacheBlockNumber_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop      
   \                     ??cacheBlockNumber_0:
   \        0x8   0x....'....        DC32     _ZN8SdVolume17cacheBlockNumber_E

   \                                 In section .text, align 4
   \   __interwork __softfp void SdVolume::cacheSetBlockNumber(uint32_t, bool)
   \                     _ZN8SdVolume19cacheSetBlockNumberEjb: (+1)
   \        0x0   0x4802             LDR.N    R0,??cacheSetBlockNumber_0
   \        0x2   0x7002             STRB     R2,[R0, #+0]
   \        0x4   0x4802             LDR.N    R0,??cacheSetBlockNumber_0+0x4
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x4770             BX       LR               ;; return
   \        0xA   0xBF00             Nop      
   \                     ??cacheSetBlockNumber_0:
   \        0xC   0x....'....        DC32     _ZN8SdVolume11cacheDirty_E
   \       0x10   0x....'....        DC32     _ZN8SdVolume17cacheBlockNumber_E

   \                                 In section .text, align 2
   \   __interwork __softfp bool SdVolume::fatPutEOC(uint32_t)
   \                     _ZN8SdVolume9fatPutEOCEj: (+1)
   \        0x0   0xF06F 0x4270      MVN      R2,#-268435456
   \        0x4   0x.... 0x....      B.W      _ZN8SdVolume6fatPutEjj

   \                                 In section .text, align 4
   \   __interwork __softfp bool SdVolume::isEOC(uint32_t) const
   \                     _ZNK8SdVolume5isEOCEj: (+1)
   \        0x0   0xF890 0x0020      LDRB     R0,[R0, #+32]
   \        0x4   0x2810             CMP      R0,#+16
   \        0x6   0xD106             BNE.N    ??isEOC_1
   \        0x8   0xF64F 0x70F8      MOVW     R0,#+65528
   \        0xC   0x4281             CMP      R1,R0
   \        0xE   0x4180             SBCS     R0,R0,R0
   \       0x10   0x43C0             MVNS     R0,R0
   \       0x12   0x0FC0             LSRS     R0,R0,#+31
   \       0x14   0x4770             BX       LR
   \                     ??isEOC_1: (+1)
   \       0x16   0x4803             LDR.N    R0,??isEOC_0     ;; 0xffffff8
   \       0x18   0x4281             CMP      R1,R0
   \       0x1A   0x4180             SBCS     R0,R0,R0
   \       0x1C   0x43C0             MVNS     R0,R0
   \       0x1E   0x0FC0             LSRS     R0,R0,#+31
   \       0x20   0x4770             BX       LR               ;; return
   \       0x22   0xBF00             Nop      
   \                     ??isEOC_0:
   \       0x24   0x0FFF'FFF8        DC32     0xffffff8

   \                                 In section .text, align 4
   \   __interwork __softfp bool SdVolume::readBlock(uint32_t, uint8_t *)
   \                     _ZN8SdVolume9readBlockEjPh: (+1)
   \        0x0   0x4801             LDR.N    R0,??readBlock_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x.... 0x....      B.W      _ZN7Sd2Card9readBlockEjPh
   \                     ??readBlock_0:
   \        0x8   0x....'....        DC32     _ZN8SdVolume7sdCard_E

   \                                 In section .text, align 4
   \   __interwork __softfp bool SdVolume::writeBlock(uint32_t, uint8_t const *)
   \                     _ZN8SdVolume10writeBlockEjPKh: (+1)
   \        0x0   0x4801             LDR.N    R0,??writeBlock_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x.... 0x....      B.W      _ZN7Sd2Card10writeBlockEjPKh
   \                     ??writeBlock_0:
   \        0x8   0x....'....        DC32     _ZN8SdVolume7sdCard_E

   \                                 In section .text, align 2
   \   __code __interwork __softfp filepos_t::filepos_t()
   \                     _ZN9filepos_tC1Ev: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0x6041             STR      R1,[R0, #+4]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint16_t FAT_DATE(uint16_t, uint8_t, uint8_t)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f8FAT_DATEEthh: (+1)
   \        0x0   0xF240 0x73BC      MOVW     R3,#+1980
   \        0x4   0x1AC0             SUBS     R0,R0,R3
   \        0x6   0x0149             LSLS     R1,R1,#+5
   \        0x8   0xEA41 0x2140      ORR      R1,R1,R0, LSL #+9
   \        0xC   0x4311             ORRS     R1,R2,R1
   \        0xE   0x4608             MOV      R0,R1
   \       0x10   0xB280             UXTH     R0,R0
   \       0x12   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint16_t FAT_YEAR(uint16_t)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f8FAT_YEAREt: (+1)
   \        0x0   0x0A40             LSRS     R0,R0,#+9
   \        0x2   0xF200 0x70BC      ADDW     R0,R0,#+1980
   \        0x6   0xB280             UXTH     R0,R0
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t FAT_MONTH(uint16_t)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f9FAT_MONTHEt: (+1)
   \        0x0   0x0940             LSRS     R0,R0,#+5
   \        0x2   0xF000 0x000F      AND      R0,R0,#0xF
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t FAT_DAY(uint16_t)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f7FAT_DAYEt: (+1)
   \        0x0   0xF000 0x001F      AND      R0,R0,#0x1F
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint16_t FAT_TIME(uint8_t, uint8_t, uint8_t)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f8FAT_TIMEEhhh: (+1)
   \        0x0   0x0149             LSLS     R1,R1,#+5
   \        0x2   0xEA41 0x21C0      ORR      R1,R1,R0, LSL #+11
   \        0x6   0xEA51 0x0152      ORRS     R1,R1,R2, LSR #+1
   \        0xA   0x4608             MOV      R0,R1
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t FAT_HOUR(uint16_t)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f8FAT_HOUREt: (+1)
   \        0x0   0x0AC0             LSRS     R0,R0,#+11
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t FAT_MINUTE(uint16_t)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f10FAT_MINUTEEt: (+1)
   \        0x0   0x0940             LSRS     R0,R0,#+5
   \        0x2   0xF000 0x003F      AND      R0,R0,#0x3F
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t FAT_SECOND(uint16_t)
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f10FAT_SECONDEt: (+1)
   \        0x0   0x0040             LSLS     R0,R0,#+1
   \        0x2   0xF000 0x003E      AND      R0,R0,#0x3E
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __code __interwork __softfp SdBaseFile::SdBaseFile()
   \                     _ZN10SdBaseFileC1Ev: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x7001             STRB     R1,[R0, #+0]
   \        0x4   0x70C1             STRB     R1,[R0, #+3]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __code __interwork __softfp SdBaseFile::~SdBaseFile()
   \                     _ZN10SdBaseFileD1Ev: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    `?~SdBaseFile_0`
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _ZN10SdBaseFile5closeEv
   \                     `?~SdBaseFile_0`: (+1)
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t SdBaseFile::curPosition() const
   \                     _ZNK10SdBaseFile11curPositionEv: (+1)
   \        0x0   0x6880             LDR      R0,[R0, #+8]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool SdBaseFile::isDir() const
   \                     _ZNK10SdBaseFile5isDirEv: (+1)
   \        0x0   0x78C0             LDRB     R0,[R0, #+3]
   \        0x2   0x2802             CMP      R0,#+2
   \        0x4   0xDB01             BLT.N    ??isDir_0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x4770             BX       LR
   \                     ??isDir_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool SdBaseFile::isFile() const
   \                     _ZNK10SdBaseFile6isFileEv: (+1)
   \        0x0   0x78C0             LDRB     R0,[R0, #+3]
   \        0x2   0x2801             CMP      R0,#+1
   \        0x4   0xD101             BNE.N    ??isFile_0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x4770             BX       LR
   \                     ??isFile_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool SdBaseFile::isOpen() const
   \                     _ZNK10SdBaseFile6isOpenEv: (+1)
   \        0x0   0x78C0             LDRB     R0,[R0, #+3]
   \        0x2   0x1E40             SUBS     R0,R0,#+1
   \        0x4   0x4180             SBCS     R0,R0,R0
   \        0x6   0x43C0             MVNS     R0,R0
   \        0x8   0x0FC0             LSRS     R0,R0,#+31
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool SdBaseFile::isSubDir() const
   \                     _ZNK10SdBaseFile8isSubDirEv: (+1)
   \        0x0   0x78C0             LDRB     R0,[R0, #+3]
   \        0x2   0x2804             CMP      R0,#+4
   \        0x4   0xD101             BNE.N    ??isSubDir_0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x4770             BX       LR
   \                     ??isSubDir_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool SdBaseFile::isRoot() const
   \                     _ZNK10SdBaseFile6isRootEv: (+1)
   \        0x0   0x78C0             LDRB     R0,[R0, #+3]
   \        0x2   0x2802             CMP      R0,#+2
   \        0x4   0xD001             BEQ.N    ??isRoot_0
   \        0x6   0x2803             CMP      R0,#+3
   \        0x8   0xD101             BNE.N    ??isRoot_1
   \                     ??isRoot_0: (+1)
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x4770             BX       LR
   \                     ??isRoot_1: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void SdBaseFile::rewind()
   \                     _ZN10SdBaseFile6rewindEv: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x.... 0x....      B.W      _ZN10SdBaseFile7seekSetEj

   \                                 In section .text, align 2
   \   __interwork __softfp bool SdBaseFile::seekEnd(int32_t)
   \                     _ZN10SdBaseFile7seekEndEi: (+1)
   \        0x0   0x6942             LDR      R2,[R0, #+20]
   \        0x2   0x1889             ADDS     R1,R1,R2
   \        0x4   0x.... 0x....      B.W      _ZN10SdBaseFile7seekSetEj

   \                                 In section .text, align 2
   \   __interwork __softfp SdVolume *SdBaseFile::volume() const
   \                     _ZNK10SdBaseFile6volumeEv: (+1)
   \        0x0   0x69C0             LDR      R0,[R0, #+28]
   \        0x2   0x4770             BX       LR               ;; return

  #define PSTR(str) (str)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",8  Warning[Pa181]: 
          incompatible redefinition of macro "PSTR" (declared at line 59 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin.h")

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",23  Warning[Pa181]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",26  Warning[Pa181]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",28  Warning[Pa181]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",36  Warning[Pa181]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  class SdFile : public SdBaseFile, public Print {
        ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\SdFile.h",45  Warning[Pe611]: 
          overloaded virtual function "Print::write" is only partially
          overridden in class "SdFile"

    FORCE_INLINE bool renameFile(const char * newPath){ file.rename(curDir, newPath);}
                                                                                     ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\cardreader.h",99  Warning[Pe940]: 
          missing return statement at end of non-void function
          "CardReader::renameFile"
     32          #if ENABLED(SDSUPPORT)
     33          
     34          #include "SdBaseFile.h"
     35          //------------------------------------------------------------------------------
     36          // pointer to cwd directory

   \                                 In section .bss, align 4
     37          SdBaseFile* SdBaseFile::cwd_ = 0;
   \                     _ZN10SdBaseFile4cwd_E:
   \        0x0                      DS8 4
     38          // callback function for date/time

   \                                 In section .bss, align 4
     39          void (*SdBaseFile::dateTime_)(uint16_t* date, uint16_t* time) = 0;
   \                     _ZN10SdBaseFile9dateTime_E:
   \        0x0                      DS8 4
     40          //------------------------------------------------------------------------------
     41          // add a cluster to a file

   \                                 In section .text, align 2, keep-with-next
     42          bool SdBaseFile::addCluster() {
   \                     _ZN10SdBaseFile10addClusterEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     43            if (!vol_->allocContiguous(1, &curCluster_)) goto fail;
   \        0x4   0x1D22             ADDS     R2,R4,#+4
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x69E0             LDR      R0,[R4, #+28]
   \        0xA   0x.... 0x....      BL       _ZN8SdVolume15allocContiguousEjPj
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD101             BNE.N    ??addCluster_0
     44          
     45            // if first cluster of file link to directory entry
     46            if (firstCluster_ == 0) {
     47              firstCluster_ = curCluster_;
     48              flags_ |= F_FILE_DIR_DIRTY;
     49            }
     50            return true;
     51          
     52           fail:
     53            return false;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xBD10             POP      {R4,PC}
   \                     ??addCluster_0: (+1)
   \       0x16   0x69A0             LDR      R0,[R4, #+24]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD105             BNE.N    ??addCluster_1
   \       0x1C   0x6860             LDR      R0,[R4, #+4]
   \       0x1E   0x61A0             STR      R0,[R4, #+24]
   \       0x20   0x7860             LDRB     R0,[R4, #+1]
   \       0x22   0xF040 0x0080      ORR      R0,R0,#0x80
   \       0x26   0x7060             STRB     R0,[R4, #+1]
   \                     ??addCluster_1: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xBD10             POP      {R4,PC}          ;; return
     54          }
     55          //------------------------------------------------------------------------------
     56          // Add a cluster to a directory file and zero the cluster.
     57          // return with first block of cluster in the cache

   \                                 In section .text, align 2, keep-with-next
     58          bool SdBaseFile::addDirCluster() {
   \                     _ZN10SdBaseFile13addDirClusterEv: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
     59            uint32_t block;
     60            // max folder size
     61            if (fileSize_ / sizeof(dir_t) >= 0XFFFF) goto fail;
   \        0x6   0x6960             LDR      R0,[R4, #+20]
   \        0x8   0x0940             LSRS     R0,R0,#+5
   \        0xA   0xF64F 0x71FF      MOVW     R1,#+65535
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xD235             BCS.N    ??addDirCluster_0
     62          
     63            if (!addCluster()) goto fail;
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       _ZN10SdBaseFile10addClusterEv
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD030             BEQ.N    ??addDirCluster_0
     64            if (!vol_->cacheFlush()) goto fail;
   \       0x1C   0x.... 0x....      BL       _ZN8SdVolume10cacheFlushEv
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD02C             BEQ.N    ??addDirCluster_0
     65          
     66            block = vol_->clusterStartBlock(curCluster_);
   \       0x24   0x6861             LDR      R1,[R4, #+4]
   \       0x26   0x69E0             LDR      R0,[R4, #+28]
   \       0x28   0x.... 0x....      BL       _ZNK8SdVolume17clusterStartBlockEj
   \       0x2C   0x4606             MOV      R6,R0
     67          
     68            // set cache to first block of cluster
     69            vol_->cacheSetBlockNumber(block, true);
   \       0x2E   0x2201             MOVS     R2,#+1
   \       0x30   0x4631             MOV      R1,R6
   \       0x32   0x69E0             LDR      R0,[R4, #+28]
   \       0x34   0x.... 0x....      BL       _ZN8SdVolume19cacheSetBlockNumberEjb
     70          
     71            // zero first block of cluster
     72            memset(vol_->cacheBuffer_.data, 0, 512);
   \       0x38   0x.... 0x....      LDR.W    R7,??DataTable11
   \       0x3C   0xF44F 0x7500      MOV      R5,#+512
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0x4629             MOV      R1,R5
   \       0x44   0x4638             MOV      R0,R7
   \       0x46   0x.... 0x....      BL       __aeabi_memset4
     73          
     74            // zero rest of cluster
     75            for (uint8_t i = 1; i < vol_->blocksPerCluster_; i++) {
   \       0x4A   0xF04F 0x0801      MOV      R8,#+1
   \       0x4E   0xE009             B.N      ??addDirCluster_1
     76              if (!vol_->writeBlock(block + i, vol_->cacheBuffer_.data)) goto fail;
   \                     ??addDirCluster_2: (+1)
   \       0x50   0x463A             MOV      R2,R7
   \       0x52   0x4641             MOV      R1,R8
   \       0x54   0xB2C9             UXTB     R1,R1
   \       0x56   0x1989             ADDS     R1,R1,R6
   \       0x58   0x.... 0x....      BL       _ZN8SdVolume10writeBlockEjPKh
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD00E             BEQ.N    ??addDirCluster_0
     77            }
   \       0x60   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??addDirCluster_1: (+1)
   \       0x64   0x69E0             LDR      R0,[R4, #+28]
   \       0x66   0x4641             MOV      R1,R8
   \       0x68   0x7902             LDRB     R2,[R0, #+4]
   \       0x6A   0xB2C9             UXTB     R1,R1
   \       0x6C   0x4291             CMP      R1,R2
   \       0x6E   0xD3EF             BCC.N    ??addDirCluster_2
     78            // Increase directory file size by cluster size
     79            fileSize_ += 512UL << vol_->clusterSizeShift_;
   \       0x70   0x6961             LDR      R1,[R4, #+20]
   \       0x72   0x7C00             LDRB     R0,[R0, #+16]
   \       0x74   0x4085             LSLS     R5,R5,R0
   \       0x76   0x186D             ADDS     R5,R5,R1
   \       0x78   0x6165             STR      R5,[R4, #+20]
     80            return true;
   \       0x7A   0x2001             MOVS     R0,#+1
   \       0x7C   0xE000             B.N      ??addDirCluster_3
     81          fail:
     82            return false;
   \                     ??addDirCluster_0: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \                     ??addDirCluster_3: (+1)
   \       0x80   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     83          }
     84          //------------------------------------------------------------------------------
     85          // cache a file's directory entry
     86          // return pointer to cached entry or null for failure

   \                                 In section .text, align 2, keep-with-next
     87          dir_t* SdBaseFile::cacheDirEntry(uint8_t action) {
   \                     _ZN10SdBaseFile13cacheDirEntryEh: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     88            if (!vol_->cacheRawBlock(dirBlock_, action)) goto fail;
   \        0x4   0x4608             MOV      R0,R1
   \        0x6   0x1E40             SUBS     R0,R0,#+1
   \        0x8   0x4180             SBCS     R0,R0,R0
   \        0xA   0x43C0             MVNS     R0,R0
   \        0xC   0x0FC0             LSRS     R0,R0,#+31
   \        0xE   0x4601             MOV      R1,R0
   \       0x10   0x68E0             LDR      R0,[R4, #+12]
   \       0x12   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??cacheDirEntry_0
     89            return vol_->cache()->dir + dirIndex_;
     90          fail:
     91            return 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD10             POP      {R4,PC}
   \                     ??cacheDirEntry_0: (+1)
   \       0x1E   0x69E0             LDR      R0,[R4, #+28]
   \       0x20   0x.... 0x....      BL       _ZN8SdVolume5cacheEv
   \       0x24   0x7C21             LDRB     R1,[R4, #+16]
   \       0x26   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \       0x2A   0xBD10             POP      {R4,PC}          ;; return
     92          }
     93          //------------------------------------------------------------------------------
     94          /** Close a file and force cached data and directory information
     95           *  to be written to the storage device.
     96           *
     97           * \return The value one, true, is returned for success and
     98           * the value zero, false, is returned for failure.
     99           * Reasons for failure include no file is open or an I/O error.
    100           */

   \                                 In section .text, align 2, keep-with-next
    101          bool SdBaseFile::close() {
   \                     _ZN10SdBaseFile5closeEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    102            bool rtn = sync();
   \        0x4   0x.... 0x....      BL       _ZN10SdBaseFile4syncEv
    103            type_ = FAT_FILE_TYPE_CLOSED;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x70E1             STRB     R1,[R4, #+3]
    104            return rtn;
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    105          }
    106          //------------------------------------------------------------------------------
    107          /** Check for contiguous file and return its raw block range.
    108           *
    109           * \param[out] bgnBlock the first block address for the file.
    110           * \param[out] endBlock the last  block address for the file.
    111           *
    112           * \return The value one, true, is returned for success and
    113           * the value zero, false, is returned for failure.
    114           * Reasons for failure include file is not contiguous, file has zero length
    115           * or an I/O error occurred.
    116           */

   \                                 In section .text, align 2, keep-with-next
    117          bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {
   \                     _ZN10SdBaseFile15contiguousRangeEPjS0_: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4615             MOV      R5,R2
    118            // error if no blocks
    119            if (firstCluster_ == 0) goto fail;
   \        0x8   0x69B4             LDR      R4,[R6, #+24]
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD021             BEQ.N    ??contiguousRange_0
    120          
    121            for (uint32_t c = firstCluster_; ; c++) {
   \        0xE   0xE000             B.N      ??contiguousRange_1
   \                     ??contiguousRange_2: (+1)
   \       0x10   0x4604             MOV      R4,R0
    122              uint32_t next;
    123              if (!vol_->fatGet(c, &next)) goto fail;
   \                     ??contiguousRange_1: (+1)
   \       0x12   0x466A             MOV      R2,SP
   \       0x14   0x4621             MOV      R1,R4
   \       0x16   0x69F0             LDR      R0,[R6, #+28]
   \       0x18   0x.... 0x....      BL       _ZN8SdVolume6fatGetEjPj
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD018             BEQ.N    ??contiguousRange_0
    124          
    125              // check for contiguous
    126              if (next != (c + 1)) {
   \       0x20   0x1C60             ADDS     R0,R4,#+1
   \       0x22   0x9900             LDR      R1,[SP, #+0]
   \       0x24   0x4281             CMP      R1,R0
   \       0x26   0xD0F3             BEQ.N    ??contiguousRange_2
    127                // error if not end of chain
    128                if (!vol_->isEOC(next)) goto fail;
   \       0x28   0x69F0             LDR      R0,[R6, #+28]
   \       0x2A   0x.... 0x....      BL       _ZNK8SdVolume5isEOCEj
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD00F             BEQ.N    ??contiguousRange_0
    129                *bgnBlock = vol_->clusterStartBlock(firstCluster_);
   \       0x32   0x69B1             LDR      R1,[R6, #+24]
   \       0x34   0x69F0             LDR      R0,[R6, #+28]
   \       0x36   0x.... 0x....      BL       _ZNK8SdVolume17clusterStartBlockEj
   \       0x3A   0x6038             STR      R0,[R7, #+0]
    130                *endBlock = vol_->clusterStartBlock(c)
    131                            + vol_->blocksPerCluster_ - 1;
   \       0x3C   0x4621             MOV      R1,R4
   \       0x3E   0x69F0             LDR      R0,[R6, #+28]
   \       0x40   0x.... 0x....      BL       _ZNK8SdVolume17clusterStartBlockEj
   \       0x44   0x69F1             LDR      R1,[R6, #+28]
   \       0x46   0x7909             LDRB     R1,[R1, #+4]
   \       0x48   0x1808             ADDS     R0,R1,R0
   \       0x4A   0x1E40             SUBS     R0,R0,#+1
   \       0x4C   0x6028             STR      R0,[R5, #+0]
    132                return true;
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0xBDF2             POP      {R1,R4-R7,PC}
    133              }
    134            }
    135          
    136          fail:
    137            return false;
   \                     ??contiguousRange_0: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    138          }
    139          //------------------------------------------------------------------------------
    140          /** Create and open a new contiguous file of a specified size.
    141           *
    142           * \note This function only supports short DOS 8.3 names.
    143           * See open() for more information.
    144           *
    145           * \param[in] dirFile The directory where the file will be created.
    146           * \param[in] path A path with a valid DOS 8.3 file name.
    147           * \param[in] size The desired file size.
    148           *
    149           * \return The value one, true, is returned for success and
    150           * the value zero, false, is returned for failure.
    151           * Reasons for failure include \a path contains
    152           * an invalid DOS 8.3 file name, the FAT volume has not been initialized,
    153           * a file is already open, the file already exists, the root
    154           * directory is full or an I/O error.
    155           *
    156           */

   \                                 In section .text, align 2, keep-with-next
    157          bool SdBaseFile::createContiguous(SdBaseFile* dirFile,
    158                                            const char* path, uint32_t size) {
   \                     _ZN10SdBaseFile16createContiguousEPS_PKcj: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x001C             MOVS     R4,R3
    159            uint32_t count;
    160            // don't allow zero length file
    161            if (size == 0) goto fail;
   \        0x6   0xD013             BEQ.N    ??createContiguous_0
    162            if (!open(dirFile, path, O_CREAT | O_EXCL | O_RDWR)) goto fail;
   \        0x8   0x23C3             MOVS     R3,#+195
   \        0xA   0x.... 0x....      BL       _ZN10SdBaseFile4openEPS_PKch
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD00E             BEQ.N    ??createContiguous_0
    163          
    164            // calculate number of clusters needed
    165            count = ((size - 1) >> (vol_->clusterSizeShift_ + 9)) + 1;
    166          
    167            // allocate clusters
    168            if (!vol_->allocContiguous(count, &firstCluster_)) {
   \       0x12   0x69E8             LDR      R0,[R5, #+28]
   \       0x14   0xF105 0x0218      ADD      R2,R5,#+24
   \       0x18   0x1E61             SUBS     R1,R4,#+1
   \       0x1A   0x7C03             LDRB     R3,[R0, #+16]
   \       0x1C   0x3309             ADDS     R3,R3,#+9
   \       0x1E   0x40D9             LSRS     R1,R1,R3
   \       0x20   0x1C49             ADDS     R1,R1,#+1
   \       0x22   0x.... 0x....      BL       _ZN8SdVolume15allocContiguousEjPj
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD104             BNE.N    ??createContiguous_1
    169              remove();
   \       0x2A   0x4628             MOV      R0,R5
   \       0x2C   0x.... 0x....      BL       _ZN10SdBaseFile6removeEv
    170              goto fail;
    171            }
    172            fileSize_ = size;
    173          
    174            // insure sync() will update dir entry
    175            flags_ |= F_FILE_DIR_DIRTY;
    176          
    177            return sync();
    178          fail:
    179            return false;
   \                     ??createContiguous_0: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??createContiguous_1: (+1)
   \       0x34   0x616C             STR      R4,[R5, #+20]
   \       0x36   0x7868             LDRB     R0,[R5, #+1]
   \       0x38   0xF040 0x0080      ORR      R0,R0,#0x80
   \       0x3C   0x7068             STRB     R0,[R5, #+1]
   \       0x3E   0x4628             MOV      R0,R5
   \       0x40   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x44   0x.... 0x....      B.W      _ZN10SdBaseFile4syncEv
    180          }
    181          //------------------------------------------------------------------------------
    182          /** Return a file's directory entry.
    183           *
    184           * \param[out] dir Location for return of the file's directory entry.
    185           *
    186           * \return The value one, true, is returned for success and
    187           * the value zero, false, is returned for failure.
    188           */

   \                                 In section .text, align 2, keep-with-next
    189          bool SdBaseFile::dirEntry(dir_t* dir) {
   \                     _ZN10SdBaseFile8dirEntryEP14directoryEntry: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    190            dir_t* p;
    191            // make sure fields on SD are correct
    192            if (!sync()) goto fail;
   \        0x6   0x.... 0x....      BL       _ZN10SdBaseFile4syncEv
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD00B             BEQ.N    ??dirEntry_0
    193          
    194            // read entry
    195            p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x.... 0x....      BL       _ZN10SdBaseFile13cacheDirEntryEh
   \       0x16   0x0001             MOVS     R1,R0
    196            if (!p) goto fail;
   \       0x18   0xD005             BEQ.N    ??dirEntry_0
    197          
    198            // copy to caller's struct
    199            memcpy(dir, p, sizeof(dir_t));
   \       0x1A   0x2220             MOVS     R2,#+32
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x.... 0x....      BL       __aeabi_memcpy
    200            return true;
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}
    201          fail:
    202            return false;
   \                     ??dirEntry_0: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    203          }
    204          //------------------------------------------------------------------------------
    205          /** Format the name field of \a dir into the 13 byte array
    206           * \a name in standard 8.3 short name format.
    207           *
    208           * \param[in] dir The directory structure containing the name.
    209           * \param[out] name A 13 byte char array for the formatted name.
    210           */

   \                                 In section .text, align 2, keep-with-next
    211          void SdBaseFile::dirName(const dir_t& dir, char* name) {
   \                     _ZN10SdBaseFile7dirNameERK14directoryEntryPc: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    212            uint8_t j = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    213            for (uint8_t i = 0; i < 11; i++) {
   \        0x4   0x4613             MOV      R3,R2
   \        0x6   0xE00F             B.N      ??dirName_0
    214              if (dir.name[i] == ' ')continue;
   \                     ??dirName_1: (+1)
   \        0x8   0x5CC4             LDRB     R4,[R0, R3]
   \        0xA   0x2C20             CMP      R4,#+32
   \        0xC   0xD00B             BEQ.N    ??dirName_2
    215              if (i == 8) name[j++] = '.';
   \        0xE   0x2B08             CMP      R3,#+8
   \       0x10   0xD104             BNE.N    ??dirName_3
   \       0x12   0x242E             MOVS     R4,#+46
   \       0x14   0x4615             MOV      R5,R2
   \       0x16   0xB2ED             UXTB     R5,R5
   \       0x18   0x554C             STRB     R4,[R1, R5]
   \       0x1A   0x1C52             ADDS     R2,R2,#+1
    216              name[j++] = dir.name[i];
   \                     ??dirName_3: (+1)
   \       0x1C   0x56C4             LDRSB    R4,[R0, R3]
   \       0x1E   0x4615             MOV      R5,R2
   \       0x20   0xB2ED             UXTB     R5,R5
   \       0x22   0x554C             STRB     R4,[R1, R5]
   \       0x24   0x1C52             ADDS     R2,R2,#+1
    217            }
   \                     ??dirName_2: (+1)
   \       0x26   0x1C5B             ADDS     R3,R3,#+1
   \                     ??dirName_0: (+1)
   \       0x28   0x2B0B             CMP      R3,#+11
   \       0x2A   0xDBED             BLT.N    ??dirName_1
    218            name[j] = 0;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xB2D2             UXTB     R2,R2
   \       0x30   0x5488             STRB     R0,[R1, R2]
    219          }
   \       0x32   0xBC30             POP      {R4,R5}
   \       0x34   0x4770             BX       LR               ;; return
    220          //------------------------------------------------------------------------------
    221          /** Test for the existence of a file in a directory
    222           *
    223           * \param[in] name Name of the file to be tested for.
    224           *
    225           * The calling instance must be an open directory file.
    226           *
    227           * dirFile.exists("TOFIND.TXT") searches for "TOFIND.TXT" in  the directory
    228           * dirFile.
    229           *
    230           * \return true if the file exists else false.
    231           */

   \                                 In section .text, align 2, keep-with-next
    232          bool SdBaseFile::exists(const char* name) {
   \                     _ZN10SdBaseFile6existsEPKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
    233            SdBaseFile file;
   \        0x8   0x4668             MOV      R0,SP
   \        0xA   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
    234            return file.open(this, name, O_READ);
   \        0xE   0x2301             MOVS     R3,#+1
   \       0x10   0x462A             MOV      R2,R5
   \       0x12   0x4621             MOV      R1,R4
   \       0x14   0x.... 0x....      BL       _ZN10SdBaseFile4openEPS_PKch
   \       0x18   0x4604             MOV      R4,R0
   \       0x1A   0x4668             MOV      R0,SP
   \       0x1C   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0xB009             ADD      SP,SP,#+36
   \       0x24   0xBD30             POP      {R4,R5,PC}       ;; return
    235          }
    236          //------------------------------------------------------------------------------
    237          /**
    238           * Get a string from a file.
    239           *
    240           * fgets() reads bytes from a file into the array pointed to by \a str, until
    241           * \a num - 1 bytes are read, or a delimiter is read and transferred to \a str,
    242           * or end-of-file is encountered. The string is then terminated
    243           * with a null byte.
    244           *
    245           * fgets() deletes CR, '\\r', from the string.  This insures only a '\\n'
    246           * terminates the string for Windows text files which use CRLF for newline.
    247           *
    248           * \param[out] str Pointer to the array where the string is stored.
    249           * \param[in] num Maximum number of characters to be read
    250           * (including the final null byte). Usually the length
    251           * of the array \a str is used.
    252           * \param[in] delim Optional set of delimiters. The default is "\n".
    253           *
    254           * \return For success fgets() returns the length of the string in \a str.
    255           * If no data is read, fgets() returns zero for EOF or -1 if an error occurred.
    256           **/

   \                                 In section .text, align 2, keep-with-next
    257          int16_t SdBaseFile::fgets(char* str, int16_t num, char* delim) {
   \                     _ZN10SdBaseFile5fgetsEPcsS0_: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x4692             MOV      R10,R2
   \        0xA   0x461E             MOV      R6,R3
    258            char ch;
    259            int16_t n = 0;
   \        0xC   0x2400             MOVS     R4,#+0
    260            int16_t r = -1;
   \        0xE   0xF04F 0x37FF      MOV      R7,#-1
    261            while ((n + 1) < num && (r = read(&ch, 1)) == 1) {
   \                     ??fgets_0: (+1)
   \       0x12   0x4625             MOV      R5,R4
   \       0x14   0xB22D             SXTH     R5,R5
   \       0x16   0x1C68             ADDS     R0,R5,#+1
   \       0x18   0x4651             MOV      R1,R10
   \       0x1A   0x4288             CMP      R0,R1
   \       0x1C   0xDA16             BGE.N    ??fgets_1
   \       0x1E   0x2201             MOVS     R2,#+1
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0x4640             MOV      R0,R8
   \       0x24   0x.... 0x....      BL       _ZN10SdBaseFile4readEPvt
   \       0x28   0x4607             MOV      R7,R0
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD10E             BNE.N    ??fgets_1
    262              // delete CR
    263              if (ch == '\r') continue;
   \       0x2E   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \       0x32   0x280D             CMP      R0,#+13
   \       0x34   0xD0ED             BEQ.N    ??fgets_0
    264              str[n++] = ch;
   \       0x36   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x3A   0xF809 0x0005      STRB     R0,[R9, R5]
   \       0x3E   0x1C64             ADDS     R4,R4,#+1
    265              if (!delim) {
   \       0x40   0x2E00             CMP      R6,#+0
   \       0x42   0xD108             BNE.N    ??fgets_2
    266                if (ch == '\n') break;
   \       0x44   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \       0x48   0x280A             CMP      R0,#+10
   \       0x4A   0xD1E2             BNE.N    ??fgets_0
    267              }
    268              else {
    269                if (strchr(delim, ch)) break;
    270              }
    271            }
    272            if (r < 0) {
   \                     ??fgets_1: (+1)
   \       0x4C   0x2F00             CMP      R7,#+0
   \       0x4E   0xD50A             BPL.N    ??fgets_3
    273              // read error
    274              return -1;
   \       0x50   0xF04F 0x30FF      MOV      R0,#-1
   \       0x54   0xE00E             B.N      ??fgets_4
    275            }
   \                     ??fgets_2: (+1)
   \       0x56   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \       0x5A   0x4630             MOV      R0,R6
   \       0x5C   0x.... 0x....      BL       __iar_Strchr
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD0D6             BEQ.N    ??fgets_0
   \       0x64   0xE7F2             B.N      ??fgets_1
    276            str[n] = '\0';
   \                     ??fgets_3: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x4621             MOV      R1,R4
   \       0x6A   0xB209             SXTH     R1,R1
   \       0x6C   0xF809 0x0001      STRB     R0,[R9, R1]
    277            return n;
   \       0x70   0x4620             MOV      R0,R4
   \       0x72   0xB200             SXTH     R0,R0
   \                     ??fgets_4: (+1)
   \       0x74   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    278          }
    279          //------------------------------------------------------------------------------
    280          /** Get a file's name
    281           *
    282           * \param[out] name An array of 13 characters for the file's name.
    283           *
    284           * \return The value one, true, is returned for success and
    285           * the value zero, false, is returned for failure.
    286           */

   \                                 In section .text, align 2, keep-with-next
    287          bool SdBaseFile::getFilename(char* name) {
   \                     _ZN10SdBaseFile11getFilenameEPc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    288            if (!isOpen()) return false;
   \        0x6   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??getFilename_0
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
    289          
    290            if (isRoot()) {
   \                     ??getFilename_0: (+1)
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       _ZNK10SdBaseFile6isRootEv
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD005             BEQ.N    ??getFilename_1
    291              name[0] = '/';
   \       0x1C   0x202F             MOVS     R0,#+47
   \       0x1E   0x7028             STRB     R0,[R5, #+0]
    292              name[1] = '\0';
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x7068             STRB     R0,[R5, #+1]
    293              return true;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}
    294            }
    295            // cache entry
    296            dir_t* p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
   \                     ??getFilename_1: (+1)
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       _ZN10SdBaseFile13cacheDirEntryEh
    297            if (!p) return false;
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD101             BNE.N    ??getFilename_2
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
    298          
    299            // format name
    300            dirName(*p, name);
   \                     ??getFilename_2: (+1)
   \       0x38   0x4629             MOV      R1,R5
   \       0x3A   0x.... 0x....      BL       _ZN10SdBaseFile7dirNameERK14directoryEntryPc
    301          
    302            
    303            return true;
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    304          }
    305          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    306          void SdBaseFile::getpos(filepos_t* pos) {
    307            pos->position = curPosition_;
   \                     _ZN10SdBaseFile6getposEP9filepos_t: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   \        0x2   0x600A             STR      R2,[R1, #+0]
    308            pos->cluster = curCluster_;
   \        0x4   0x6840             LDR      R0,[R0, #+4]
   \        0x6   0x6048             STR      R0,[R1, #+4]
    309          }
   \        0x8   0x4770             BX       LR               ;; return
    310          
    311          //------------------------------------------------------------------------------
    312          /** List directory contents.
    313           *
    314           * \param[in] pr Print stream for list.
    315           *
    316           * \param[in] flags The inclusive OR of
    317           *
    318           * LS_DATE - %Print file modification date
    319           *
    320           * LS_SIZE - %Print file size.
    321           *
    322           * LS_R - Recursive list of subdirectories.
    323           *
    324           * \param[in] indent Amount of space before file name. Used for recursive
    325           * list to indicate subdirectory level.
    326           */

   \                                 In section .text, align 2, keep-with-next
    327          void SdBaseFile::ls(uint8_t flags, uint8_t indent) {
   \                     _ZN10SdBaseFile2lsEhh: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    328            rewind();
   \        0xA   0x.... 0x....      BL       _ZN10SdBaseFile6rewindEv
   \        0xE   0xE024             B.N      ??ls_0
    329            int8_t status;
    330            while ((status = lsPrintNext(flags, indent))) {
    331              if (status > 1 && (flags & LS_R)) {
   \                     ??ls_1: (+1)
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xDD22             BLE.N    ??ls_0
   \       0x14   0x0768             LSLS     R0,R5,#+29
   \       0x16   0xD520             BPL.N    ??ls_0
    332                uint16_t index = curPosition() / 32 - 1;
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x.... 0x....      BL       _ZNK10SdBaseFile11curPositionEv
   \       0x1E   0x4607             MOV      R7,R0
   \       0x20   0x097F             LSRS     R7,R7,#+5
   \       0x22   0x1E7F             SUBS     R7,R7,#+1
    333                SdBaseFile s;
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
    334                if (s.open(this, index, O_READ)) s.ls(flags, indent + 2);
   \       0x2A   0x2301             MOVS     R3,#+1
   \       0x2C   0x463A             MOV      R2,R7
   \       0x2E   0xB292             UXTH     R2,R2
   \       0x30   0x4621             MOV      R1,R4
   \       0x32   0x.... 0x....      BL       _ZN10SdBaseFile4openEPS_th
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD005             BEQ.N    ??ls_2
   \       0x3A   0x1CB2             ADDS     R2,R6,#+2
   \       0x3C   0xB2D2             UXTB     R2,R2
   \       0x3E   0x4629             MOV      R1,R5
   \       0x40   0x4668             MOV      R0,SP
   \       0x42   0xF7FF 0xFFDD      BL       _ZN10SdBaseFile2lsEhh
    335                seekSet(32 * (index + 1));
   \                     ??ls_2: (+1)
   \       0x46   0xB2BF             UXTH     R7,R7
   \       0x48   0x1C7F             ADDS     R7,R7,#+1
   \       0x4A   0x017F             LSLS     R7,R7,#+5
   \       0x4C   0x4639             MOV      R1,R7
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0x.... 0x....      BL       _ZN10SdBaseFile7seekSetEj
    336              }
   \       0x54   0x4668             MOV      R0,SP
   \       0x56   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
    337            }
   \                     ??ls_0: (+1)
   \       0x5A   0x4632             MOV      R2,R6
   \       0x5C   0x4629             MOV      R1,R5
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0x.... 0x....      BL       _ZN10SdBaseFile11lsPrintNextEhh
   \       0x64   0x0001             MOVS     R1,R0
   \       0x66   0xD1D3             BNE.N    ??ls_1
    338          }
   \       0x68   0xB009             ADD      SP,SP,#+36
   \       0x6A   0xBDF0             POP      {R4-R7,PC}       ;; return
    339          //------------------------------------------------------------------------------
    340          // saves 32 bytes on stack for ls recursion
    341          // return 0 - EOF, 1 - normal file, or 2 - directory

   \                                 In section .text, align 2, keep-with-next
    342          int8_t SdBaseFile::lsPrintNext(uint8_t flags, uint8_t indent) {
   \                     _ZN10SdBaseFile11lsPrintNextEhh: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4607             MOV      R7,R0
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x4616             MOV      R6,R2
    343            dir_t dir;
    344            uint8_t w = 0;
   \        0xC   0x2500             MOVS     R5,#+0
    345          
    346            while (1) {
    347              if (read(&dir, sizeof(dir)) != sizeof(dir)) return 0;
   \                     ??lsPrintNext_0: (+1)
   \        0xE   0x2220             MOVS     R2,#+32
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x4638             MOV      R0,R7
   \       0x14   0x.... 0x....      BL       _ZN10SdBaseFile4readEPvt
   \       0x18   0xB280             UXTH     R0,R0
   \       0x1A   0x2820             CMP      R0,#+32
   \       0x1C   0xD177             BNE.N    ??lsPrintNext_1
    348              if (dir.name[0] == DIR_NAME_FREE) return 0;
   \       0x1E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD073             BEQ.N    ??lsPrintNext_1
    349          
    350              // skip deleted entry and entries for . and  ..
    351              if (dir.name[0] != DIR_NAME_DELETED && dir.name[0] != '.'
    352                  && DIR_IS_FILE_OR_SUBDIR(&dir)) break;
   \       0x26   0x28E5             CMP      R0,#+229
   \       0x28   0xD0F1             BEQ.N    ??lsPrintNext_0
   \       0x2A   0x282E             CMP      R0,#+46
   \       0x2C   0xD0EF             BEQ.N    ??lsPrintNext_0
   \       0x2E   0x4668             MOV      R0,SP
   \       0x30   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f21DIR_IS_FILE_OR_SUBDIREPK14directoryEntry
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD0EA             BEQ.N    ??lsPrintNext_0
    353            }
    354            // indent for dir level
    355            for (uint8_t i = 0; i < indent; i++) MYSERIAL.write(' ');
   \       0x38   0x46A8             MOV      R8,R5
   \       0x3A   0x.... 0x....      LDR.W    R7,??DataTable11_1
   \       0x3E   0xE005             B.N      ??lsPrintNext_2
   \                     ??lsPrintNext_3: (+1)
   \       0x40   0x2120             MOVS     R1,#+32
   \       0x42   0x4638             MOV      R0,R7
   \       0x44   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x48   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??lsPrintNext_2: (+1)
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0x4631             MOV      R1,R6
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0x4288             CMP      R0,R1
   \       0x54   0xD3F4             BCC.N    ??lsPrintNext_3
    356          
    357            // print name
    358            for (uint8_t i = 0; i < 11; i++) {
   \       0x56   0x462E             MOV      R6,R5
   \       0x58   0xE010             B.N      ??lsPrintNext_4
    359              if (dir.name[i] == ' ')continue;
   \                     ??lsPrintNext_5: (+1)
   \       0x5A   0x5D80             LDRB     R0,[R0, R6]
   \       0x5C   0x2820             CMP      R0,#+32
   \       0x5E   0xD00C             BEQ.N    ??lsPrintNext_6
    360              if (i == 8) {
   \       0x60   0x2E08             CMP      R6,#+8
   \       0x62   0xD104             BNE.N    ??lsPrintNext_7
    361                MYSERIAL.write('.');
   \       0x64   0x212E             MOVS     R1,#+46
   \       0x66   0x4638             MOV      R0,R7
   \       0x68   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    362                w++;
   \       0x6C   0x1C6D             ADDS     R5,R5,#+1
    363              }
    364              MYSERIAL.write(dir.name[i]);
   \                     ??lsPrintNext_7: (+1)
   \       0x6E   0x4668             MOV      R0,SP
   \       0x70   0x5D81             LDRB     R1,[R0, R6]
   \       0x72   0x4638             MOV      R0,R7
   \       0x74   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    365              w++;
   \       0x78   0x1C6D             ADDS     R5,R5,#+1
    366            }
   \                     ??lsPrintNext_6: (+1)
   \       0x7A   0x1C76             ADDS     R6,R6,#+1
   \                     ??lsPrintNext_4: (+1)
   \       0x7C   0x2E0A             CMP      R6,#+10
   \       0x7E   0x4668             MOV      R0,SP
   \       0x80   0xDDEB             BLE.N    ??lsPrintNext_5
    367            if (DIR_IS_SUBDIR(&dir)) {
   \       0x82   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f13DIR_IS_SUBDIREPK14directoryEntry
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD004             BEQ.N    ??lsPrintNext_8
    368              MYSERIAL.write('/');
   \       0x8A   0x212F             MOVS     R1,#+47
   \       0x8C   0x4638             MOV      R0,R7
   \       0x8E   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    369              w++;
   \       0x92   0x1C6D             ADDS     R5,R5,#+1
    370            }
    371            if (flags & (LS_DATE | LS_SIZE)) {
   \                     ??lsPrintNext_8: (+1)
   \       0x94   0xF014 0x0F03      TST      R4,#0x3
   \       0x98   0xD104             BNE.N    ??lsPrintNext_9
   \       0x9A   0xE008             B.N      ??lsPrintNext_10
    372              while (w++ < 14) MYSERIAL.write(' ');
   \                     ??lsPrintNext_11: (+1)
   \       0x9C   0x2120             MOVS     R1,#+32
   \       0x9E   0x4638             MOV      R0,R7
   \       0xA0   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \                     ??lsPrintNext_9: (+1)
   \       0xA4   0x4628             MOV      R0,R5
   \       0xA6   0x1C45             ADDS     R5,R0,#+1
   \       0xA8   0xB2C0             UXTB     R0,R0
   \       0xAA   0x280E             CMP      R0,#+14
   \       0xAC   0xDBF6             BLT.N    ??lsPrintNext_11
    373            }
    374            // print modify date/time if requested
    375            if (flags & LS_DATE) {
   \                     ??lsPrintNext_10: (+1)
   \       0xAE   0x07E0             LSLS     R0,R4,#+31
   \       0xB0   0xD50F             BPL.N    ??lsPrintNext_12
    376              MYSERIAL.write(' ');
   \       0xB2   0x2120             MOVS     R1,#+32
   \       0xB4   0x4638             MOV      R0,R7
   \       0xB6   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    377              printFatDate(dir.lastWriteDate);
   \       0xBA   0xF8BD 0x0018      LDRH     R0,[SP, #+24]
   \       0xBE   0x.... 0x....      BL       _ZN10SdBaseFile12printFatDateEt
    378              MYSERIAL.write(' ');
   \       0xC2   0x2120             MOVS     R1,#+32
   \       0xC4   0x4638             MOV      R0,R7
   \       0xC6   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    379              printFatTime(dir.lastWriteTime);
   \       0xCA   0xF8BD 0x0016      LDRH     R0,[SP, #+22]
   \       0xCE   0x.... 0x....      BL       _ZN10SdBaseFile12printFatTimeEt
    380            }
    381            // print size if requested
    382            if (!DIR_IS_SUBDIR(&dir) && (flags & LS_SIZE)) {
   \                     ??lsPrintNext_12: (+1)
   \       0xD2   0x4668             MOV      R0,SP
   \       0xD4   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f13DIR_IS_SUBDIREPK14directoryEntry
   \       0xD8   0x2800             CMP      R0,#+0
   \       0xDA   0xD10A             BNE.N    ??lsPrintNext_13
   \       0xDC   0x07A0             LSLS     R0,R4,#+30
   \       0xDE   0xD508             BPL.N    ??lsPrintNext_13
    383              MYSERIAL.write(' ');
   \       0xE0   0x2120             MOVS     R1,#+32
   \       0xE2   0x4638             MOV      R0,R7
   \       0xE4   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    384              MYSERIAL.print(dir.fileSize);
   \       0xE8   0x220A             MOVS     R2,#+10
   \       0xEA   0x9907             LDR      R1,[SP, #+28]
   \       0xEC   0x4638             MOV      R0,R7
   \       0xEE   0x.... 0x....      BL       _ZN12MarlinSerial5printEji
    385            }
    386            MYSERIAL.println();
   \                     ??lsPrintNext_13: (+1)
   \       0xF2   0x4638             MOV      R0,R7
   \       0xF4   0x.... 0x....      BL       _ZN12MarlinSerial7printlnEv
    387            return DIR_IS_FILE(&dir) ? 1 : 2;
   \       0xF8   0x4668             MOV      R0,SP
   \       0xFA   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f11DIR_IS_FILEEPK14directoryEntry
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD001             BEQ.N    ??lsPrintNext_14
   \      0x102   0x2001             MOVS     R0,#+1
   \      0x104   0xE000             B.N      ??lsPrintNext_15
   \                     ??lsPrintNext_14: (+1)
   \      0x106   0x2002             MOVS     R0,#+2
   \                     ??lsPrintNext_15: (+1)
   \      0x108   0xB008             ADD      SP,SP,#+32
   \      0x10A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??lsPrintNext_1: (+1)
   \      0x10E   0x4628             MOV      R0,R5
   \      0x110   0xE7FA             B.N      ??lsPrintNext_15
    388          }
    389          //------------------------------------------------------------------------------
    390          // format directory name field from a 8.3 name string

   \                                 In section .text, align 4, keep-with-next
    391          bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {
   \                     _ZN10SdBaseFile10make83NameEPKcPhPS1_: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x4603             MOV      R3,R0
    392            uint8_t c;
    393            uint8_t n = 7;  // max index for part before dot
   \        0x4   0x2407             MOVS     R4,#+7
    394            uint8_t i = 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x2620             MOVS     R6,#+32
   \        0xA   0xE001             B.N      ??make83Name_0
    395            // blank fill name and extension
    396            while (i < 11) name[i++] = ' ';
   \                     ??make83Name_1: (+1)
   \        0xC   0x554E             STRB     R6,[R1, R5]
   \        0xE   0x1C40             ADDS     R0,R0,#+1
   \                     ??make83Name_0: (+1)
   \       0x10   0x4605             MOV      R5,R0
   \       0x12   0xB2ED             UXTB     R5,R5
   \       0x14   0x2D0A             CMP      R5,#+10
   \       0x16   0xDDF9             BLE.N    ??make83Name_1
    397            i = 0;
   \       0x18   0x2500             MOVS     R5,#+0
   \       0x1A   0xE003             B.N      ??make83Name_2
    398            while (*str != '\0' && *str != '/') {
    399              c = *str++;
    400              if (c == '.') {
    401                if (n == 10) goto fail;  // only one dot allowed
   \                     ??make83Name_3: (+1)
   \       0x1C   0x2C0A             CMP      R4,#+10
   \       0x1E   0xD016             BEQ.N    ??make83Name_4
    402                n = 10;  // max index for full 8.3 name
   \       0x20   0x240A             MOVS     R4,#+10
    403                i = 8;   // place for extension
   \       0x22   0x2508             MOVS     R5,#+8
    404              }
   \                     ??make83Name_2: (+1)
   \       0x24   0xF993 0x0000      LDRSB    R0,[R3, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD016             BEQ.N    ??make83Name_5
   \       0x2C   0x282F             CMP      R0,#+47
   \       0x2E   0xD014             BEQ.N    ??make83Name_5
   \       0x30   0xF913 0x0B01      LDRSB    R0,[R3], #+1
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x282E             CMP      R0,#+46
   \       0x38   0xD0F0             BEQ.N    ??make83Name_3
    405              else {
    406                // illegal FAT characters
    407                PGM_P p = PSTR("|<>^+=?/[];,*\"\\");
   \       0x3A   0xBF00             Nop      
   \       0x3C   0x....             ADR.N    R6,?_0
    408                uint8_t b;
    409                while ((b = pgm_read_byte(p++))) if (b == c) goto fail;
   \                     ??make83Name_6: (+1)
   \       0x3E   0xF816 0x7B01      LDRB     R7,[R6], #+1
   \       0x42   0x46BC             MOV      R12,R7
   \       0x44   0xF1BC 0x0F00      CMP      R12,#+0
   \       0x48   0xD00F             BEQ.N    ??make83Name_7
   \       0x4A   0x4287             CMP      R7,R0
   \       0x4C   0xD1F7             BNE.N    ??make83Name_6
    410                // check size and only allow ASCII printable characters
    411                if (i > n || c < 0x21 || c == 0x7F) goto fail;
    412                // only upper case allowed in 8.3 names - convert lower to upper
    413                name[i++] = (c < 'a' || c > 'z') ? (c) : (c + ('A' - 'a'));
    414              }
    415            }
    416            *ptr = str;
    417            // must have a file name, extension is optional
    418            return name[0] != ' ';
    419          fail:
    420            return false;
   \                     ??make83Name_4: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??make83Name_8: (+1)
   \       0x50   0xBCF0             POP      {R4-R7}
   \       0x52   0x4770             BX       LR               ;; return
   \                     ??make83Name_9: (+1)
   \       0x54   0x3820             SUBS     R0,R0,#+32
   \                     ??make83Name_10: (+1)
   \       0x56   0x5588             STRB     R0,[R1, R6]
   \       0x58   0xE7E4             B.N      ??make83Name_2
   \                     ??make83Name_5: (+1)
   \       0x5A   0x6013             STR      R3,[R2, #+0]
   \       0x5C   0x7808             LDRB     R0,[R1, #+0]
   \       0x5E   0x2820             CMP      R0,#+32
   \       0x60   0xD001             BEQ.N    ??make83Name_11
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0xE7F4             B.N      ??make83Name_8
   \                     ??make83Name_11: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE7F2             B.N      ??make83Name_8
   \                     ??make83Name_7: (+1)
   \       0x6A   0x462E             MOV      R6,R5
   \       0x6C   0xB2F6             UXTB     R6,R6
   \       0x6E   0x42B4             CMP      R4,R6
   \       0x70   0xDBED             BLT.N    ??make83Name_4
   \       0x72   0x2821             CMP      R0,#+33
   \       0x74   0xDBEB             BLT.N    ??make83Name_4
   \       0x76   0x287F             CMP      R0,#+127
   \       0x78   0xD0E9             BEQ.N    ??make83Name_4
   \       0x7A   0x1C6D             ADDS     R5,R5,#+1
   \       0x7C   0xF1A0 0x0761      SUB      R7,R0,#+97
   \       0x80   0x2F1A             CMP      R7,#+26
   \       0x82   0xD3E7             BCC.N    ??make83Name_9
   \       0x84   0xE7E7             B.N      ??make83Name_10
    421          }
    422          //------------------------------------------------------------------------------
    423          /** Make a new directory.
    424           *
    425           * \param[in] parent An open SdFat instance for the directory that will contain
    426           * the new directory.
    427           *
    428           * \param[in] path A path with a valid 8.3 DOS name for the new directory.
    429           *
    430           * \param[in] pFlag Create missing parent directories if true.
    431           *
    432           * \return The value one, true, is returned for success and
    433           * the value zero, false, is returned for failure.
    434           * Reasons for failure include this file is already open, \a parent is not a
    435           * directory, \a path is invalid or already exists in \a parent.
    436           */

   \                                 In section .text, align 2, keep-with-next
    437          bool SdBaseFile::mkdir(SdBaseFile* parent, const char* path, bool pFlag) {
   \                     _ZN10SdBaseFile5mkdirEPS_PKcb: (+1)
   \        0x0   0xE92D 0x41F4      PUSH     {R2,R4-R8,LR}
   \        0x4   0xB093             SUB      SP,SP,#+76
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x461F             MOV      R7,R3
    438            uint8_t dname[11];
    439            SdBaseFile dir1, dir2;
   \        0xC   0xA80B             ADD      R0,SP,#+44
   \        0xE   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
   \       0x12   0xA803             ADD      R0,SP,#+12
   \       0x14   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
    440            SdBaseFile* sub = &dir1;
   \       0x18   0xAD0B             ADD      R5,SP,#+44
    441            SdBaseFile* start = parent;
   \       0x1A   0x0026             MOVS     R6,R4
    442          
    443            if (!parent || isOpen()) goto fail;
   \       0x1C   0xD027             BEQ.N    ??mkdir_0
   \       0x1E   0x4640             MOV      R0,R8
   \       0x20   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD122             BNE.N    ??mkdir_0
    444          
    445            if (*path == '/') {
   \       0x28   0x9813             LDR      R0,[SP, #+76]
   \       0x2A   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \       0x2E   0x282F             CMP      R0,#+47
   \       0x30   0xD116             BNE.N    ??mkdir_1
   \       0x32   0xE002             B.N      ??mkdir_2
    446              while (*path == '/') path++;
   \                     ??mkdir_3: (+1)
   \       0x34   0x9813             LDR      R0,[SP, #+76]
   \       0x36   0x1C40             ADDS     R0,R0,#+1
   \       0x38   0x9013             STR      R0,[SP, #+76]
   \                     ??mkdir_2: (+1)
   \       0x3A   0x9813             LDR      R0,[SP, #+76]
   \       0x3C   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \       0x40   0x282F             CMP      R0,#+47
   \       0x42   0xD0F7             BEQ.N    ??mkdir_3
    447              if (!parent->isRoot()) {
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0x.... 0x....      BL       _ZNK10SdBaseFile6isRootEv
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD108             BNE.N    ??mkdir_1
    448                if (!dir2.openRoot(parent->vol_)) goto fail;
   \       0x4E   0x69E1             LDR      R1,[R4, #+28]
   \       0x50   0xA803             ADD      R0,SP,#+12
   \       0x52   0x.... 0x....      BL       _ZN10SdBaseFile8openRootEP8SdVolume
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD009             BEQ.N    ??mkdir_0
    449                parent = &dir2;
   \       0x5A   0xAC03             ADD      R4,SP,#+12
   \       0x5C   0xE000             B.N      ??mkdir_1
    450              }
    451            }
    452            while (1) {
    453              if (!make83Name(path, dname, &path)) goto fail;
    454              while (*path == '/') path++;
    455              if (!*path) break;
    456              if (!sub->open(parent, dname, O_READ)) {
    457                if (!pFlag || !sub->mkdir(parent, dname)) {
    458                  goto fail;
    459                }
    460              }
    461              if (parent != start) parent->close();
    462              parent = sub;
    463              sub = parent != &dir1 ? &dir1 : &dir2;
   \                     ??mkdir_4: (+1)
   \       0x5E   0xAD0B             ADD      R5,SP,#+44
   \                     ??mkdir_1: (+1)
   \       0x60   0xAA13             ADD      R2,SP,#+76
   \       0x62   0x4669             MOV      R1,SP
   \       0x64   0x9813             LDR      R0,[SP, #+76]
   \       0x66   0x.... 0x....      BL       _ZN10SdBaseFile10make83NameEPKcPhPS1_
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD10C             BNE.N    ??mkdir_5
    464            }
    465            return mkdir(parent, dname);
    466          fail:
    467            return false;
   \                     ??mkdir_0: (+1)
   \       0x6E   0xA803             ADD      R0,SP,#+12
   \       0x70   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0x74   0xA80B             ADD      R0,SP,#+44
   \       0x76   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0x7A   0x2000             MOVS     R0,#+0
   \                     ??mkdir_6: (+1)
   \       0x7C   0xB014             ADD      SP,SP,#+80
   \       0x7E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??mkdir_7: (+1)
   \       0x82   0x9813             LDR      R0,[SP, #+76]
   \       0x84   0x1C40             ADDS     R0,R0,#+1
   \       0x86   0x9013             STR      R0,[SP, #+76]
   \                     ??mkdir_5: (+1)
   \       0x88   0x9813             LDR      R0,[SP, #+76]
   \       0x8A   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \       0x8E   0x282F             CMP      R0,#+47
   \       0x90   0xD0F7             BEQ.N    ??mkdir_7
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD10D             BNE.N    ??mkdir_8
   \       0x96   0x466A             MOV      R2,SP
   \       0x98   0x4621             MOV      R1,R4
   \       0x9A   0x4640             MOV      R0,R8
   \       0x9C   0x.... 0x....      BL       _ZN10SdBaseFile5mkdirEPS_PKh
   \       0xA0   0x4604             MOV      R4,R0
   \       0xA2   0xA803             ADD      R0,SP,#+12
   \       0xA4   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0xA8   0xA80B             ADD      R0,SP,#+44
   \       0xAA   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0xAE   0x4620             MOV      R0,R4
   \       0xB0   0xE7E4             B.N      ??mkdir_6
   \                     ??mkdir_8: (+1)
   \       0xB2   0x2301             MOVS     R3,#+1
   \       0xB4   0x466A             MOV      R2,SP
   \       0xB6   0x4621             MOV      R1,R4
   \       0xB8   0x4628             MOV      R0,R5
   \       0xBA   0x.... 0x....      BL       _ZN10SdBaseFile4openEPS_PKhh
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD108             BNE.N    ??mkdir_9
   \       0xC2   0x0038             MOVS     R0,R7
   \       0xC4   0xD0D3             BEQ.N    ??mkdir_0
   \       0xC6   0x466A             MOV      R2,SP
   \       0xC8   0x4621             MOV      R1,R4
   \       0xCA   0x4628             MOV      R0,R5
   \       0xCC   0x.... 0x....      BL       _ZN10SdBaseFile5mkdirEPS_PKh
   \       0xD0   0x2800             CMP      R0,#+0
   \       0xD2   0xD0CC             BEQ.N    ??mkdir_0
   \                     ??mkdir_9: (+1)
   \       0xD4   0x42B4             CMP      R4,R6
   \       0xD6   0xD002             BEQ.N    ??mkdir_10
   \       0xD8   0x4620             MOV      R0,R4
   \       0xDA   0x.... 0x....      BL       _ZN10SdBaseFile5closeEv
   \                     ??mkdir_10: (+1)
   \       0xDE   0x462C             MOV      R4,R5
   \       0xE0   0xA80B             ADD      R0,SP,#+44
   \       0xE2   0x4284             CMP      R4,R0
   \       0xE4   0xD1BB             BNE.N    ??mkdir_4
   \       0xE6   0xAD03             ADD      R5,SP,#+12
   \       0xE8   0xE7BA             B.N      ??mkdir_1
    468          }
    469          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    470          bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
   \                     _ZN10SdBaseFile5mkdirEPS_PKh: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    471            uint32_t block;
    472            dir_t d;
    473            dir_t* p;
    474          
    475            if (!parent->isDir()) goto fail;
   \        0xA   0x4628             MOV      R0,R5
   \        0xC   0x.... 0x....      BL       _ZNK10SdBaseFile5isDirEv
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD05F             BEQ.N    ??mkdir_11
    476          
    477            // create a normal file
    478            if (!open(parent, dname, O_CREAT | O_EXCL | O_RDWR)) goto fail;
   \       0x14   0x23C3             MOVS     R3,#+195
   \       0x16   0x4632             MOV      R2,R6
   \       0x18   0x4629             MOV      R1,R5
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x.... 0x....      BL       _ZN10SdBaseFile4openEPS_PKhh
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD057             BEQ.N    ??mkdir_11
    479          
    480            // convert file to directory
    481            flags_ = O_READ;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x7060             STRB     R0,[R4, #+1]
    482            type_ = FAT_FILE_TYPE_SUBDIR;
   \       0x28   0x2004             MOVS     R0,#+4
   \       0x2A   0x70E0             STRB     R0,[R4, #+3]
    483          
    484            // allocate and zero first cluster
    485            if (!addDirCluster())goto fail;
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x.... 0x....      BL       _ZN10SdBaseFile13addDirClusterEv
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD04E             BEQ.N    ??mkdir_11
    486          
    487            // force entry to SD
    488            if (!sync()) goto fail;
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0x.... 0x....      BL       _ZN10SdBaseFile4syncEv
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD049             BEQ.N    ??mkdir_11
    489          
    490            // cache entry - should already be in cache due to sync() call
    491            p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0x.... 0x....      BL       _ZN10SdBaseFile13cacheDirEntryEh
    492            if (!p) goto fail;
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD043             BEQ.N    ??mkdir_11
    493          
    494            // change directory entry  attribute
    495            p->attributes = DIR_ATT_DIRECTORY;
   \       0x4C   0x2110             MOVS     R1,#+16
   \       0x4E   0x72C1             STRB     R1,[R0, #+11]
    496          
    497            // make entry for '.'
    498            memcpy(&d, p, sizeof(d));
   \       0x50   0x2220             MOVS     R2,#+32
   \       0x52   0x4601             MOV      R1,R0
   \       0x54   0x4668             MOV      R0,SP
   \       0x56   0x.... 0x....      BL       __aeabi_memcpy
    499            d.name[0] = '.';
   \       0x5A   0x202E             MOVS     R0,#+46
   \       0x5C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    500            for (uint8_t i = 1; i < 11; i++) d.name[i] = ' ';
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0x2220             MOVS     R2,#+32
   \       0x64   0x466B             MOV      R3,SP
   \       0x66   0xE001             B.N      ??mkdir_12
   \                     ??mkdir_13: (+1)
   \       0x68   0x545A             STRB     R2,[R3, R1]
   \       0x6A   0x1C40             ADDS     R0,R0,#+1
   \                     ??mkdir_12: (+1)
   \       0x6C   0x4601             MOV      R1,R0
   \       0x6E   0xB2C9             UXTB     R1,R1
   \       0x70   0x290B             CMP      R1,#+11
   \       0x72   0xDBF9             BLT.N    ??mkdir_13
    501          
    502            // cache block for '.'  and '..'
    503            block = vol_->clusterStartBlock(firstCluster_);
   \       0x74   0x69A1             LDR      R1,[R4, #+24]
   \       0x76   0x69E0             LDR      R0,[R4, #+28]
   \       0x78   0x.... 0x....      BL       _ZNK8SdVolume17clusterStartBlockEj
    504            if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;
   \       0x7C   0x2101             MOVS     R1,#+1
   \       0x7E   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD026             BEQ.N    ??mkdir_11
    505          
    506            // copy '.' to block
    507            memcpy(&vol_->cache()->dir[0], &d, sizeof(d));
   \       0x86   0x69E0             LDR      R0,[R4, #+28]
   \       0x88   0x.... 0x....      BL       _ZN8SdVolume5cacheEv
   \       0x8C   0x2220             MOVS     R2,#+32
   \       0x8E   0x4669             MOV      R1,SP
   \       0x90   0x.... 0x....      BL       __aeabi_memcpy
    508          
    509            // make entry for '..'
    510            d.name[1] = '.';
   \       0x94   0x202E             MOVS     R0,#+46
   \       0x96   0xF88D 0x0001      STRB     R0,[SP, #+1]
    511            if (parent->isRoot()) {
   \       0x9A   0x4628             MOV      R0,R5
   \       0x9C   0x.... 0x....      BL       _ZNK10SdBaseFile6isRootEv
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD005             BEQ.N    ??mkdir_14
    512              d.firstClusterLow = 0;
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    513              d.firstClusterHigh = 0;
   \       0xAA   0xF8AD 0x0014      STRH     R0,[SP, #+20]
   \       0xAE   0xE006             B.N      ??mkdir_15
    514            }
    515            else {
    516              d.firstClusterLow = parent->firstCluster_ & 0XFFFF;
   \                     ??mkdir_14: (+1)
   \       0xB0   0x69A8             LDR      R0,[R5, #+24]
   \       0xB2   0x4601             MOV      R1,R0
   \       0xB4   0xF8AD 0x101A      STRH     R1,[SP, #+26]
    517              d.firstClusterHigh = parent->firstCluster_ >> 16;
   \       0xB8   0x0C00             LSRS     R0,R0,#+16
   \       0xBA   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    518            }
    519            // copy '..' to block
    520            memcpy(&vol_->cache()->dir[1], &d, sizeof(d));
   \                     ??mkdir_15: (+1)
   \       0xBE   0x69E0             LDR      R0,[R4, #+28]
   \       0xC0   0x.... 0x....      BL       _ZN8SdVolume5cacheEv
   \       0xC4   0x3020             ADDS     R0,R0,#+32
   \       0xC6   0x2220             MOVS     R2,#+32
   \       0xC8   0x4669             MOV      R1,SP
   \       0xCA   0x.... 0x....      BL       __aeabi_memcpy
    521          
    522            // write first block
    523            return vol_->cacheFlush();
   \       0xCE   0x.... 0x....      BL       _ZN8SdVolume10cacheFlushEv
   \       0xD2   0xE000             B.N      ??mkdir_16
    524          fail:
    525            return false;
   \                     ??mkdir_11: (+1)
   \       0xD4   0x2000             MOVS     R0,#+0
   \                     ??mkdir_16: (+1)
   \       0xD6   0xB008             ADD      SP,SP,#+32
   \       0xD8   0xBD70             POP      {R4-R6,PC}       ;; return
    526          }
    527          //------------------------------------------------------------------------------
    528          /** Open a file in the current working directory.
    529           *
    530           * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
    531           *
    532           * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
    533           * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
    534           *
    535           * \return The value one, true, is returned for success and
    536           * the value zero, false, is returned for failure.
    537           */

   \                                 In section .text, align 2, keep-with-next
    538          bool SdBaseFile::open(const char* path, uint8_t oflag) {
   \                     _ZN10SdBaseFile4openEPKch: (+1)
   \        0x0   0x4613             MOV      R3,R2
    539            return open(cwd_, path, oflag);
   \        0x2   0x460A             MOV      R2,R1
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable12
   \        0x8   0x6809             LDR      R1,[R1, #+0]
   \        0xA                      REQUIRE _ZN10SdBaseFile4openEPS_PKch
   \        0xA                      ;; // Fall through to label SdBaseFile::open(SdBaseFile *, char const *, uint8_t)
    540          }
    541          //------------------------------------------------------------------------------
    542          /** Open a file or directory by name.
    543           *
    544           * \param[in] dirFile An open SdFat instance for the directory containing the
    545           * file to be opened.
    546           *
    547           * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
    548           *
    549           * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
    550           * OR of flags from the following list
    551           *
    552           * O_READ - Open for reading.
    553           *
    554           * O_RDONLY - Same as O_READ.
    555           *
    556           * O_WRITE - Open for writing.
    557           *
    558           * O_WRONLY - Same as O_WRITE.
    559           *
    560           * O_RDWR - Open for reading and writing.
    561           *
    562           * O_APPEND - If set, the file offset shall be set to the end of the
    563           * file prior to each write.
    564           *
    565           * O_AT_END - Set the initial position at the end of the file.
    566           *
    567           * O_CREAT - If the file exists, this flag has no effect except as noted
    568           * under O_EXCL below. Otherwise, the file shall be created
    569           *
    570           * O_EXCL - If O_CREAT and O_EXCL are set, open() shall fail if the file exists.
    571           *
    572           * O_SYNC - Call sync() after each write.  This flag should not be used with
    573           * write(uint8_t), write_P(PGM_P), writeln_P(PGM_P), or the Arduino Print class.
    574           * These functions do character at a time writes so sync() will be called
    575           * after each byte.
    576           *
    577           * O_TRUNC - If the file exists and is a regular file, and the file is
    578           * successfully opened and is not read only, its length shall be truncated to 0.
    579           *
    580           * WARNING: A given file must not be opened by more than one SdBaseFile object
    581           * of file corruption may occur.
    582           *
    583           * \note Directory files must be opened read only.  Write and truncation is
    584           * not allowed for directory files.
    585           *
    586           * \return The value one, true, is returned for success and
    587           * the value zero, false, is returned for failure.
    588           * Reasons for failure include this file is already open, \a dirFile is not
    589           * a directory, \a path is invalid, the file does not exist
    590           * or can't be opened in the access mode specified by oflag.
    591           */

   \                                 In section .text, align 2, keep-with-next
    592          bool SdBaseFile::open(SdBaseFile* dirFile, const char* path, uint8_t oflag) {
   \                     _ZN10SdBaseFile4openEPS_PKch: (+1)
   \        0x0   0xE92D 0x41F4      PUSH     {R2,R4-R8,LR}
   \        0x4   0xB093             SUB      SP,SP,#+76
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x461E             MOV      R6,R3
    593            uint8_t dname[11];
    594            SdBaseFile dir1, dir2;
   \        0xC   0xA80B             ADD      R0,SP,#+44
   \        0xE   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
   \       0x12   0xA803             ADD      R0,SP,#+12
   \       0x14   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
    595            SdBaseFile* parent = dirFile;
   \       0x18   0x0027             MOVS     R7,R4
    596            SdBaseFile* sub = &dir1;
   \       0x1A   0xAD0B             ADD      R5,SP,#+44
    597          
    598            if (!dirFile) goto fail;
   \       0x1C   0xD027             BEQ.N    ??open_0
    599          
    600            // error if already open
    601            if (isOpen()) goto fail;
   \       0x1E   0x4640             MOV      R0,R8
   \       0x20   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD122             BNE.N    ??open_0
    602          
    603            if (*path == '/') {
   \       0x28   0x9813             LDR      R0,[SP, #+76]
   \       0x2A   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \       0x2E   0x282F             CMP      R0,#+47
   \       0x30   0xD116             BNE.N    ??open_1
   \       0x32   0xE002             B.N      ??open_2
    604              while (*path == '/') path++;
   \                     ??open_3: (+1)
   \       0x34   0x9813             LDR      R0,[SP, #+76]
   \       0x36   0x1C40             ADDS     R0,R0,#+1
   \       0x38   0x9013             STR      R0,[SP, #+76]
   \                     ??open_2: (+1)
   \       0x3A   0x9813             LDR      R0,[SP, #+76]
   \       0x3C   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \       0x40   0x282F             CMP      R0,#+47
   \       0x42   0xD0F7             BEQ.N    ??open_3
    605              if (!dirFile->isRoot()) {
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0x.... 0x....      BL       _ZNK10SdBaseFile6isRootEv
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD108             BNE.N    ??open_1
    606                if (!dir2.openRoot(dirFile->vol_)) goto fail;
   \       0x4E   0x69E1             LDR      R1,[R4, #+28]
   \       0x50   0xA803             ADD      R0,SP,#+12
   \       0x52   0x.... 0x....      BL       _ZN10SdBaseFile8openRootEP8SdVolume
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD009             BEQ.N    ??open_0
    607                parent = &dir2;
   \       0x5A   0xAF03             ADD      R7,SP,#+12
   \       0x5C   0xE000             B.N      ??open_1
    608              }
    609            }
    610            while (1) {
    611              if (!make83Name(path, dname, &path)) goto fail;
    612              while (*path == '/') path++;
    613              if (!*path) break;
    614              if (!sub->open(parent, dname, O_READ)) goto fail;
    615              if (parent != dirFile) parent->close();
    616              parent = sub;
    617              sub = parent != &dir1 ? &dir1 : &dir2;
   \                     ??open_4: (+1)
   \       0x5E   0xAD0B             ADD      R5,SP,#+44
   \                     ??open_1: (+1)
   \       0x60   0xAA13             ADD      R2,SP,#+76
   \       0x62   0x4669             MOV      R1,SP
   \       0x64   0x9813             LDR      R0,[SP, #+76]
   \       0x66   0x.... 0x....      BL       _ZN10SdBaseFile10make83NameEPKcPhPS1_
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD10C             BNE.N    ??open_5
    618            }
    619            return open(parent, dname, oflag);
    620          fail:
    621            return false;
   \                     ??open_0: (+1)
   \       0x6E   0xA803             ADD      R0,SP,#+12
   \       0x70   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0x74   0xA80B             ADD      R0,SP,#+44
   \       0x76   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0x7A   0x2000             MOVS     R0,#+0
   \                     ??open_6: (+1)
   \       0x7C   0xB014             ADD      SP,SP,#+80
   \       0x7E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??open_7: (+1)
   \       0x82   0x9813             LDR      R0,[SP, #+76]
   \       0x84   0x1C40             ADDS     R0,R0,#+1
   \       0x86   0x9013             STR      R0,[SP, #+76]
   \                     ??open_5: (+1)
   \       0x88   0x9813             LDR      R0,[SP, #+76]
   \       0x8A   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \       0x8E   0x282F             CMP      R0,#+47
   \       0x90   0xD0F7             BEQ.N    ??open_7
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD10E             BNE.N    ??open_8
   \       0x96   0x4633             MOV      R3,R6
   \       0x98   0x466A             MOV      R2,SP
   \       0x9A   0x4639             MOV      R1,R7
   \       0x9C   0x4640             MOV      R0,R8
   \       0x9E   0x.... 0x....      BL       _ZN10SdBaseFile4openEPS_PKhh
   \       0xA2   0x4606             MOV      R6,R0
   \       0xA4   0xA803             ADD      R0,SP,#+12
   \       0xA6   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0xAA   0xA80B             ADD      R0,SP,#+44
   \       0xAC   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0xB0   0x4630             MOV      R0,R6
   \       0xB2   0xE7E3             B.N      ??open_6
   \                     ??open_8: (+1)
   \       0xB4   0x2301             MOVS     R3,#+1
   \       0xB6   0x466A             MOV      R2,SP
   \       0xB8   0x4639             MOV      R1,R7
   \       0xBA   0x4628             MOV      R0,R5
   \       0xBC   0x.... 0x....      BL       _ZN10SdBaseFile4openEPS_PKhh
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD0D4             BEQ.N    ??open_0
   \       0xC4   0x42A7             CMP      R7,R4
   \       0xC6   0xD002             BEQ.N    ??open_9
   \       0xC8   0x4638             MOV      R0,R7
   \       0xCA   0x.... 0x....      BL       _ZN10SdBaseFile5closeEv
   \                     ??open_9: (+1)
   \       0xCE   0x462F             MOV      R7,R5
   \       0xD0   0xA80B             ADD      R0,SP,#+44
   \       0xD2   0x4287             CMP      R7,R0
   \       0xD4   0xD1C3             BNE.N    ??open_4
   \       0xD6   0xAD03             ADD      R5,SP,#+12
   \       0xD8   0xE7C2             B.N      ??open_1
    622          }
    623          //------------------------------------------------------------------------------
    624          // open with filename in dname

   \                                 In section .text, align 2, keep-with-next
    625          bool SdBaseFile::open(SdBaseFile* dirFile,
    626                                const uint8_t dname[11], uint8_t oflag) {
   \                     _ZN10SdBaseFile4openEPS_PKhh: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4691             MOV      R9,R2
   \        0xA   0x461D             MOV      R5,R3
    627            bool emptyFound = false;
   \        0xC   0xF04F 0x0A00      MOV      R10,#+0
    628            bool fileFound = false;
   \       0x10   0x4656             MOV      R6,R10
    629            uint8_t index;
    630            dir_t* p;
    631          
    632            vol_ = dirFile->vol_;
   \       0x12   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \       0x16   0x61F8             STR      R0,[R7, #+28]
    633          
    634            dirFile->rewind();
   \       0x18   0x4640             MOV      R0,R8
   \       0x1A   0x.... 0x....      BL       _ZN10SdBaseFile6rewindEv
    635            // search for file
    636          
    637            while (dirFile->curPosition_ < dirFile->fileSize_) {
   \                     ??open_10: (+1)
   \       0x1E   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x22   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD226             BCS.N    ??open_11
    638              index = 0XF & (dirFile->curPosition_ >> 5);
   \       0x2A   0x4683             MOV      R11,R0
   \       0x2C   0xEA4F 0x1B5B      LSR      R11,R11,#+5
   \       0x30   0xF00B 0x0B0F      AND      R11,R11,#0xF
    639              p = dirFile->readDirCache();
   \       0x34   0x4640             MOV      R0,R8
   \       0x36   0x.... 0x....      BL       _ZN10SdBaseFile12readDirCacheEv
   \       0x3A   0x0004             MOVS     R4,R0
    640              if (!p) goto fail;
   \       0x3C   0xD020             BEQ.N    ??open_12
    641          
    642              if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
   \       0x3E   0x7820             LDRB     R0,[R4, #+0]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD001             BEQ.N    ??open_13
   \       0x44   0x28E5             CMP      R0,#+229
   \       0x46   0xD10F             BNE.N    ??open_14
    643                // remember first empty slot
    644                if (!emptyFound) {
   \                     ??open_13: (+1)
   \       0x48   0x4650             MOV      R0,R10
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD108             BNE.N    ??open_15
    645                  dirBlock_ = dirFile->vol_->cacheBlockNumber();
   \       0x4E   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \       0x52   0x.... 0x....      BL       _ZN8SdVolume16cacheBlockNumberEv
   \       0x56   0x60F8             STR      R0,[R7, #+12]
    646                  dirIndex_ = index;
   \       0x58   0xF887 0xB010      STRB     R11,[R7, #+16]
    647                  emptyFound = true;
   \       0x5C   0xF04F 0x0A01      MOV      R10,#+1
    648                }
    649                // done if no entries follow
    650                if (p->name[0] == DIR_NAME_FREE) break;
   \                     ??open_15: (+1)
   \       0x60   0x7820             LDRB     R0,[R4, #+0]
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD1DB             BNE.N    ??open_10
   \       0x66   0xE007             B.N      ??open_11
    651              }
    652              else if (!memcmp(dname, p->name, 11)) {
   \                     ??open_14: (+1)
   \       0x68   0x220B             MOVS     R2,#+11
   \       0x6A   0x4621             MOV      R1,R4
   \       0x6C   0x4648             MOV      R0,R9
   \       0x6E   0x.... 0x....      BL       memcmp
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD1D3             BNE.N    ??open_10
    653                fileFound = true;
   \       0x76   0x2601             MOVS     R6,#+1
    654                break;
    655              }
    656            }
    657            if (fileFound) {
   \                     ??open_11: (+1)
   \       0x78   0x2E00             CMP      R6,#+0
   \       0x7A   0xD004             BEQ.N    ??open_16
    658              // don't open existing file if O_EXCL
    659              if (oflag & O_EXCL) goto fail;
   \       0x7C   0x0628             LSLS     R0,R5,#+24
   \       0x7E   0xD547             BPL.N    ??open_17
    660            }
    661            else {
    662              // don't create unless O_CREAT and O_WRITE
    663              if (!(oflag & O_CREAT) || !(oflag & O_WRITE)) goto fail;
    664              if (emptyFound) {
    665                index = dirIndex_;
    666                p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    667                if (!p) goto fail;
    668              }
    669              else {
    670                if (dirFile->type_ == FAT_FILE_TYPE_ROOT_FIXED) goto fail;
    671          
    672                // add and zero cluster for dirFile - first cluster is in cache for write
    673                if (!dirFile->addDirCluster()) goto fail;
    674          
    675                // use first entry in cluster
    676                p = dirFile->vol_->cache()->dir;
    677                index = 0;
    678              }
    679              // initialize as empty file
    680              memset(p, 0, sizeof(*p));
    681              memcpy(p->name, dname, 11);
    682          
    683              // set timestamps
    684              if (dateTime_) {
    685                // call user date/time function
    686                dateTime_(&p->creationDate, &p->creationTime);
                                 ^
Warning[Pa039]: use of address of unaligned structure member

        dateTime_(&p->creationDate, &p->creationTime);
                                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\SdBaseFile.cpp",686  Warning[Pa039]: 
          use of address of unaligned structure member
    687              }
    688              else {
    689                // use default date/time
    690                p->creationDate = FAT_DEFAULT_DATE;
    691                p->creationTime = FAT_DEFAULT_TIME;
    692              }
    693              p->lastAccessDate = p->creationDate;
    694              p->lastWriteDate = p->creationDate;
    695              p->lastWriteTime = p->creationTime;
    696          
    697              // write entry to SD
    698              if (!dirFile->vol_->cacheFlush()) goto fail;
    699            }
    700            // open entry in cache
    701            return openCachedEntry(index, oflag);
    702          fail:
    703            return false;
   \                     ??open_12: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??open_16: (+1)
   \       0x86   0xF005 0x0042      AND      R0,R5,#0x42
   \       0x8A   0x2842             CMP      R0,#+66
   \       0x8C   0xD1F8             BNE.N    ??open_12
   \       0x8E   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x92   0xD008             BEQ.N    ??open_18
   \       0x94   0xF897 0xB010      LDRB     R11,[R7, #+16]
   \       0x98   0x2101             MOVS     R1,#+1
   \       0x9A   0x4638             MOV      R0,R7
   \       0x9C   0x.... 0x....      BL       _ZN10SdBaseFile13cacheDirEntryEh
   \       0xA0   0x0004             MOVS     R4,R0
   \       0xA2   0xD110             BNE.N    ??open_19
   \       0xA4   0xE7EC             B.N      ??open_12
   \                     ??open_18: (+1)
   \       0xA6   0xF898 0x0003      LDRB     R0,[R8, #+3]
   \       0xAA   0x2802             CMP      R0,#+2
   \       0xAC   0xD0E8             BEQ.N    ??open_12
   \       0xAE   0x4640             MOV      R0,R8
   \       0xB0   0x.... 0x....      BL       _ZN10SdBaseFile13addDirClusterEv
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD0E3             BEQ.N    ??open_12
   \       0xB8   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \       0xBC   0x.... 0x....      BL       _ZN8SdVolume5cacheEv
   \       0xC0   0x4604             MOV      R4,R0
   \       0xC2   0xF04F 0x0B00      MOV      R11,#+0
   \                     ??open_19: (+1)
   \       0xC6   0x2200             MOVS     R2,#+0
   \       0xC8   0x2120             MOVS     R1,#+32
   \       0xCA   0x4620             MOV      R0,R4
   \       0xCC   0x.... 0x....      BL       __aeabi_memset
   \       0xD0   0x220B             MOVS     R2,#+11
   \       0xD2   0x4649             MOV      R1,R9
   \       0xD4   0x4620             MOV      R0,R4
   \       0xD6   0x.... 0x....      BL       __aeabi_memcpy
   \       0xDA   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \       0xDE   0x6802             LDR      R2,[R0, #+0]
   \       0xE0   0x2A00             CMP      R2,#+0
   \       0xE2   0xD005             BEQ.N    ??open_20
   \       0xE4   0xF104 0x010E      ADD      R1,R4,#+14
   \       0xE8   0xF104 0x0010      ADD      R0,R4,#+16
   \       0xEC   0x4790             BLX      R2
   \       0xEE   0xE005             B.N      ??open_21
   \                     ??open_20: (+1)
   \       0xF0   0xF642 0x0021      MOVW     R0,#+10273
   \       0xF4   0x8220             STRH     R0,[R4, #+16]
   \       0xF6   0xF44F 0x6000      MOV      R0,#+2048
   \       0xFA   0x81E0             STRH     R0,[R4, #+14]
   \                     ??open_21: (+1)
   \       0xFC   0x8A20             LDRH     R0,[R4, #+16]
   \       0xFE   0x8260             STRH     R0,[R4, #+18]
   \      0x100   0x8A20             LDRH     R0,[R4, #+16]
   \      0x102   0x8320             STRH     R0,[R4, #+24]
   \      0x104   0x89E0             LDRH     R0,[R4, #+14]
   \      0x106   0x82E0             STRH     R0,[R4, #+22]
   \      0x108   0x.... 0x....      BL       _ZN8SdVolume10cacheFlushEv
   \      0x10C   0x2800             CMP      R0,#+0
   \      0x10E   0xD0B7             BEQ.N    ??open_12
   \                     ??open_17: (+1)
   \      0x110   0x462A             MOV      R2,R5
   \      0x112   0x4659             MOV      R1,R11
   \      0x114   0xB2C9             UXTB     R1,R1
   \      0x116   0x4638             MOV      R0,R7
   \      0x118   0xE8BD 0x4FF8      POP      {R3-R11,LR}
   \      0x11C   0x....             B.N      _ZN10SdBaseFile15openCachedEntryEhh
    704          }
    705          //------------------------------------------------------------------------------
    706          /** Open a file by index.
    707           *
    708           * \param[in] dirFile An open SdFat instance for the directory.
    709           *
    710           * \param[in] index The \a index of the directory entry for the file to be
    711           * opened.  The value for \a index is (directory file position)/32.
    712           *
    713           * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
    714           * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
    715           *
    716           * See open() by path for definition of flags.
    717           * \return true for success or false for failure.
    718           */

   \                                 In section .text, align 2, keep-with-next
    719          bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {
   \                     _ZN10SdBaseFile4openEPS_th: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    720            dir_t* p;
    721          
    722            vol_ = dirFile->vol_;
   \        0xA   0x69E0             LDR      R0,[R4, #+28]
   \        0xC   0x61E8             STR      R0,[R5, #+28]
    723          
    724            // error if already open
    725            if (isOpen() || !dirFile) goto fail;
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD11E             BNE.N    ??open_22
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD01C             BEQ.N    ??open_22
    726          
    727            // don't open existing file if O_EXCL - user call error
    728            if (oflag & O_EXCL) goto fail;
   \       0x1C   0x0638             LSLS     R0,R7,#+24
   \       0x1E   0xD41A             BMI.N    ??open_22
    729          
    730            // seek to location of entry
    731            if (!dirFile->seekSet(32 * index)) goto fail;
   \       0x20   0x4631             MOV      R1,R6
   \       0x22   0x0149             LSLS     R1,R1,#+5
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x.... 0x....      BL       _ZN10SdBaseFile7seekSetEj
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD013             BEQ.N    ??open_22
    732          
    733            // read entry into cache
    734            p = dirFile->readDirCache();
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x.... 0x....      BL       _ZN10SdBaseFile12readDirCacheEv
    735            if (!p) goto fail;
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD00E             BEQ.N    ??open_22
    736          
    737            // error if empty slot or '.' or '..'
    738            if (p->name[0] == DIR_NAME_FREE ||
    739                p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
   \       0x38   0x7800             LDRB     R0,[R0, #+0]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD00B             BEQ.N    ??open_22
   \       0x3E   0x28E5             CMP      R0,#+229
   \       0x40   0xD009             BEQ.N    ??open_22
   \       0x42   0x282E             CMP      R0,#+46
   \       0x44   0xD007             BEQ.N    ??open_22
    740              goto fail;
    741            }
    742            // open cached entry
    743            return openCachedEntry(index & 0XF, oflag);
   \       0x46   0x463A             MOV      R2,R7
   \       0x48   0xF006 0x060F      AND      R6,R6,#0xF
   \       0x4C   0x4631             MOV      R1,R6
   \       0x4E   0x4628             MOV      R0,R5
   \       0x50   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \       0x54   0x....             B.N      _ZN10SdBaseFile15openCachedEntryEhh
    744          fail:
    745            return false;
   \                     ??open_22: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    746          }
    747          //------------------------------------------------------------------------------
    748          // open a cached directory entry. Assumes vol_ is initialized

   \                                 In section .text, align 2, keep-with-next
    749          bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
   \                     _ZN10SdBaseFile15openCachedEntryEhh: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4615             MOV      R5,R2
    750            // location of entry in cache
    751            dir_t* p = &vol_->cache()->dir[dirIndex];
   \        0x8   0x69E0             LDR      R0,[R4, #+28]
   \        0xA   0x.... 0x....      BL       _ZN8SdVolume5cacheEv
   \        0xE   0x4631             MOV      R1,R6
   \       0x10   0xEB10 0x1741      ADDS     R7,R0,R1, LSL #+5
    752          
    753            // write or truncate is an error for a directory or read-only file
    754            if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
   \       0x14   0x7AF8             LDRB     R0,[R7, #+11]
   \       0x16   0xF010 0x0F11      TST      R0,#0x11
   \       0x1A   0xD002             BEQ.N    ??openCachedEntry_0
    755              if (oflag & (O_WRITE | O_TRUNC)) goto fail;
   \       0x1C   0xF015 0x0F12      TST      R5,#0x12
   \       0x20   0xD13D             BNE.N    ??openCachedEntry_1
    756            }
    757            // remember location of directory entry on SD
    758            dirBlock_ = vol_->cacheBlockNumber();
   \                     ??openCachedEntry_0: (+1)
   \       0x22   0x69E0             LDR      R0,[R4, #+28]
   \       0x24   0x.... 0x....      BL       _ZN8SdVolume16cacheBlockNumberEv
   \       0x28   0x60E0             STR      R0,[R4, #+12]
    759            dirIndex_ = dirIndex;
   \       0x2A   0x7426             STRB     R6,[R4, #+16]
    760          
    761            // copy first cluster number for directory fields
    762            firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
   \       0x2C   0x8AB9             LDRH     R1,[R7, #+20]
   \       0x2E   0x0409             LSLS     R1,R1,#+16
   \       0x30   0x61A1             STR      R1,[R4, #+24]
    763            firstCluster_ |= p->firstClusterLow;
   \       0x32   0x8B78             LDRH     R0,[R7, #+26]
   \       0x34   0x4301             ORRS     R1,R0,R1
   \       0x36   0x61A1             STR      R1,[R4, #+24]
    764          
    765            // make sure it is a normal file or subdirectory
    766            if (DIR_IS_FILE(p)) {
   \       0x38   0x4638             MOV      R0,R7
   \       0x3A   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f11DIR_IS_FILEEPK14directoryEntry
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD004             BEQ.N    ??openCachedEntry_2
    767              fileSize_ = p->fileSize;
   \       0x42   0x69F8             LDR      R0,[R7, #+28]
   \       0x44   0x6160             STR      R0,[R4, #+20]
    768              type_ = FAT_FILE_TYPE_NORMAL;
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0x70E0             STRB     R0,[R4, #+3]
   \       0x4A   0xE00E             B.N      ??openCachedEntry_3
    769            }
    770            else if (DIR_IS_SUBDIR(p)) {
   \                     ??openCachedEntry_2: (+1)
   \       0x4C   0x4638             MOV      R0,R7
   \       0x4E   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f13DIR_IS_SUBDIREPK14directoryEntry
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD023             BEQ.N    ??openCachedEntry_1
    771              if (!vol_->chainSize(firstCluster_, &fileSize_)) goto fail;
   \       0x56   0xF104 0x0214      ADD      R2,R4,#+20
   \       0x5A   0x69A1             LDR      R1,[R4, #+24]
   \       0x5C   0x69E0             LDR      R0,[R4, #+28]
   \       0x5E   0x.... 0x....      BL       _ZN8SdVolume9chainSizeEjPj
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD01B             BEQ.N    ??openCachedEntry_1
    772              type_ = FAT_FILE_TYPE_SUBDIR;
   \       0x66   0x2004             MOVS     R0,#+4
   \       0x68   0x70E0             STRB     R0,[R4, #+3]
    773            }
    774            else {
    775              goto fail;
    776            }
    777            // save open flags for read/write
    778            flags_ = oflag & F_OFLAG;
   \                     ??openCachedEntry_3: (+1)
   \       0x6A   0xF005 0x000F      AND      R0,R5,#0xF
   \       0x6E   0x7060             STRB     R0,[R4, #+1]
    779          
    780            // set to start of file
    781            curCluster_ = 0;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x6060             STR      R0,[R4, #+4]
    782            curPosition_ = 0;
   \       0x74   0x60A0             STR      R0,[R4, #+8]
    783            if ((oflag & O_TRUNC) && !truncate(0)) return false;
   \       0x76   0x06E8             LSLS     R0,R5,#+27
   \       0x78   0xD507             BPL.N    ??openCachedEntry_4
   \       0x7A   0x2100             MOVS     R1,#+0
   \       0x7C   0x4620             MOV      R0,R4
   \       0x7E   0x.... 0x....      BL       _ZN10SdBaseFile8truncateEj
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD101             BNE.N    ??openCachedEntry_4
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0xBDF2             POP      {R1,R4-R7,PC}
    784            return oflag & O_AT_END ? seekEnd(0) : true;
   \                     ??openCachedEntry_4: (+1)
   \       0x8A   0x06A8             LSLS     R0,R5,#+26
   \       0x8C   0xD505             BPL.N    ??openCachedEntry_5
   \       0x8E   0x2100             MOVS     R1,#+0
   \       0x90   0x4620             MOV      R0,R4
   \       0x92   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \       0x96   0x.... 0x....      B.W      _ZN10SdBaseFile7seekEndEi
   \                     ??openCachedEntry_5: (+1)
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0xBDF2             POP      {R1,R4-R7,PC}
    785          fail:
    786            type_ = FAT_FILE_TYPE_CLOSED;
   \                     ??openCachedEntry_1: (+1)
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x70E0             STRB     R0,[R4, #+3]
    787            return false;
   \       0xA2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    788          }
    789          //------------------------------------------------------------------------------
    790          /** Open the next file or subdirectory in a directory.
    791           *
    792           * \param[in] dirFile An open SdFat instance for the directory containing the
    793           * file to be opened.
    794           *
    795           * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
    796           * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
    797           *
    798           * See open() by path for definition of flags.
    799           * \return true for success or false for failure.
    800           */

   \                                 In section .text, align 2, keep-with-next
    801          bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
   \                     _ZN10SdBaseFile8openNextEPS_h: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
    802            dir_t* p;
    803            uint8_t index;
    804          
    805            if (!dirFile) goto fail;
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD01F             BEQ.N    ??openNext_0
    806          
    807            // error if already open
    808            if (isOpen()) goto fail;
   \        0xC   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD11B             BNE.N    ??openNext_0
    809          
    810            vol_ = dirFile->vol_;
   \       0x14   0x69E0             LDR      R0,[R4, #+28]
   \       0x16   0x61E8             STR      R0,[R5, #+28]
    811          
    812            while (1) {
    813              index = 0XF & (dirFile->curPosition_ >> 5);
   \                     ??openNext_1: (+1)
   \       0x18   0x68A7             LDR      R7,[R4, #+8]
   \       0x1A   0x097F             LSRS     R7,R7,#+5
   \       0x1C   0xF007 0x070F      AND      R7,R7,#0xF
    814          
    815              // read entry into cache
    816              p = dirFile->readDirCache();
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x.... 0x....      BL       _ZN10SdBaseFile12readDirCacheEv
    817              if (!p) goto fail;
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD010             BEQ.N    ??openNext_0
    818          
    819              // done if last entry
    820              if (p->name[0] == DIR_NAME_FREE) goto fail;
   \       0x2A   0x7801             LDRB     R1,[R0, #+0]
   \       0x2C   0x2900             CMP      R1,#+0
   \       0x2E   0xD00D             BEQ.N    ??openNext_0
    821          
    822              // skip empty slot or '.' or '..'
    823              if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
   \       0x30   0x29E5             CMP      R1,#+229
   \       0x32   0xD0F1             BEQ.N    ??openNext_1
   \       0x34   0x292E             CMP      R1,#+46
   \       0x36   0xD0EF             BEQ.N    ??openNext_1
    824                continue;
    825              }
    826              // must be file or dir
    827              if (DIR_IS_FILE_OR_SUBDIR(p)) {
   \       0x38   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f21DIR_IS_FILE_OR_SUBDIREPK14directoryEntry
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD0EB             BEQ.N    ??openNext_1
    828                return openCachedEntry(index, oflag);
   \       0x40   0x4632             MOV      R2,R6
   \       0x42   0x4639             MOV      R1,R7
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \       0x4A   0x....             B.N      _ZN10SdBaseFile15openCachedEntryEhh
    829              }
    830            }
    831          fail:
    832            return false;
   \                     ??openNext_0: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    833          }
    834          //------------------------------------------------------------------------------
    835          /** Open a directory's parent directory.
    836           *
    837           * \param[in] dir Parent of this directory will be opened.  Must not be root.
    838           *
    839           * \return The value one, true, is returned for success and
    840           * the value zero, false, is returned for failure.
    841           */

   \                                 In section .text, align 2, keep-with-next
    842          bool SdBaseFile::openParent(SdBaseFile* dir) {
   \                     _ZN10SdBaseFile10openParentEPS_: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB090             SUB      SP,SP,#+64
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460D             MOV      R5,R1
    843            dir_t entry;
    844            dir_t* p;
    845            SdBaseFile file;
   \        0x8   0x4668             MOV      R0,SP
   \        0xA   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
    846            uint32_t c;
    847            uint32_t cluster;
    848            uint32_t lbn;
    849            // error if already open or dir is root or dir is not a directory
    850            if (isOpen() || !dir || dir->isRoot() || !dir->isDir()) goto fail;
   \        0xE   0x4630             MOV      R0,R6
   \       0x10   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD153             BNE.N    ??openParent_0
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD051             BEQ.N    ??openParent_0
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x.... 0x....      BL       _ZNK10SdBaseFile6isRootEv
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD14C             BNE.N    ??openParent_0
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x.... 0x....      BL       _ZNK10SdBaseFile5isDirEv
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD047             BEQ.N    ??openParent_0
    851            vol_ = dir->vol_;
   \       0x30   0x69E8             LDR      R0,[R5, #+28]
   \       0x32   0x61F0             STR      R0,[R6, #+28]
    852            // position to '..'
    853            if (!dir->seekSet(32)) goto fail;
   \       0x34   0x2120             MOVS     R1,#+32
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x.... 0x....      BL       _ZN10SdBaseFile7seekSetEj
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD03F             BEQ.N    ??openParent_0
    854            // read '..' entry
    855            if (dir->read(&entry, sizeof(entry)) != 32) goto fail;
   \       0x40   0x2220             MOVS     R2,#+32
   \       0x42   0xA908             ADD      R1,SP,#+32
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x.... 0x....      BL       _ZN10SdBaseFile4readEPvt
   \       0x4A   0x2820             CMP      R0,#+32
   \       0x4C   0xD138             BNE.N    ??openParent_0
    856            // verify it is '..'
    857            if (entry.name[0] != '.' || entry.name[1] != '.') goto fail;
   \       0x4E   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \       0x52   0x282E             CMP      R0,#+46
   \       0x54   0xD134             BNE.N    ??openParent_0
   \       0x56   0xF89D 0x0021      LDRB     R0,[SP, #+33]
   \       0x5A   0x282E             CMP      R0,#+46
   \       0x5C   0xD130             BNE.N    ??openParent_0
    858            // start cluster for '..'
    859            cluster = entry.firstClusterLow;
    860            cluster |= (uint32_t)entry.firstClusterHigh << 16;
   \       0x5E   0xF8BD 0x403A      LDRH     R4,[SP, #+58]
   \       0x62   0xF8BD 0x0034      LDRH     R0,[SP, #+52]
   \       0x66   0xEA54 0x4400      ORRS     R4,R4,R0, LSL #+16
    861            if (cluster == 0) return openRoot(vol_);
   \       0x6A   0x69F0             LDR      R0,[R6, #+28]
   \       0x6C   0xD109             BNE.N    ??openParent_1
   \       0x6E   0x4601             MOV      R1,R0
   \       0x70   0x4630             MOV      R0,R6
   \       0x72   0x.... 0x....      BL       _ZN10SdBaseFile8openRootEP8SdVolume
   \       0x76   0x4604             MOV      R4,R0
   \       0x78   0x4668             MOV      R0,SP
   \       0x7A   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0xE022             B.N      ??openParent_2
    862            // start block for '..'
    863            lbn = vol_->clusterStartBlock(cluster);
   \                     ??openParent_1: (+1)
   \       0x82   0x4621             MOV      R1,R4
   \       0x84   0x.... 0x....      BL       _ZNK8SdVolume17clusterStartBlockEj
    864            // first block of parent dir
    865            if (!vol_->cacheRawBlock(lbn, SdVolume::CACHE_FOR_READ)) {
   \       0x88   0x2100             MOVS     R1,#+0
   \       0x8A   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD016             BEQ.N    ??openParent_0
    866              goto fail;
    867            }
    868            p = &vol_->cacheBuffer_.dir[1];
    869            // verify name for '../..'
    870            if (p->name[0] != '.' || p->name[1] != '.') goto fail;
   \       0x92   0x.... 0x....      LDR.W    R1,??DataTable13
   \       0x96   0x7808             LDRB     R0,[R1, #+0]
   \       0x98   0x282E             CMP      R0,#+46
   \       0x9A   0xD111             BNE.N    ??openParent_0
   \       0x9C   0x7848             LDRB     R0,[R1, #+1]
   \       0x9E   0x282E             CMP      R0,#+46
   \       0xA0   0xD10E             BNE.N    ??openParent_0
    871            // '..' is pointer to first cluster of parent. open '../..' to find parent
    872            if (p->firstClusterHigh == 0 && p->firstClusterLow == 0) {
   \       0xA2   0x8A88             LDRH     R0,[R1, #+20]
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD111             BNE.N    ??openParent_3
   \       0xA8   0x8B48             LDRH     R0,[R1, #+26]
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD10E             BNE.N    ??openParent_3
    873              if (!file.openRoot(dir->volume())) goto fail;
   \       0xAE   0x4628             MOV      R0,R5
   \       0xB0   0x.... 0x....      BL       _ZNK10SdBaseFile6volumeEv
   \       0xB4   0x4601             MOV      R1,R0
   \       0xB6   0x4668             MOV      R0,SP
   \       0xB8   0x.... 0x....      BL       _ZN10SdBaseFile8openRootEP8SdVolume
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD10C             BNE.N    ??openParent_4
    874            }
    875            else if (!file.openCachedEntry(1, O_READ)) {
    876              goto fail;
    877            }
    878            // search for parent in '../..'
    879            do {
    880              if (file.readDir(&entry, NULL) != 32) goto fail;
    881              c = entry.firstClusterLow;
    882              c |= (uint32_t)entry.firstClusterHigh << 16;
    883            } while (c != cluster);
    884            // open parent
    885            return open(&file, file.curPosition() / 32 - 1, O_READ);
    886          fail:
    887            return false;
   \                     ??openParent_0: (+1)
   \       0xC0   0x4668             MOV      R0,SP
   \       0xC2   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0xC6   0x2000             MOVS     R0,#+0
   \                     ??openParent_2: (+1)
   \       0xC8   0xB010             ADD      SP,SP,#+64
   \       0xCA   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??openParent_3: (+1)
   \       0xCC   0x2201             MOVS     R2,#+1
   \       0xCE   0x4611             MOV      R1,R2
   \       0xD0   0x4668             MOV      R0,SP
   \       0xD2   0x.... 0x....      BL       _ZN10SdBaseFile15openCachedEntryEhh
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD0F2             BEQ.N    ??openParent_0
   \                     ??openParent_4: (+1)
   \       0xDA   0x2200             MOVS     R2,#+0
   \       0xDC   0xA908             ADD      R1,SP,#+32
   \       0xDE   0x4668             MOV      R0,SP
   \       0xE0   0x.... 0x....      BL       _ZN10SdBaseFile7readDirEP14directoryEntryPc
   \       0xE4   0x2820             CMP      R0,#+32
   \       0xE6   0xD1EB             BNE.N    ??openParent_0
   \       0xE8   0xF8BD 0x003A      LDRH     R0,[SP, #+58]
   \       0xEC   0xF8BD 0x1034      LDRH     R1,[SP, #+52]
   \       0xF0   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \       0xF4   0x42A0             CMP      R0,R4
   \       0xF6   0xD1F0             BNE.N    ??openParent_4
   \       0xF8   0x4668             MOV      R0,SP
   \       0xFA   0x.... 0x....      BL       _ZNK10SdBaseFile11curPositionEv
   \       0xFE   0x4602             MOV      R2,R0
   \      0x100   0x2301             MOVS     R3,#+1
   \      0x102   0x0952             LSRS     R2,R2,#+5
   \      0x104   0x1E52             SUBS     R2,R2,#+1
   \      0x106   0xB292             UXTH     R2,R2
   \      0x108   0x4669             MOV      R1,SP
   \      0x10A   0x4630             MOV      R0,R6
   \      0x10C   0x.... 0x....      BL       _ZN10SdBaseFile4openEPS_th
   \      0x110   0x4604             MOV      R4,R0
   \      0x112   0x4668             MOV      R0,SP
   \      0x114   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \      0x118   0x4620             MOV      R0,R4
   \      0x11A   0xE7D5             B.N      ??openParent_2
    888          }
    889          //------------------------------------------------------------------------------
    890          /** Open a volume's root directory.
    891           *
    892           * \param[in] vol The FAT volume containing the root directory to be opened.
    893           *
    894           * \return The value one, true, is returned for success and
    895           * the value zero, false, is returned for failure.
    896           * Reasons for failure include the file is already open, the FAT volume has
    897           * not been initialized or it a FAT12 volume.
    898           */

   \                                 In section .text, align 2, keep-with-next
    899          bool SdBaseFile::openRoot(SdVolume* vol) {
   \                     _ZN10SdBaseFile8openRootEP8SdVolume: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    900            // error if file is already open
    901            if (isOpen()) goto fail;
   \        0x6   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD12B             BNE.N    ??openRoot_0
    902          
    903            if (vol->fatType() == 16 || (FAT12_SUPPORT && vol->fatType() == 12)) {
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x.... 0x....      BL       _ZNK8SdVolume7fatTypeEv
   \       0x14   0x2810             CMP      R0,#+16
   \       0x16   0xD109             BNE.N    ??openRoot_1
    904              type_ = FAT_FILE_TYPE_ROOT_FIXED;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0x70E0             STRB     R0,[R4, #+3]
    905              firstCluster_ = 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x61A0             STR      R0,[R4, #+24]
    906              fileSize_ = 32 * vol->rootDirEntryCount();
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0x.... 0x....      BL       _ZNK8SdVolume17rootDirEntryCountEv
   \       0x26   0x0140             LSLS     R0,R0,#+5
   \       0x28   0x6160             STR      R0,[R4, #+20]
   \       0x2A   0xE012             B.N      ??openRoot_2
    907            }
    908            else if (vol->fatType() == 32) {
   \                     ??openRoot_1: (+1)
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x.... 0x....      BL       _ZNK8SdVolume7fatTypeEv
   \       0x32   0x2820             CMP      R0,#+32
   \       0x34   0xD117             BNE.N    ??openRoot_0
    909              type_ = FAT_FILE_TYPE_ROOT32;
   \       0x36   0x2003             MOVS     R0,#+3
   \       0x38   0x70E0             STRB     R0,[R4, #+3]
    910              firstCluster_ = vol->rootDirStart();
   \       0x3A   0x4628             MOV      R0,R5
   \       0x3C   0x.... 0x....      BL       _ZNK8SdVolume12rootDirStartEv
   \       0x40   0x61A0             STR      R0,[R4, #+24]
    911              if (!vol->chainSize(firstCluster_, &fileSize_)) goto fail;
   \       0x42   0xF104 0x0214      ADD      R2,R4,#+20
   \       0x46   0x4601             MOV      R1,R0
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x.... 0x....      BL       _ZN8SdVolume9chainSizeEjPj
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD009             BEQ.N    ??openRoot_0
    912            }
    913            else {
    914              // volume is not initialized, invalid, or FAT12 without support
    915              return false;
    916            }
    917            vol_ = vol;
   \                     ??openRoot_2: (+1)
   \       0x52   0x61E5             STR      R5,[R4, #+28]
    918            // read only
    919            flags_ = O_READ;
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0x7060             STRB     R0,[R4, #+1]
    920          
    921            // set to start of file
    922            curCluster_ = 0;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x6060             STR      R0,[R4, #+4]
    923            curPosition_ = 0;
   \       0x5C   0x60A0             STR      R0,[R4, #+8]
    924          
    925            // root has no directory entry
    926            dirBlock_ = 0;
   \       0x5E   0x60E0             STR      R0,[R4, #+12]
    927            dirIndex_ = 0;
   \       0x60   0x7420             STRB     R0,[R4, #+16]
    928            return true;
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0xBD32             POP      {R1,R4,R5,PC}
    929          fail:
    930            return false;
   \                     ??openRoot_0: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    931          }
    932          //------------------------------------------------------------------------------
    933          /** Return the next available byte without consuming it.
    934           *
    935           * \return The byte if no error and not at eof else -1;
    936           */

   \                                 In section .text, align 2, keep-with-next
    937          int SdBaseFile::peek() {
   \                     _ZN10SdBaseFile4peekEv: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    938            filepos_t pos;
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x.... 0x....      BL       _ZN9filepos_tC1Ev
    939            getpos(&pos);
   \        0xA   0x4601             MOV      R1,R0
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _ZN10SdBaseFile6getposEP9filepos_t
    940            int c = read();
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       _ZN10SdBaseFile4readEv
   \       0x18   0x0005             MOVS     R5,R0
    941            if (c >= 0) setpos(&pos);
   \       0x1A   0xD403             BMI.N    ??peek_0
   \       0x1C   0x4669             MOV      R1,SP
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x.... 0x....      BL       _ZN10SdBaseFile6setposEP9filepos_t
    942            return c;
   \                     ??peek_0: (+1)
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0xBD3E             POP      {R1-R5,PC}       ;; return
    943          }
    944          
    945          //------------------------------------------------------------------------------
    946          /** %Print the name field of a directory entry in 8.3 format.
    947           * \param[in] pr Print stream for output.
    948           * \param[in] dir The directory structure containing the name.
    949           * \param[in] width Blank fill name if length is less than \a width.
    950           * \param[in] printSlash Print '/' after directory names if true.
    951           */

   \                                 In section .text, align 2, keep-with-next
    952          void SdBaseFile::printDirName(const dir_t& dir,
    953                                        uint8_t width, bool printSlash) {
   \                     _ZN10SdBaseFile12printDirNameERK14directoryEntryhb: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4617             MOV      R7,R2
    954            uint8_t w = 0;
   \        0xA   0x2500             MOVS     R5,#+0
    955            for (uint8_t i = 0; i < 11; i++) {
   \        0xC   0x46A8             MOV      R8,R5
   \        0xE   0x.... 0x....      LDR.W    R9,??DataTable11_1
   \       0x12   0xE013             B.N      ??printDirName_0
    956              if (dir.name[i] == ' ')continue;
   \                     ??printDirName_1: (+1)
   \       0x14   0xF816 0x0008      LDRB     R0,[R6, R8]
   \       0x18   0x2820             CMP      R0,#+32
   \       0x1A   0xD00D             BEQ.N    ??printDirName_2
    957              if (i == 8) {
   \       0x1C   0xF1B8 0x0F08      CMP      R8,#+8
   \       0x20   0xD104             BNE.N    ??printDirName_3
    958                MYSERIAL.write('.');
   \       0x22   0x212E             MOVS     R1,#+46
   \       0x24   0x4648             MOV      R0,R9
   \       0x26   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    959                w++;
   \       0x2A   0x1C6D             ADDS     R5,R5,#+1
    960              }
    961              MYSERIAL.write(dir.name[i]);
   \                     ??printDirName_3: (+1)
   \       0x2C   0xF816 0x1008      LDRB     R1,[R6, R8]
   \       0x30   0x4648             MOV      R0,R9
   \       0x32   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    962              w++;
   \       0x36   0x1C6D             ADDS     R5,R5,#+1
    963            }
   \                     ??printDirName_2: (+1)
   \       0x38   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??printDirName_0: (+1)
   \       0x3C   0xF1B8 0x0F0B      CMP      R8,#+11
   \       0x40   0xDBE8             BLT.N    ??printDirName_1
    964            if (DIR_IS_SUBDIR(&dir) && printSlash) {
   \       0x42   0x4630             MOV      R0,R6
   \       0x44   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f13DIR_IS_SUBDIREPK14directoryEntry
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD00C             BEQ.N    ??printDirName_4
   \       0x4C   0x2F00             CMP      R7,#+0
   \       0x4E   0xD00A             BEQ.N    ??printDirName_4
    965              MYSERIAL.write('/');
   \       0x50   0x212F             MOVS     R1,#+47
   \       0x52   0x4648             MOV      R0,R9
   \       0x54   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    966              w++;
   \       0x58   0x1C6D             ADDS     R5,R5,#+1
   \       0x5A   0xE004             B.N      ??printDirName_4
    967            }
    968            while (w < width) {
    969              MYSERIAL.write(' ');
   \                     ??printDirName_5: (+1)
   \       0x5C   0x2120             MOVS     R1,#+32
   \       0x5E   0x4648             MOV      R0,R9
   \       0x60   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    970              w++;
   \       0x64   0x1C6D             ADDS     R5,R5,#+1
    971            }
   \                     ??printDirName_4: (+1)
   \       0x66   0x4628             MOV      R0,R5
   \       0x68   0x4621             MOV      R1,R4
   \       0x6A   0xB2C0             UXTB     R0,R0
   \       0x6C   0x4288             CMP      R0,R1
   \       0x6E   0xD3F5             BCC.N    ??printDirName_5
    972          }
   \       0x70   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    973          //------------------------------------------------------------------------------
    974          // print uint8_t with width 2

   \                                 In section .text, align 2, keep-with-next
    975          static void print2u(uint8_t v) {
   \                     _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f7print2uEh: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    976            if (v < 10) MYSERIAL.write('0');
   \        0x4   0x....             LDR.N    R5,??DataTable11_1
   \        0x6   0x280A             CMP      R0,#+10
   \        0x8   0xDA03             BGE.N    ??print2u_0
   \        0xA   0x2130             MOVS     R1,#+48
   \        0xC   0x4628             MOV      R0,R5
   \        0xE   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    977            MYSERIAL.print(v, DEC);
   \                     ??print2u_0: (+1)
   \       0x12   0x220A             MOVS     R2,#+10
   \       0x14   0x4621             MOV      R1,R4
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x1C   0x.... 0x....      B.W      _ZN12MarlinSerial5printEhi
    978          }
    979          //------------------------------------------------------------------------------
    980          /** %Print a directory date field to Serial.
    981           *
    982           *  Format is yyyy-mm-dd.
    983           *
    984           * \param[in] fatDate The date field from a directory entry.
    985           */
    986          
    987          //------------------------------------------------------------------------------
    988          /** %Print a directory date field.
    989           *
    990           *  Format is yyyy-mm-dd.
    991           *
    992           * \param[in] pr Print stream for output.
    993           * \param[in] fatDate The date field from a directory entry.
    994           */

   \                                 In section .text, align 2, keep-with-next
    995          void SdBaseFile::printFatDate(uint16_t fatDate) {
   \                     _ZN10SdBaseFile12printFatDateEt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    996            MYSERIAL.print(FAT_YEAR(fatDate));
   \        0x4   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f8FAT_YEAREt
   \        0x8   0x4601             MOV      R1,R0
   \        0xA   0x....             LDR.N    R5,??DataTable11_1
   \        0xC   0x220A             MOVS     R2,#+10
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
    997            MYSERIAL.write('-');
   \       0x14   0x212D             MOVS     R1,#+45
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    998            print2u(FAT_MONTH(fatDate));
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f9FAT_MONTHEt
   \       0x22   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f7print2uEh
    999            MYSERIAL.write('-');
   \       0x26   0x212D             MOVS     R1,#+45
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   1000            print2u(FAT_DAY(fatDate));
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f7FAT_DAYEt
   \       0x34   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x38   0x....             B.N      _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f7print2uEh
   1001          }
   1002          
   1003          //------------------------------------------------------------------------------
   1004          /** %Print a directory time field.
   1005           *
   1006           * Format is hh:mm:ss.
   1007           *
   1008           * \param[in] pr Print stream for output.
   1009           * \param[in] fatTime The time field from a directory entry.
   1010           */

   \                                 In section .text, align 2, keep-with-next
   1011          void SdBaseFile::printFatTime(uint16_t fatTime) {
   \                     _ZN10SdBaseFile12printFatTimeEt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   1012            print2u(FAT_HOUR(fatTime));
   \        0x4   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f8FAT_HOUREt
   \        0x8   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f7print2uEh
   1013            MYSERIAL.write(':');
   \        0xC   0x....             LDR.N    R5,??DataTable11_1
   \        0xE   0x213A             MOVS     R1,#+58
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   1014            print2u(FAT_MINUTE(fatTime));
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f10FAT_MINUTEEt
   \       0x1C   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f7print2uEh
   1015            MYSERIAL.write(':');
   \       0x20   0x213A             MOVS     R1,#+58
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   1016            print2u(FAT_SECOND(fatTime));
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f10FAT_SECONDEt
   \       0x2E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x32   0x....             B.N      _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f7print2uEh
   1017          }
   1018          //------------------------------------------------------------------------------
   1019          /** Print a file's name to Serial
   1020           *
   1021           * \return The value one, true, is returned for success and
   1022           * the value zero, false, is returned for failure.
   1023           */

   \                                 In section .text, align 2, keep-with-next
   1024          bool SdBaseFile::printName() {
   \                     _ZN10SdBaseFile9printNameEv: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1025            char name[FILENAME_LENGTH];
   1026            if (!getFilename(name)) return false;
   \        0x2   0x4669             MOV      R1,SP
   \        0x4   0x.... 0x....      BL       _ZN10SdBaseFile11getFilenameEPc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE.N    ??printName_0
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE005             B.N      ??printName_1
   1027            MYSERIAL.print(name);
   \                     ??printName_0: (+1)
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x16   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   1028            return true;
   \       0x1A   0x2001             MOVS     R0,#+1
   \                     ??printName_1: (+1)
   \       0x1C   0xB005             ADD      SP,SP,#+20
   \       0x1E   0xBD00             POP      {PC}             ;; return
   1029          }
   1030          //------------------------------------------------------------------------------
   1031          /** Read the next byte from a file.
   1032           *
   1033           * \return For success read returns the next byte in the file as an int.
   1034           * If an error occurs or end of file is reached -1 is returned.
   1035           */

   \                                 In section .text, align 2, keep-with-next
   1036          int16_t SdBaseFile::read() {
   \                     _ZN10SdBaseFile4readEv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1037            uint8_t b;
   1038            return read(&b, 1) == 1 ? b : -1;
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x.... 0x....      BL       _ZN10SdBaseFile4readEPvt
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD102             BNE.N    ??read_0
   \        0xE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x12   0xBD02             POP      {R1,PC}
   \                     ??read_0: (+1)
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xBD02             POP      {R1,PC}          ;; return
   1039          }
   1040          //------------------------------------------------------------------------------
   1041          /** Read data from a file starting at the current position.
   1042           *
   1043           * \param[out] buf Pointer to the location that will receive the data.
   1044           *
   1045           * \param[in] nbyte Maximum number of bytes to read.
   1046           *
   1047           * \return For success read() returns the number of bytes read.
   1048           * A value less than \a nbyte, including zero, will be returned
   1049           * if end of file is reached.
   1050           * If an error occurs, read() returns -1.  Possible errors include
   1051           * read() called before a file has been opened, corrupt file system
   1052           * or an I/O error occurred.
   1053           */

   \                                 In section .text, align 2, keep-with-next
   1054          int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
   \                     _ZN10SdBaseFile4readEPvt: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4615             MOV      R5,R2
   1055            uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
   1056            uint16_t offset;
   1057            uint16_t toRead;
   1058            uint32_t block;  // raw device block number
   1059          
   1060            // error if not open or write only
   1061            if (!isOpen() || !(flags_ & O_READ)) goto fail;
   \        0xA   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD067             BEQ.N    ??read_1
   \       0x12   0x7860             LDRB     R0,[R4, #+1]
   \       0x14   0x07C0             LSLS     R0,R0,#+31
   \       0x16   0xD564             BPL.N    ??read_1
   1062          
   1063            // max bytes left in file
   1064            NOMORE(nbyte, fileSize_ - curPosition_);
   \       0x18   0x68A0             LDR      R0,[R4, #+8]
   \       0x1A   0x6961             LDR      R1,[R4, #+20]
   \       0x1C   0x1A0A             SUBS     R2,R1,R0
   \       0x1E   0x462B             MOV      R3,R5
   \       0x20   0x429A             CMP      R2,R3
   \       0x22   0xD201             BCS.N    ??read_2
   \       0x24   0x4605             MOV      R5,R0
   \       0x26   0x1B4D             SUBS     R5,R1,R5
   1065          
   1066            // amount left to read
   1067            toRead = nbyte;
   \                     ??read_2: (+1)
   \       0x28   0x462E             MOV      R6,R5
   \       0x2A   0xE03B             B.N      ??read_3
   1068            while (toRead > 0) {
   1069              offset = curPosition_ & 0X1FF;  // offset in block
   1070              if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {
   1071                block = vol_->rootDirStart() + (curPosition_ >> 9);
   1072              }
   1073              else {
   1074                uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
   1075                if (offset == 0 && blockOfCluster == 0) {
   1076                  // start of new cluster
   1077                  if (curPosition_ == 0) {
   1078                    // use first cluster in file
   1079                    curCluster_ = firstCluster_;
   1080                  }
   1081                  else {
   1082                    // get next cluster from FAT
   1083                    if (!vol_->fatGet(curCluster_, &curCluster_)) goto fail;
   1084                  }
   1085                }
   1086                block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   1087              }
   1088              uint16_t n = toRead;
   1089          
   1090              // amount to be read from current block
   1091              NOMORE(n, 512 - offset);
   1092          
   1093              // no buffering needed if n == 512
   1094              if (n == 512 && block != vol_->cacheBlockNumber()) {
   1095                if (!vol_->readBlock(block, dst)) goto fail;
   1096              }
   1097              else {
   1098                // read block to cache and copy data to caller
   1099                if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto fail;
   \                     ??read_4: (+1)
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x4650             MOV      R0,R10
   \       0x30   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD054             BEQ.N    ??read_1
   1100                uint8_t* src = vol_->cache()->data + offset;
   \       0x38   0x69E0             LDR      R0,[R4, #+28]
   \       0x3A   0x.... 0x....      BL       _ZN8SdVolume5cacheEv
   \       0x3E   0x19C1             ADDS     R1,R0,R7
   1101                memcpy(dst, src, n);
   \       0x40   0x464A             MOV      R2,R9
   \       0x42   0x4640             MOV      R0,R8
   \       0x44   0x.... 0x....      BL       __aeabi_memcpy
   1102              }
   \       0x48   0xE026             B.N      ??read_5
   \                     ??read_6: (+1)
   \       0x4A   0x1D22             ADDS     R2,R4,#+4
   \       0x4C   0x6861             LDR      R1,[R4, #+4]
   \       0x4E   0x69E0             LDR      R0,[R4, #+28]
   \       0x50   0x.... 0x....      BL       _ZN8SdVolume6fatGetEjPj
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD044             BEQ.N    ??read_1
   \                     ??read_7: (+1)
   \       0x58   0x6861             LDR      R1,[R4, #+4]
   \       0x5A   0x69E0             LDR      R0,[R4, #+28]
   \       0x5C   0x.... 0x....      BL       _ZNK8SdVolume17clusterStartBlockEj
   \       0x60   0x4682             MOV      R10,R0
   \       0x62   0x44CA             ADD      R10,R9,R10
   \                     ??read_8: (+1)
   \       0x64   0x46B1             MOV      R9,R6
   \       0x66   0xFA1F 0xF989      UXTH     R9,R9
   \       0x6A   0xF5C7 0x7000      RSB      R0,R7,#+512
   \       0x6E   0x4548             CMP      R0,R9
   \       0x70   0xDA03             BGE.N    ??read_9
   \       0x72   0xF5C7 0x7900      RSB      R9,R7,#+512
   \       0x76   0xFA1F 0xF989      UXTH     R9,R9
   \                     ??read_9: (+1)
   \       0x7A   0xF5B9 0x7F00      CMP      R9,#+512
   \       0x7E   0xD1D5             BNE.N    ??read_4
   \       0x80   0x69E0             LDR      R0,[R4, #+28]
   \       0x82   0x.... 0x....      BL       _ZN8SdVolume16cacheBlockNumberEv
   \       0x86   0x4582             CMP      R10,R0
   \       0x88   0xD0D0             BEQ.N    ??read_4
   \       0x8A   0x4642             MOV      R2,R8
   \       0x8C   0x4651             MOV      R1,R10
   \       0x8E   0x69E0             LDR      R0,[R4, #+28]
   \       0x90   0x.... 0x....      BL       _ZN8SdVolume9readBlockEjPh
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD024             BEQ.N    ??read_1
   1103              dst += n;
   \                     ??read_5: (+1)
   \       0x98   0x44C8             ADD      R8,R8,R9
   1104              curPosition_ += n;
   \       0x9A   0x68A0             LDR      R0,[R4, #+8]
   \       0x9C   0x4448             ADD      R0,R9,R0
   \       0x9E   0x60A0             STR      R0,[R4, #+8]
   1105              toRead -= n;
   \       0xA0   0xEBA6 0x0609      SUB      R6,R6,R9
   \                     ??read_3: (+1)
   \       0xA4   0x4630             MOV      R0,R6
   \       0xA6   0xB280             UXTH     R0,R0
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD01E             BEQ.N    ??read_10
   \       0xAC   0x68A1             LDR      R1,[R4, #+8]
   \       0xAE   0x460F             MOV      R7,R1
   \       0xB0   0xF3C7 0x0708      UBFX     R7,R7,#+0,#+9
   \       0xB4   0x69E0             LDR      R0,[R4, #+28]
   \       0xB6   0x78E2             LDRB     R2,[R4, #+3]
   \       0xB8   0x2A02             CMP      R2,#+2
   \       0xBA   0xD106             BNE.N    ??read_11
   \       0xBC   0x.... 0x....      BL       _ZNK8SdVolume12rootDirStartEv
   \       0xC0   0x4682             MOV      R10,R0
   \       0xC2   0x68A0             LDR      R0,[R4, #+8]
   \       0xC4   0xEB0A 0x2A50      ADD      R10,R10,R0, LSR #+9
   \       0xC8   0xE7CC             B.N      ??read_8
   \                     ??read_11: (+1)
   \       0xCA   0x.... 0x....      BL       _ZNK8SdVolume14blockOfClusterEj
   \       0xCE   0x4681             MOV      R9,R0
   \       0xD0   0xEA59 0x0007      ORRS     R0,R9,R7
   \       0xD4   0xD1C0             BNE.N    ??read_7
   \       0xD6   0x68A0             LDR      R0,[R4, #+8]
   \       0xD8   0x2800             CMP      R0,#+0
   \       0xDA   0xD1B6             BNE.N    ??read_6
   \       0xDC   0x69A0             LDR      R0,[R4, #+24]
   \       0xDE   0x6060             STR      R0,[R4, #+4]
   \       0xE0   0xE7BA             B.N      ??read_7
   1106            }
   1107            return nbyte;
   1108          fail:
   1109            return -1;
   \                     ??read_1: (+1)
   \       0xE2   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??read_12: (+1)
   \       0xE6   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??read_10: (+1)
   \       0xEA   0x4628             MOV      R0,R5
   \       0xEC   0xB200             SXTH     R0,R0
   \       0xEE   0xE7FA             B.N      ??read_12
   1110          }
   1111          
   1112          /**
   1113           * Read the next entry in a directory.
   1114           *
   1115           * \param[out] dir The dir_t struct that will receive the data.
   1116           *
   1117           * \return For success readDir() returns the number of bytes read.
   1118           * A value of zero will be returned if end of file is reached.
   1119           * If an error occurs, readDir() returns -1.  Possible errors include
   1120           * readDir() called before a directory has been opened, this is not
   1121           * a directory file or an I/O error occurred.
   1122           */

   \                                 In section .text, align 2, keep-with-next
   1123          int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
   \                     _ZN10SdBaseFile7readDirEP14directoryEntryPc: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4614             MOV      R4,R2
   1124            int16_t n;
   1125            // if not a directory file or miss-positioned return an error
   1126            if (!isDir() || (0X1F & curPosition_)) return -1;
   \        0x8   0x.... 0x....      BL       _ZNK10SdBaseFile5isDirEv
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD003             BEQ.N    ??readDir_0
   \       0x10   0x7A30             LDRB     R0,[R6, #+8]
   \       0x12   0xF010 0x0F1F      TST      R0,#0x1F
   \       0x16   0xD002             BEQ.N    ??readDir_1
   \                     ??readDir_0: (+1)
   \       0x18   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1C   0xBDF2             POP      {R1,R4-R7,PC}
   1127          
   1128            //If we have a longFilename buffer, mark it as invalid. If we find a long filename it will be filled automaticly.
   1129            if (longFilename != NULL) longFilename[0] = '\0';
   \                     ??readDir_1: (+1)
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD001             BEQ.N    ??readDir_2
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x7020             STRB     R0,[R4, #+0]
   1130          
   1131            while (1) {
   1132          
   1133              n = read(dir, sizeof(dir_t));
   \                     ??readDir_2: (+1)
   \       0x26   0x2220             MOVS     R2,#+32
   \       0x28   0x4639             MOV      R1,R7
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0x.... 0x....      BL       _ZN10SdBaseFile4readEPvt
   \       0x30   0x4605             MOV      R5,R0
   1134              if (n != sizeof(dir_t)) return n == 0 ? 0 : -1;
   \       0x32   0x2D20             CMP      R5,#+32
   \       0x34   0xD11D             BNE.N    ??readDir_3
   1135          
   1136              // last entry if DIR_NAME_FREE
   1137              if (dir->name[0] == DIR_NAME_FREE) return 0;
   \       0x36   0x7838             LDRB     R0,[R7, #+0]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD021             BEQ.N    ??readDir_4
   1138          
   1139              // skip empty entries and entry for .  and ..
   1140              if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') continue;
   \       0x3C   0x28E5             CMP      R0,#+229
   \       0x3E   0xD0F2             BEQ.N    ??readDir_2
   \       0x40   0x282E             CMP      R0,#+46
   \       0x42   0xD0F0             BEQ.N    ??readDir_2
   1141          
   1142              // Fill the long filename if we have a long filename entry.
   1143              // Long filename entries are stored before the short filename.
   1144              if (longFilename != NULL && DIR_IS_LONG_NAME(dir)) {
   \       0x44   0x2C00             CMP      R4,#+0
   \       0x46   0xD034             BEQ.N    ??readDir_5
   \       0x48   0x4638             MOV      R0,R7
   \       0x4A   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f16DIR_IS_LONG_NAMEEPK14directoryEntry
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD02F             BEQ.N    ??readDir_5
   1145                vfat_t* VFAT = (vfat_t*)dir;
   1146                // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
   1147                if (VFAT->firstClusterLow == 0 && (VFAT->sequenceNumber & 0x1F) > 0 && (VFAT->sequenceNumber & 0x1F) <= MAX_VFAT_ENTRIES) {
   \       0x52   0x8B78             LDRH     R0,[R7, #+26]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD12C             BNE.N    ??readDir_5
   \       0x58   0x7838             LDRB     R0,[R7, #+0]
   \       0x5A   0xF000 0x001F      AND      R0,R0,#0x1F
   \       0x5E   0x1E41             SUBS     R1,R0,#+1
   \       0x60   0x2902             CMP      R1,#+2
   \       0x62   0xD226             BCS.N    ??readDir_5
   1148                  // TODO: Store the filename checksum to verify if a none-long filename aware system modified the file table.
   1149                  n = ((VFAT->sequenceNumber & 0x1F) - 1) * (FILENAME_LENGTH);
   \       0x64   0x4605             MOV      R5,R0
   \       0x66   0x1E6D             SUBS     R5,R5,#+1
   \       0x68   0x200D             MOVS     R0,#+13
   \       0x6A   0x4345             MULS     R5,R0,R5
   \       0x6C   0xB22D             SXTH     R5,R5
   1150                  for (uint8_t i = 0; i < FILENAME_LENGTH; i++)
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xE010             B.N      ??readDir_6
   \                     ??readDir_3: (+1)
   \       0x72   0x2D00             CMP      R5,#+0
   \       0x74   0xD101             BNE.N    ??readDir_7
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??readDir_7: (+1)
   \       0x7A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x7E   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??readDir_4: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xBDF2             POP      {R1,R4-R7,PC}
   1151                    longFilename[n + i] = (i < 5) ? VFAT->name1[i] : (i < 11) ? VFAT->name2[i - 5] : VFAT->name3[i - 11];
   \                     ??readDir_8: (+1)
   \       0x84   0x88C9             LDRH     R1,[R1, #+6]
   \       0x86   0xE002             B.N      ??readDir_9
   \                     ??readDir_10: (+1)
   \       0x88   0x280B             CMP      R0,#+11
   \       0x8A   0xDAFB             BGE.N    ??readDir_8
   \       0x8C   0x8889             LDRH     R1,[R1, #+4]
   \                     ??readDir_9: (+1)
   \       0x8E   0x1942             ADDS     R2,R0,R5
   \       0x90   0x54A1             STRB     R1,[R4, R2]
   \       0x92   0x1C40             ADDS     R0,R0,#+1
   \                     ??readDir_6: (+1)
   \       0x94   0x280D             CMP      R0,#+13
   \       0x96   0xDA06             BGE.N    ??readDir_11
   \       0x98   0xEB07 0x0140      ADD      R1,R7,R0, LSL #+1
   \       0x9C   0x2804             CMP      R0,#+4
   \       0x9E   0xDCF3             BGT.N    ??readDir_10
   \       0xA0   0xF8B1 0x1001      LDRH     R1,[R1, #+1]
   \       0xA4   0xE7F3             B.N      ??readDir_9
   1152                  // If this VFAT entry is the last one, add a NUL terminator at the end of the string
   1153                  if (VFAT->sequenceNumber & 0x40) longFilename[n + FILENAME_LENGTH] = '\0';
   \                     ??readDir_11: (+1)
   \       0xA6   0x7838             LDRB     R0,[R7, #+0]
   \       0xA8   0x0640             LSLS     R0,R0,#+25
   \       0xAA   0xD502             BPL.N    ??readDir_5
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x1961             ADDS     R1,R4,R5
   \       0xB0   0x7348             STRB     R0,[R1, #+13]
   1154                }
   1155              }
   1156              // Return if normal file or subdirectory
   1157              if (DIR_IS_FILE_OR_SUBDIR(dir)) return n;
   \                     ??readDir_5: (+1)
   \       0xB2   0x4638             MOV      R0,R7
   \       0xB4   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f21DIR_IS_FILE_OR_SUBDIREPK14directoryEntry
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD0B4             BEQ.N    ??readDir_2
   \       0xBC   0x4628             MOV      R0,R5
   \       0xBE   0xB240             SXTB     R0,R0
   \       0xC0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1158            }
   1159          }
   1160          
   1161          //------------------------------------------------------------------------------
   1162          // Read next directory entry into the cache
   1163          // Assumes file is correctly positioned

   \                                 In section .text, align 2, keep-with-next
   1164          dir_t* SdBaseFile::readDirCache() {
   \                     _ZN10SdBaseFile12readDirCacheEv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   1165            uint8_t i;
   1166            // error if not directory
   1167            if (!isDir()) goto fail;
   \        0x4   0x.... 0x....      BL       _ZNK10SdBaseFile5isDirEv
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD011             BEQ.N    ??readDirCache_0
   1168          
   1169            // index of entry in cache
   1170            i = (curPosition_ >> 5) & 0XF;
   \        0xC   0x68A5             LDR      R5,[R4, #+8]
   \        0xE   0x096D             LSRS     R5,R5,#+5
   \       0x10   0xF005 0x050F      AND      R5,R5,#0xF
   1171          
   1172            // use read to locate and cache block
   1173            if (read() < 0) goto fail;
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x.... 0x....      BL       _ZN10SdBaseFile4readEv
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD408             BMI.N    ??readDirCache_0
   1174          
   1175            // advance to next entry
   1176            curPosition_ += 31;
   \       0x1E   0x68A0             LDR      R0,[R4, #+8]
   \       0x20   0x301F             ADDS     R0,R0,#+31
   \       0x22   0x60A0             STR      R0,[R4, #+8]
   1177          
   1178            // return pointer to entry
   1179            return vol_->cache()->dir + i;
   \       0x24   0x69E0             LDR      R0,[R4, #+28]
   \       0x26   0x.... 0x....      BL       _ZN8SdVolume5cacheEv
   \       0x2A   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
   1180          fail:
   1181            return 0;
   \                     ??readDirCache_0: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1182          }
   1183          //------------------------------------------------------------------------------
   1184          /** Remove a file.
   1185           *
   1186           * The directory entry and all data for the file are deleted.
   1187           *
   1188           * \note This function should not be used to delete the 8.3 version of a
   1189           * file that has a long name. For example if a file has the long name
   1190           * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".
   1191           *
   1192           * \return The value one, true, is returned for success and
   1193           * the value zero, false, is returned for failure.
   1194           * Reasons for failure include the file read-only, is a directory,
   1195           * or an I/O error occurred.
   1196           */

   \                                 In section .text, align 2, keep-with-next
   1197          bool SdBaseFile::remove() {
   \                     _ZN10SdBaseFile6removeEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1198            dir_t* d;
   1199            // free any clusters - will fail if read-only or directory
   1200            if (!truncate(0)) goto fail;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x.... 0x....      BL       _ZN10SdBaseFile8truncateEj
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD00D             BEQ.N    ??remove_0
   1201          
   1202            // cache directory entry
   1203            d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x.... 0x....      BL       _ZN10SdBaseFile13cacheDirEntryEh
   1204            if (!d) goto fail;
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD007             BEQ.N    ??remove_0
   1205          
   1206            // mark entry deleted
   1207            d->name[0] = DIR_NAME_DELETED;
   \       0x1A   0x21E5             MOVS     R1,#+229
   \       0x1C   0x7001             STRB     R1,[R0, #+0]
   1208          
   1209            // set this file closed
   1210            type_ = FAT_FILE_TYPE_CLOSED;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x70E0             STRB     R0,[R4, #+3]
   1211          
   1212            // write entry to SD
   1213            return vol_->cacheFlush();
   \       0x22   0xE8BD 0x4010      POP      {R4,LR}
   \       0x26   0x.... 0x....      B.W      _ZN8SdVolume10cacheFlushEv
   1214            return true;
                   ^
Warning[Pe111]: statement is unreachable
   1215          fail:
   1216            return false;
   \                     ??remove_0: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return
   1217          }
   1218          //------------------------------------------------------------------------------
   1219          /** Remove a file.
   1220           *
   1221           * The directory entry and all data for the file are deleted.
   1222           *
   1223           * \param[in] dirFile The directory that contains the file.
   1224           * \param[in] path Path for the file to be removed.
   1225           *
   1226           * \note This function should not be used to delete the 8.3 version of a
   1227           * file that has a long name. For example if a file has the long name
   1228           * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".
   1229           *
   1230           * \return The value one, true, is returned for success and
   1231           * the value zero, false, is returned for failure.
   1232           * Reasons for failure include the file is a directory, is read only,
   1233           * \a dirFile is not a directory, \a path is not found
   1234           * or an I/O error occurred.
   1235           */

   \                                 In section .text, align 2, keep-with-next
   1236          bool SdBaseFile::remove(SdBaseFile* dirFile, const char* path) {
   \                     _ZN10SdBaseFile6removeEPS_PKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   1237            SdBaseFile file;
   \        0x8   0x4668             MOV      R0,SP
   \        0xA   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
   1238            if (!file.open(dirFile, path, O_WRITE)) goto fail;
   \        0xE   0x2302             MOVS     R3,#+2
   \       0x10   0x462A             MOV      R2,R5
   \       0x12   0x4621             MOV      R1,R4
   \       0x14   0x.... 0x....      BL       _ZN10SdBaseFile4openEPS_PKch
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0x4668             MOV      R0,SP
   \       0x1C   0xD103             BNE.N    ??remove_1
   1239            return file.remove();
   1240          fail:
   1241            // can't set iostate - static function
   1242            return false;
   \       0x1E   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xE006             B.N      ??remove_2
   \                     ??remove_1: (+1)
   \       0x26   0x.... 0x....      BL       _ZN10SdBaseFile6removeEv
   \       0x2A   0x4604             MOV      R4,R0
   \       0x2C   0x4668             MOV      R0,SP
   \       0x2E   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0x32   0x4620             MOV      R0,R4
   \                     ??remove_2: (+1)
   \       0x34   0xB009             ADD      SP,SP,#+36
   \       0x36   0xBD30             POP      {R4,R5,PC}       ;; return
   1243          }
   1244          //------------------------------------------------------------------------------
   1245          /** Rename a file or subdirectory.
   1246           *
   1247           * \param[in] dirFile Directory for the new path.
   1248           * \param[in] newPath New path name for the file/directory.
   1249           *
   1250           * \return The value one, true, is returned for success and
   1251           * the value zero, false, is returned for failure.
   1252           * Reasons for failure include \a dirFile is not open or is not a directory
   1253           * file, newPath is invalid or already exists, or an I/O error occurs.
   1254           */

   \                                 In section .text, align 2, keep-with-next
   1255          bool SdBaseFile::rename(SdBaseFile* dirFile, const char* newPath) {
   \                     _ZN10SdBaseFile6renameEPS_PKc: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB090             SUB      SP,SP,#+64
   \        0x6   0x4606             MOV      R6,R0
   \        0x8   0x460F             MOV      R7,R1
   \        0xA   0x4690             MOV      R8,R2
   1256            dir_t entry;
   1257            uint32_t dirCluster = 0;
   \        0xC   0x2400             MOVS     R4,#+0
   1258            SdBaseFile file;
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
   1259            dir_t* d;
   1260          
   1261            // must be an open file or subdirectory
   1262            if (!(isFile() || isSubDir())) goto fail;
   \       0x14   0x4630             MOV      R0,R6
   \       0x16   0x.... 0x....      BL       _ZNK10SdBaseFile6isFileEv
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD104             BNE.N    ??rename_0
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x.... 0x....      BL       _ZNK10SdBaseFile8isSubDirEv
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD02B             BEQ.N    ??rename_1
   1263          
   1264            // can't move file
   1265            if (vol_ != dirFile->vol_) goto fail;
   \                     ??rename_0: (+1)
   \       0x28   0x69F0             LDR      R0,[R6, #+28]
   \       0x2A   0x69F9             LDR      R1,[R7, #+28]
   \       0x2C   0x4288             CMP      R0,R1
   \       0x2E   0xD127             BNE.N    ??rename_1
   1266          
   1267            // sync() and cache directory entry
   1268            sync();
   \       0x30   0x4630             MOV      R0,R6
   \       0x32   0x.... 0x....      BL       _ZN10SdBaseFile4syncEv
   1269            d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   \       0x36   0x2101             MOVS     R1,#+1
   \       0x38   0x4630             MOV      R0,R6
   \       0x3A   0x.... 0x....      BL       _ZN10SdBaseFile13cacheDirEntryEh
   \       0x3E   0x0005             MOVS     R5,R0
   1270            if (!d) goto fail;
   \       0x40   0xD01E             BEQ.N    ??rename_1
   1271          
   1272            // save directory entry
   1273            memcpy(&entry, d, sizeof(entry));
   \       0x42   0x2220             MOVS     R2,#+32
   \       0x44   0x4629             MOV      R1,R5
   \       0x46   0xA808             ADD      R0,SP,#+32
   \       0x48   0x.... 0x....      BL       __aeabi_memcpy
   1274          
   1275            // mark entry deleted
   1276            d->name[0] = DIR_NAME_DELETED;
   \       0x4C   0x20E5             MOVS     R0,#+229
   \       0x4E   0x7028             STRB     R0,[R5, #+0]
   1277          
   1278            // make directory entry for new path
   1279            if (isFile()) {
   \       0x50   0x4630             MOV      R0,R6
   \       0x52   0x.... 0x....      BL       _ZNK10SdBaseFile6isFileEv
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD019             BEQ.N    ??rename_2
   1280              if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRITE)) {
   \       0x5A   0x23C2             MOVS     R3,#+194
   \       0x5C   0x4642             MOV      R2,R8
   \       0x5E   0x4639             MOV      R1,R7
   \       0x60   0x4668             MOV      R0,SP
   \       0x62   0x.... 0x....      BL       _ZN10SdBaseFile4openEPS_PKch
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD11A             BNE.N    ??rename_3
   1281                goto restore;
   1282              }
   1283            }
   1284            else {
   1285              // don't create missing path prefix components
   1286              if (!file.mkdir(dirFile, newPath, false)) {
   1287                goto restore;
   1288              }
   1289              // save cluster containing new dot dot
   1290              dirCluster = file.firstCluster_;
   1291            }
   1292            // change to new directory entry
   1293            dirBlock_ = file.dirBlock_;
   1294            dirIndex_ = file.dirIndex_;
   1295          
   1296            // mark closed to avoid possible destructor close call
   1297            file.type_ = FAT_FILE_TYPE_CLOSED;
   1298          
   1299            // cache new directory entry
   1300            d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   1301            if (!d) goto fail;
   1302          
   1303            // copy all but name field to new directory entry
   1304            memcpy(&d->attributes, &entry.attributes, sizeof(entry) - sizeof(d->name));
   1305          
   1306            // update dot dot if directory
   1307            if (dirCluster) {
   1308              // get new dot dot
   1309              uint32_t block = vol_->clusterStartBlock(dirCluster);
   1310              if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto fail;
   1311              memcpy(&entry, &vol_->cache()->dir[1], sizeof(entry));
   1312          
   1313              // free unused cluster
   1314              if (!vol_->freeChain(dirCluster)) goto fail;
   1315          
   1316              // store new dot dot
   1317              block = vol_->clusterStartBlock(firstCluster_);
   1318              if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;
   1319              memcpy(&vol_->cache()->dir[1], &entry, sizeof(entry));
   1320            }
   1321            return vol_->cacheFlush();
   1322          
   1323          restore:
   1324            d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   \                     ??rename_4: (+1)
   \       0x6A   0x2101             MOVS     R1,#+1
   \       0x6C   0x4630             MOV      R0,R6
   \       0x6E   0x.... 0x....      BL       _ZN10SdBaseFile13cacheDirEntryEh
   1325            if (!d) goto fail;
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD004             BEQ.N    ??rename_1
   1326            // restore entry
   1327            d->name[0] = entry.name[0];
   \       0x76   0xF89D 0x1020      LDRB     R1,[SP, #+32]
   \       0x7A   0x7001             STRB     R1,[R0, #+0]
   1328            vol_->cacheFlush();
   \       0x7C   0x.... 0x....      BL       _ZN8SdVolume10cacheFlushEv
   1329          
   1330          fail:
   1331            return false;
   \                     ??rename_1: (+1)
   \       0x80   0x4668             MOV      R0,SP
   \       0x82   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0x86   0x2000             MOVS     R0,#+0
   \                     ??rename_5: (+1)
   \       0x88   0xB010             ADD      SP,SP,#+64
   \       0x8A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??rename_2: (+1)
   \       0x8E   0x4623             MOV      R3,R4
   \       0x90   0x4642             MOV      R2,R8
   \       0x92   0x4639             MOV      R1,R7
   \       0x94   0x4668             MOV      R0,SP
   \       0x96   0x.... 0x....      BL       _ZN10SdBaseFile5mkdirEPS_PKcb
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD0E5             BEQ.N    ??rename_4
   \       0x9E   0x9C06             LDR      R4,[SP, #+24]
   \                     ??rename_3: (+1)
   \       0xA0   0x9803             LDR      R0,[SP, #+12]
   \       0xA2   0x60F0             STR      R0,[R6, #+12]
   \       0xA4   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \       0xA8   0x7430             STRB     R0,[R6, #+16]
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \       0xB0   0x2101             MOVS     R1,#+1
   \       0xB2   0x4630             MOV      R0,R6
   \       0xB4   0x.... 0x....      BL       _ZN10SdBaseFile13cacheDirEntryEh
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD0E1             BEQ.N    ??rename_1
   \       0xBC   0x2215             MOVS     R2,#+21
   \       0xBE   0xF10D 0x012B      ADD      R1,SP,#+43
   \       0xC2   0x300B             ADDS     R0,R0,#+11
   \       0xC4   0x.... 0x....      BL       __aeabi_memcpy
   \       0xC8   0x2C00             CMP      R4,#+0
   \       0xCA   0xD028             BEQ.N    ??rename_6
   \       0xCC   0x4621             MOV      R1,R4
   \       0xCE   0x69F0             LDR      R0,[R6, #+28]
   \       0xD0   0x.... 0x....      BL       _ZNK8SdVolume17clusterStartBlockEj
   \       0xD4   0x2100             MOVS     R1,#+0
   \       0xD6   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD0D0             BEQ.N    ??rename_1
   \       0xDE   0x69F0             LDR      R0,[R6, #+28]
   \       0xE0   0x.... 0x....      BL       _ZN8SdVolume5cacheEv
   \       0xE4   0xF100 0x0120      ADD      R1,R0,#+32
   \       0xE8   0x2220             MOVS     R2,#+32
   \       0xEA   0xA808             ADD      R0,SP,#+32
   \       0xEC   0x.... 0x....      BL       __aeabi_memcpy
   \       0xF0   0x4621             MOV      R1,R4
   \       0xF2   0x69F0             LDR      R0,[R6, #+28]
   \       0xF4   0x.... 0x....      BL       _ZN8SdVolume9freeChainEj
   \       0xF8   0x2800             CMP      R0,#+0
   \       0xFA   0xD0C1             BEQ.N    ??rename_1
   \       0xFC   0x69B1             LDR      R1,[R6, #+24]
   \       0xFE   0x69F0             LDR      R0,[R6, #+28]
   \      0x100   0x.... 0x....      BL       _ZNK8SdVolume17clusterStartBlockEj
   \      0x104   0x2101             MOVS     R1,#+1
   \      0x106   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xD0B8             BEQ.N    ??rename_1
   \      0x10E   0x69F0             LDR      R0,[R6, #+28]
   \      0x110   0x.... 0x....      BL       _ZN8SdVolume5cacheEv
   \      0x114   0x3020             ADDS     R0,R0,#+32
   \      0x116   0x2220             MOVS     R2,#+32
   \      0x118   0xA908             ADD      R1,SP,#+32
   \      0x11A   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??rename_6: (+1)
   \      0x11E   0x.... 0x....      BL       _ZN8SdVolume10cacheFlushEv
   \      0x122   0x4604             MOV      R4,R0
   \      0x124   0x4668             MOV      R0,SP
   \      0x126   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \      0x12A   0x4620             MOV      R0,R4
   \      0x12C   0xE7AC             B.N      ??rename_5
   1332          }
   1333          //------------------------------------------------------------------------------
   1334          /** Remove a directory file.
   1335           *
   1336           * The directory file will be removed only if it is empty and is not the
   1337           * root directory.  rmdir() follows DOS and Windows and ignores the
   1338           * read-only attribute for the directory.
   1339           *
   1340           * \note This function should not be used to delete the 8.3 version of a
   1341           * directory that has a long name. For example if a directory has the
   1342           * long name "New folder" you should not delete the 8.3 name "NEWFOL~1".
   1343           *
   1344           * \return The value one, true, is returned for success and
   1345           * the value zero, false, is returned for failure.
   1346           * Reasons for failure include the file is not a directory, is the root
   1347           * directory, is not empty, or an I/O error occurred.
   1348           */

   \                                 In section .text, align 2, keep-with-next
   1349          bool SdBaseFile::rmdir() {
   \                     _ZN10SdBaseFile5rmdirEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1350            // must be open subdirectory
   1351            if (!isSubDir()) goto fail;
   \        0x4   0x.... 0x....      BL       _ZNK10SdBaseFile8isSubDirEv
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD016             BEQ.N    ??rmdir_0
   1352          
   1353            rewind();
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _ZN10SdBaseFile6rewindEv
   1354          
   1355            // make sure directory is empty
   1356            while (curPosition_ < fileSize_) {
   \                     ??rmdir_1: (+1)
   \       0x12   0x68A0             LDR      R0,[R4, #+8]
   \       0x14   0x6961             LDR      R1,[R4, #+20]
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD211             BCS.N    ??rmdir_2
   1357              dir_t* p = readDirCache();
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x.... 0x....      BL       _ZN10SdBaseFile12readDirCacheEv
   1358              if (!p) goto fail;
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD00A             BEQ.N    ??rmdir_0
   1359              // done if past last used entry
   1360              if (p->name[0] == DIR_NAME_FREE) break;
   \       0x24   0x7801             LDRB     R1,[R0, #+0]
   \       0x26   0x2900             CMP      R1,#+0
   \       0x28   0xD009             BEQ.N    ??rmdir_2
   1361              // skip empty slot, '.' or '..'
   1362              if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') continue;
   \       0x2A   0x29E5             CMP      R1,#+229
   \       0x2C   0xD0F1             BEQ.N    ??rmdir_1
   \       0x2E   0x292E             CMP      R1,#+46
   \       0x30   0xD0EF             BEQ.N    ??rmdir_1
   1363              // error not empty
   1364              if (DIR_IS_FILE_OR_SUBDIR(p)) goto fail;
   \       0x32   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f21DIR_IS_FILE_OR_SUBDIREPK14directoryEntry
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD0EB             BEQ.N    ??rmdir_1
   1365            }
   1366            // convert empty directory to normal file for remove
   1367            type_ = FAT_FILE_TYPE_NORMAL;
   1368            flags_ |= O_WRITE;
   1369            return remove();
   1370          fail:
   1371            return false;
   \                     ??rmdir_0: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xBD10             POP      {R4,PC}          ;; return
   \                     ??rmdir_2: (+1)
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x70E0             STRB     R0,[R4, #+3]
   \       0x42   0x7860             LDRB     R0,[R4, #+1]
   \       0x44   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0x48   0x7060             STRB     R0,[R4, #+1]
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x50   0x....             B.N      _ZN10SdBaseFile6removeEv
   1372          }
   1373          //------------------------------------------------------------------------------
   1374          /** Recursively delete a directory and all contained files.
   1375           *
   1376           * This is like the Unix/Linux 'rm -rf *' if called with the root directory
   1377           * hence the name.
   1378           *
   1379           * Warning - This will remove all contents of the directory including
   1380           * subdirectories.  The directory will then be removed if it is not root.
   1381           * The read-only attribute for files will be ignored.
   1382           *
   1383           * \note This function should not be used to delete the 8.3 version of
   1384           * a directory that has a long name.  See remove() and rmdir().
   1385           *
   1386           * \return The value one, true, is returned for success and
   1387           * the value zero, false, is returned for failure.
   1388           */

   \                                 In section .text, align 2, keep-with-next
   1389          bool SdBaseFile::rmRfStar() {
   \                     _ZN10SdBaseFile8rmRfStarEv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x4604             MOV      R4,R0
   1390            uint16_t index;
   1391            SdBaseFile f;
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
   1392            rewind();
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _ZN10SdBaseFile6rewindEv
   1393            while (curPosition_ < fileSize_) {
   \                     ??rmRfStar_0: (+1)
   \       0x12   0x68A5             LDR      R5,[R4, #+8]
   \       0x14   0x6960             LDR      R0,[R4, #+20]
   \       0x16   0x4285             CMP      R5,R0
   \       0x18   0xD241             BCS.N    ??rmRfStar_1
   1394              // remember position
   1395              index = curPosition_ / 32;
   \       0x1A   0x096D             LSRS     R5,R5,#+5
   1396          
   1397              dir_t* p = readDirCache();
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       _ZN10SdBaseFile12readDirCacheEv
   1398              if (!p) goto fail;
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD01D             BEQ.N    ??rmRfStar_2
   1399          
   1400              // done if past last entry
   1401              if (p->name[0] == DIR_NAME_FREE) break;
   \       0x26   0x7801             LDRB     R1,[R0, #+0]
   \       0x28   0x2900             CMP      R1,#+0
   \       0x2A   0xD038             BEQ.N    ??rmRfStar_1
   1402          
   1403              // skip empty slot or '.' or '..'
   1404              if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') continue;
   \       0x2C   0x29E5             CMP      R1,#+229
   \       0x2E   0xD0F0             BEQ.N    ??rmRfStar_0
   \       0x30   0x292E             CMP      R1,#+46
   \       0x32   0xD0EE             BEQ.N    ??rmRfStar_0
   1405          
   1406              // skip if part of long file name or volume label in root
   1407              if (!DIR_IS_FILE_OR_SUBDIR(p)) continue;
   \       0x34   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f21DIR_IS_FILE_OR_SUBDIREPK14directoryEntry
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD0EA             BEQ.N    ??rmRfStar_0
   1408          
   1409              if (!f.open(this, index, O_READ)) goto fail;
   \       0x3C   0x2301             MOVS     R3,#+1
   \       0x3E   0x462A             MOV      R2,R5
   \       0x40   0xB292             UXTH     R2,R2
   \       0x42   0x4621             MOV      R1,R4
   \       0x44   0x4668             MOV      R0,SP
   \       0x46   0x.... 0x....      BL       _ZN10SdBaseFile4openEPS_th
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD009             BEQ.N    ??rmRfStar_2
   1410              if (f.isSubDir()) {
   \       0x4E   0x4668             MOV      R0,SP
   \       0x50   0x.... 0x....      BL       _ZNK10SdBaseFile8isSubDirEv
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD00A             BEQ.N    ??rmRfStar_3
   1411                // recursively delete
   1412                if (!f.rmRfStar()) goto fail;
   \       0x58   0x4668             MOV      R0,SP
   \       0x5A   0xF7FF 0xFFD1      BL       _ZN10SdBaseFile8rmRfStarEv
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD110             BNE.N    ??rmRfStar_4
   1413              }
   1414              else {
   1415                // ignore read-only
   1416                f.flags_ |= O_WRITE;
   1417                if (!f.remove()) goto fail;
   1418              }
   1419              // position to next entry if required
   1420              if (curPosition_ != (32 * (index + 1))) {
   1421                if (!seekSet(32 * (index + 1))) goto fail;
   1422              }
   1423            }
   1424            // don't try to delete root
   1425            if (!isRoot()) {
   1426              if (!rmdir()) goto fail;
   1427            }
   1428            return true;
   1429          fail:
   1430            return false;
   \                     ??rmRfStar_2: (+1)
   \       0x62   0x4668             MOV      R0,SP
   \       0x64   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??rmRfStar_5: (+1)
   \       0x6A   0xB009             ADD      SP,SP,#+36
   \       0x6C   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??rmRfStar_3: (+1)
   \       0x6E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x72   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0x76   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \       0x7A   0x4668             MOV      R0,SP
   \       0x7C   0x.... 0x....      BL       _ZN10SdBaseFile6removeEv
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD0EE             BEQ.N    ??rmRfStar_2
   \                     ??rmRfStar_4: (+1)
   \       0x84   0xB2AD             UXTH     R5,R5
   \       0x86   0x1C6D             ADDS     R5,R5,#+1
   \       0x88   0x016D             LSLS     R5,R5,#+5
   \       0x8A   0x68A0             LDR      R0,[R4, #+8]
   \       0x8C   0x42A8             CMP      R0,R5
   \       0x8E   0xD0C0             BEQ.N    ??rmRfStar_0
   \       0x90   0x4629             MOV      R1,R5
   \       0x92   0x4620             MOV      R0,R4
   \       0x94   0x.... 0x....      BL       _ZN10SdBaseFile7seekSetEj
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD1BA             BNE.N    ??rmRfStar_0
   \       0x9C   0xE7E1             B.N      ??rmRfStar_2
   \                     ??rmRfStar_1: (+1)
   \       0x9E   0x4620             MOV      R0,R4
   \       0xA0   0x.... 0x....      BL       _ZNK10SdBaseFile6isRootEv
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD104             BNE.N    ??rmRfStar_6
   \       0xA8   0x4620             MOV      R0,R4
   \       0xAA   0x.... 0x....      BL       _ZN10SdBaseFile5rmdirEv
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD0D7             BEQ.N    ??rmRfStar_2
   \                     ??rmRfStar_6: (+1)
   \       0xB2   0x4668             MOV      R0,SP
   \       0xB4   0x.... 0x....      BL       _ZN10SdBaseFileD1Ev
   \       0xB8   0x2001             MOVS     R0,#+1
   \       0xBA   0xE7D6             B.N      ??rmRfStar_5
   1431          }
   1432          //------------------------------------------------------------------------------
   1433          /**  Create a file object and open it in the current working directory.
   1434           *
   1435           * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
   1436           *
   1437           * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
   1438           * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
   1439           */

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp SdBaseFile::subobject SdBaseFile(char const *, uint8_t)
   \                     _ZN10SdBaseFileC2EPKch: (+1)
   \        0x0   0x.... 0x....      B.W      _ZN10SdBaseFileC1EPKch

   \                                 In section .text, align 2, keep-with-next
   1440          SdBaseFile::SdBaseFile(const char* path, uint8_t oflag) {
   \                     _ZN10SdBaseFileC1EPKch: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1441            type_ = FAT_FILE_TYPE_CLOSED;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x70E0             STRB     R0,[R4, #+3]
   1442            writeError = false;
   \        0x8   0x7020             STRB     R0,[R4, #+0]
   1443            open(path, oflag);
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x.... 0x....      BL       _ZN10SdBaseFile4openEPKch
   1444          }
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0xBD10             POP      {R4,PC}          ;; return
   1445          //------------------------------------------------------------------------------
   1446          /** Sets a file's position.
   1447           *
   1448           * \param[in] pos The new position in bytes from the beginning of the file.
   1449           *
   1450           * \return The value one, true, is returned for success and
   1451           * the value zero, false, is returned for failure.
   1452           */

   \                                 In section .text, align 2, keep-with-next
   1453          bool SdBaseFile::seekSet(uint32_t pos) {
   \                     _ZN10SdBaseFile7seekSetEj: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   1454            uint32_t nCur;
   1455            uint32_t nNew;
   1456            // error if file not open or seek past end of file
   1457            if (!isOpen() || pos > fileSize_) goto fail;
   \        0x6   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD024             BEQ.N    ??seekSet_0
   \        0xE   0x6968             LDR      R0,[R5, #+20]
   \       0x10   0x42A0             CMP      R0,R4
   \       0x12   0xD321             BCC.N    ??seekSet_0
   1458          
   1459            if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {
   \       0x14   0x78E8             LDRB     R0,[R5, #+3]
   \       0x16   0x2802             CMP      R0,#+2
   \       0x18   0xD023             BEQ.N    ??seekSet_1
   1460              curPosition_ = pos;
   1461              goto done;
   1462            }
   1463            if (pos == 0) {
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD103             BNE.N    ??seekSet_2
   1464              // set position to start of file
   1465              curCluster_ = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6068             STR      R0,[R5, #+4]
   1466              curPosition_ = 0;
   \       0x22   0x60A8             STR      R0,[R5, #+8]
   1467              goto done;
   \       0x24   0xE01E             B.N      ??seekSet_3
   1468            }
   1469            // calculate cluster index for cur and new position
   1470            nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
   \                     ??seekSet_2: (+1)
   \       0x26   0x69E8             LDR      R0,[R5, #+28]
   \       0x28   0x7C02             LDRB     R2,[R0, #+16]
   \       0x2A   0x3209             ADDS     R2,R2,#+9
   \       0x2C   0x68A8             LDR      R0,[R5, #+8]
   \       0x2E   0x1E41             SUBS     R1,R0,#+1
   \       0x30   0x40D1             LSRS     R1,R1,R2
   1471            nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
   \       0x32   0x1E66             SUBS     R6,R4,#+1
   \       0x34   0x40D6             LSRS     R6,R6,R2
   1472          
   1473            if (nNew < nCur || curPosition_ == 0) {
   \       0x36   0x428E             CMP      R6,R1
   \       0x38   0xD301             BCC.N    ??seekSet_4
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD10E             BNE.N    ??seekSet_5
   1474              // must follow chain from first cluster
   1475              curCluster_ = firstCluster_;
   \                     ??seekSet_4: (+1)
   \       0x3E   0x69A8             LDR      R0,[R5, #+24]
   \       0x40   0x6068             STR      R0,[R5, #+4]
   1476            }
   1477            else {
   1478              // advance from curPosition
   1479              nNew -= nCur;
   1480            }
   1481            while (nNew--) {
   \                     ??seekSet_6: (+1)
   \       0x42   0x4630             MOV      R0,R6
   \       0x44   0x1E46             SUBS     R6,R0,#+1
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD00B             BEQ.N    ??seekSet_1
   1482              if (!vol_->fatGet(curCluster_, &curCluster_)) goto fail;
   \       0x4A   0x1D2A             ADDS     R2,R5,#+4
   \       0x4C   0x6869             LDR      R1,[R5, #+4]
   \       0x4E   0x69E8             LDR      R0,[R5, #+28]
   \       0x50   0x.... 0x....      BL       _ZN8SdVolume6fatGetEjPj
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD1F4             BNE.N    ??seekSet_6
   1483            }
   1484            curPosition_ = pos;
   1485          
   1486          done:
   1487            return true;
   1488          
   1489          fail:
   1490            return false;
   \                     ??seekSet_0: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??seekSet_5: (+1)
   \       0x5C   0x1A71             SUBS     R1,R6,R1
   \       0x5E   0x460E             MOV      R6,R1
   \       0x60   0xE7EF             B.N      ??seekSet_6
   \                     ??seekSet_1: (+1)
   \       0x62   0x60AC             STR      R4,[R5, #+8]
   \                     ??seekSet_3: (+1)
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xBD70             POP      {R4-R6,PC}
   1491          }
   1492          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1493          void SdBaseFile::setpos(filepos_t* pos) {
   1494            curPosition_ = pos->position;
   \                     _ZN10SdBaseFile6setposEP9filepos_t: (+1)
   \        0x0   0x680A             LDR      R2,[R1, #+0]
   \        0x2   0x6082             STR      R2,[R0, #+8]
   1495            curCluster_ = pos->cluster;
   \        0x4   0x6849             LDR      R1,[R1, #+4]
   \        0x6   0x6041             STR      R1,[R0, #+4]
   1496          }
   \        0x8   0x4770             BX       LR               ;; return
   1497          //------------------------------------------------------------------------------
   1498          /** The sync() call causes all modified data and directory fields
   1499           * to be written to the storage device.
   1500           *
   1501           * \return The value one, true, is returned for success and
   1502           * the value zero, false, is returned for failure.
   1503           * Reasons for failure include a call to sync() before a file has been
   1504           * opened or an I/O error.
   1505           */

   \                                 In section .text, align 2, keep-with-next
   1506          bool SdBaseFile::sync() {
   \                     _ZN10SdBaseFile4syncEv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   1507            // only allow open files and directories
   1508            if (!isOpen()) goto fail;
   \        0x4   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD02A             BEQ.N    ??sync_0
   1509          
   1510            if (flags_ & F_FILE_DIR_DIRTY) {
   \        0xC   0x7868             LDRB     R0,[R5, #+1]
   \        0xE   0x0600             LSLS     R0,R0,#+24
   \       0x10   0xD523             BPL.N    ??sync_1
   1511              dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0x.... 0x....      BL       _ZN10SdBaseFile13cacheDirEntryEh
   \       0x1A   0x0004             MOVS     R4,R0
   1512              // check for deleted by another open file object
   1513              if (!d || d->name[0] == DIR_NAME_DELETED) goto fail;
   \       0x1C   0xD021             BEQ.N    ??sync_0
   \       0x1E   0x7820             LDRB     R0,[R4, #+0]
   \       0x20   0x28E5             CMP      R0,#+229
   \       0x22   0xD01E             BEQ.N    ??sync_0
   1514          
   1515              // do not set filesize for dir files
   1516              if (!isDir()) d->fileSize = fileSize_;
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x.... 0x....      BL       _ZNK10SdBaseFile5isDirEv
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD101             BNE.N    ??sync_2
   \       0x2E   0x6968             LDR      R0,[R5, #+20]
   \       0x30   0x61E0             STR      R0,[R4, #+28]
   1517          
   1518              // update first cluster fields
   1519              d->firstClusterLow = firstCluster_ & 0XFFFF;
   \                     ??sync_2: (+1)
   \       0x32   0x69A8             LDR      R0,[R5, #+24]
   \       0x34   0x8360             STRH     R0,[R4, #+26]
   1520              d->firstClusterHigh = firstCluster_ >> 16;
   \       0x36   0x69A8             LDR      R0,[R5, #+24]
   \       0x38   0x0C00             LSRS     R0,R0,#+16
   \       0x3A   0x82A0             STRH     R0,[R4, #+20]
   1521          
   1522              // set modify time if user supplied a callback date/time function
   1523              if (dateTime_) {
   \       0x3C   0x....             LDR.N    R0,??DataTable12_1
   \       0x3E   0x6802             LDR      R2,[R0, #+0]
   \       0x40   0x2A00             CMP      R2,#+0
   \       0x42   0xD006             BEQ.N    ??sync_3
   1524                dateTime_(&d->lastWriteDate, &d->lastWriteTime);
                                 ^
Warning[Pa039]: use of address of unaligned structure member

        dateTime_(&d->lastWriteDate, &d->lastWriteTime);
                                     ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\SdBaseFile.cpp",1524  Warning[Pa039]: 
          use of address of unaligned structure member
   \       0x44   0xF104 0x0116      ADD      R1,R4,#+22
   \       0x48   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x4C   0x4790             BLX      R2
   1525                d->lastAccessDate = d->lastWriteDate;
   \       0x4E   0x8B20             LDRH     R0,[R4, #+24]
   \       0x50   0x8260             STRH     R0,[R4, #+18]
   1526              }
   1527              // clear directory dirty
   1528              flags_ &= ~F_FILE_DIR_DIRTY;
   \                     ??sync_3: (+1)
   \       0x52   0x7868             LDRB     R0,[R5, #+1]
   \       0x54   0xF000 0x007F      AND      R0,R0,#0x7F
   \       0x58   0x7068             STRB     R0,[R5, #+1]
   1529            }
   1530            return vol_->cacheFlush();
   \                     ??sync_1: (+1)
   \       0x5A   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x5E   0x.... 0x....      B.W      _ZN8SdVolume10cacheFlushEv
   1531          
   1532          fail:
   1533            writeError = true;
   \                     ??sync_0: (+1)
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0x7028             STRB     R0,[R5, #+0]
   1534            return false;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1535          }
   1536          //------------------------------------------------------------------------------
   1537          /** Copy a file's timestamps
   1538           *
   1539           * \param[in] file File to copy timestamps from.
   1540           *
   1541           * \note
   1542           * Modify and access timestamps may be overwritten if a date time callback
   1543           * function has been set by dateTimeCallback().
   1544           *
   1545           * \return The value one, true, is returned for success and
   1546           * the value zero, false, is returned for failure.
   1547           */

   \                                 In section .text, align 2, keep-with-next
   1548          bool SdBaseFile::timestamp(SdBaseFile* file) {
   \                     _ZN10SdBaseFile9timestampEPS_: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4608             MOV      R0,R1
   1549            dir_t* d;
   1550            dir_t dir;
   1551          
   1552            // get timestamps
   1553            if (!file->dirEntry(&dir)) goto fail;
   \        0x8   0x4669             MOV      R1,SP
   \        0xA   0x.... 0x....      BL       _ZN10SdBaseFile8dirEntryEP14directoryEntry
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD01F             BEQ.N    ??timestamp_0
   1554          
   1555            // update directory fields
   1556            if (!sync()) goto fail;
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       _ZN10SdBaseFile4syncEv
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD01A             BEQ.N    ??timestamp_0
   1557          
   1558            d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x.... 0x....      BL       _ZN10SdBaseFile13cacheDirEntryEh
   1559            if (!d) goto fail;
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD014             BEQ.N    ??timestamp_0
   1560          
   1561            // copy timestamps
   1562            d->lastAccessDate = dir.lastAccessDate;
   \       0x28   0xF8BD 0x1012      LDRH     R1,[SP, #+18]
   \       0x2C   0x8241             STRH     R1,[R0, #+18]
   1563            d->creationDate = dir.creationDate;
   \       0x2E   0xF8BD 0x1010      LDRH     R1,[SP, #+16]
   \       0x32   0x8201             STRH     R1,[R0, #+16]
   1564            d->creationTime = dir.creationTime;
   \       0x34   0xF8BD 0x100E      LDRH     R1,[SP, #+14]
   \       0x38   0x81C1             STRH     R1,[R0, #+14]
   1565            d->creationTimeTenths = dir.creationTimeTenths;
   \       0x3A   0xF89D 0x100D      LDRB     R1,[SP, #+13]
   \       0x3E   0x7341             STRB     R1,[R0, #+13]
   1566            d->lastWriteDate = dir.lastWriteDate;
   \       0x40   0xF8BD 0x1018      LDRH     R1,[SP, #+24]
   \       0x44   0x8301             STRH     R1,[R0, #+24]
   1567            d->lastWriteTime = dir.lastWriteTime;
   \       0x46   0xF8BD 0x1016      LDRH     R1,[SP, #+22]
   \       0x4A   0x82C1             STRH     R1,[R0, #+22]
   1568          
   1569            // write back entry
   1570            return vol_->cacheFlush();
   \       0x4C   0x.... 0x....      BL       _ZN8SdVolume10cacheFlushEv
   \       0x50   0xE000             B.N      ??timestamp_1
   1571          
   1572          fail:
   1573            return false;
   \                     ??timestamp_0: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \                     ??timestamp_1: (+1)
   \       0x54   0xB008             ADD      SP,SP,#+32
   \       0x56   0xBD10             POP      {R4,PC}          ;; return
   1574          }
   1575          //------------------------------------------------------------------------------
   1576          /** Set a file's timestamps in its directory entry.
   1577           *
   1578           * \param[in] flags Values for \a flags are constructed by a bitwise-inclusive
   1579           * OR of flags from the following list
   1580           *
   1581           * T_ACCESS - Set the file's last access date.
   1582           *
   1583           * T_CREATE - Set the file's creation date and time.
   1584           *
   1585           * T_WRITE - Set the file's last write/modification date and time.
   1586           *
   1587           * \param[in] year Valid range 1980 - 2107 inclusive.
   1588           *
   1589           * \param[in] month Valid range 1 - 12 inclusive.
   1590           *
   1591           * \param[in] day Valid range 1 - 31 inclusive.
   1592           *
   1593           * \param[in] hour Valid range 0 - 23 inclusive.
   1594           *
   1595           * \param[in] minute Valid range 0 - 59 inclusive.
   1596           *
   1597           * \param[in] second Valid range 0 - 59 inclusive
   1598           *
   1599           * \note It is possible to set an invalid date since there is no check for
   1600           * the number of days in a month.
   1601           *
   1602           * \note
   1603           * Modify and access timestamps may be overwritten if a date time callback
   1604           * function has been set by dateTimeCallback().
   1605           *
   1606           * \return The value one, true, is returned for success and
   1607           * the value zero, false, is returned for failure.
   1608           */

   \                                 In section .text, align 2, keep-with-next
   1609          bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
   1610                                     uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
   \                     _ZN10SdBaseFile9timestampEhthhhhh: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x4691             MOV      R9,R2
   \        0xA   0x469A             MOV      R10,R3
   1611            uint16_t dirDate;
   1612            uint16_t dirTime;
   1613            dir_t* d;
   1614          
   1615            if (!isOpen()
   1616                || year < 1980
   1617                || year > 2107
   1618                || month < 1
   1619                || month > 12
   1620                || day < 1
   1621                || day > 31
   1622                || hour > 23
   1623                || minute > 59
   1624                || second > 59) {
   \        0xC   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD04A             BEQ.N    ??timestamp_2
   \       0x14   0x4648             MOV      R0,R9
   \       0x16   0xF2A0 0x70BC      SUBW     R0,R0,#+1980
   \       0x1A   0x2880             CMP      R0,#+128
   \       0x1C   0xD245             BCS.N    ??timestamp_2
   \       0x1E   0x4650             MOV      R0,R10
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD042             BEQ.N    ??timestamp_2
   \       0x24   0x280D             CMP      R0,#+13
   \       0x26   0xDA40             BGE.N    ??timestamp_2
   \       0x28   0x9D0A             LDR      R5,[SP, #+40]
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0xD03D             BEQ.N    ??timestamp_2
   \       0x2E   0x2820             CMP      R0,#+32
   \       0x30   0xDA3B             BGE.N    ??timestamp_2
   \       0x32   0x9E0B             LDR      R6,[SP, #+44]
   \       0x34   0x4630             MOV      R0,R6
   \       0x36   0x2818             CMP      R0,#+24
   \       0x38   0xDA37             BGE.N    ??timestamp_2
   \       0x3A   0x9F0C             LDR      R7,[SP, #+48]
   \       0x3C   0x4638             MOV      R0,R7
   \       0x3E   0x283C             CMP      R0,#+60
   \       0x40   0xDA33             BGE.N    ??timestamp_2
   \       0x42   0xF8DD 0x8034      LDR      R8,[SP, #+52]
   \       0x46   0x4640             MOV      R0,R8
   \       0x48   0x283C             CMP      R0,#+60
   \       0x4A   0xDA2E             BGE.N    ??timestamp_2
   1625              goto fail;
   1626            }
   1627            // update directory entry
   1628            if (!sync()) goto fail;
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x.... 0x....      BL       _ZN10SdBaseFile4syncEv
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD029             BEQ.N    ??timestamp_2
   1629          
   1630            d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   \       0x56   0x2101             MOVS     R1,#+1
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x.... 0x....      BL       _ZN10SdBaseFile13cacheDirEntryEh
   \       0x5E   0x0004             MOVS     R4,R0
   1631            if (!d) goto fail;
   \       0x60   0xD023             BEQ.N    ??timestamp_2
   1632          
   1633            dirDate = FAT_DATE(year, month, day);
   \       0x62   0x462A             MOV      R2,R5
   \       0x64   0x4651             MOV      R1,R10
   \       0x66   0x4648             MOV      R0,R9
   \       0x68   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f8FAT_DATEEthh
   \       0x6C   0x4605             MOV      R5,R0
   1634            dirTime = FAT_TIME(hour, minute, second);
   \       0x6E   0x4642             MOV      R2,R8
   \       0x70   0x4639             MOV      R1,R7
   \       0x72   0x4630             MOV      R0,R6
   \       0x74   0x.... 0x....      BL       _ZN36_INTERNAL_14_SdBaseFile_cpp_9a4d697f8FAT_TIMEEhhh
   1635            if (flags & T_ACCESS) {
   \       0x78   0xEA5F 0x71CB      LSLS     R1,R11,#+31
   \       0x7C   0xD500             BPL.N    ??timestamp_3
   1636              d->lastAccessDate = dirDate;
   \       0x7E   0x8265             STRH     R5,[R4, #+18]
   1637            }
   1638            if (flags & T_CREATE) {
   \                     ??timestamp_3: (+1)
   \       0x80   0xEA5F 0x718B      LSLS     R1,R11,#+30
   \       0x84   0xD508             BPL.N    ??timestamp_4
   1639              d->creationDate = dirDate;
   \       0x86   0x8225             STRH     R5,[R4, #+16]
   1640              d->creationTime = dirTime;
   \       0x88   0x81E0             STRH     R0,[R4, #+14]
   1641              // seems to be units of 1/100 second not 1/10 as Microsoft states
   1642              d->creationTimeTenths = second & 1 ? 100 : 0;
   \       0x8A   0xEA5F 0x71C8      LSLS     R1,R8,#+31
   \       0x8E   0xD501             BPL.N    ??timestamp_5
   \       0x90   0x2164             MOVS     R1,#+100
   \       0x92   0xE000             B.N      ??timestamp_6
   \                     ??timestamp_5: (+1)
   \       0x94   0x2100             MOVS     R1,#+0
   \                     ??timestamp_6: (+1)
   \       0x96   0x7361             STRB     R1,[R4, #+13]
   1643            }
   1644            if (flags & T_WRITE) {
   \                     ??timestamp_4: (+1)
   \       0x98   0xEA5F 0x714B      LSLS     R1,R11,#+29
   \       0x9C   0xD501             BPL.N    ??timestamp_7
   1645              d->lastWriteDate = dirDate;
   \       0x9E   0x8325             STRH     R5,[R4, #+24]
   1646              d->lastWriteTime = dirTime;
   \       0xA0   0x82E0             STRH     R0,[R4, #+22]
   1647            }
   1648            return vol_->cacheFlush();
   \                     ??timestamp_7: (+1)
   \       0xA2   0xE8BD 0x4FF1      POP      {R0,R4-R11,LR}
   \       0xA6   0x.... 0x....      B.W      _ZN8SdVolume10cacheFlushEv
   1649          fail:
   1650            return false;
   \                     ??timestamp_2: (+1)
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1651          }
   1652          //------------------------------------------------------------------------------
   1653          /** Truncate a file to a specified length.  The current file position
   1654           * will be maintained if it is less than or equal to \a length otherwise
   1655           * it will be set to end of file.
   1656           *
   1657           * \param[in] length The desired length for the file.
   1658           *
   1659           * \return The value one, true, is returned for success and
   1660           * the value zero, false, is returned for failure.
   1661           * Reasons for failure include file is read only, file is a directory,
   1662           * \a length is greater than the current file size or an I/O error occurs.
   1663           */

   \                                 In section .text, align 2, keep-with-next
   1664          bool SdBaseFile::truncate(uint32_t length) {
   \                     _ZN10SdBaseFile8truncateEj: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   1665            uint32_t newPos;
   1666            // error if not a normal file or read-only
   1667            if (!isFile() || !(flags_ & O_WRITE)) goto fail;
   \        0x6   0x.... 0x....      BL       _ZNK10SdBaseFile6isFileEv
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD046             BEQ.N    ??truncate_0
   \        0xE   0x7868             LDRB     R0,[R5, #+1]
   \       0x10   0x0780             LSLS     R0,R0,#+30
   \       0x12   0xD543             BPL.N    ??truncate_0
   1668          
   1669            // error if length is greater than current size
   1670            if (length > fileSize_) goto fail;
   \       0x14   0x6968             LDR      R0,[R5, #+20]
   \       0x16   0x42A0             CMP      R0,R4
   \       0x18   0xD340             BCC.N    ??truncate_0
   1671          
   1672            // fileSize and length are zero - nothing to do
   1673            if (fileSize_ == 0) return true;
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD101             BNE.N    ??truncate_1
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xBD76             POP      {R1,R2,R4-R6,PC}
   1674          
   1675            // remember position for seek after truncation
   1676            newPos = curPosition_ > length ? length : curPosition_;
   \                     ??truncate_1: (+1)
   \       0x22   0x68A8             LDR      R0,[R5, #+8]
   \       0x24   0x4626             MOV      R6,R4
   \       0x26   0x4284             CMP      R4,R0
   \       0x28   0xD900             BLS.N    ??truncate_2
   \       0x2A   0x4606             MOV      R6,R0
   1677          
   1678            // position to last cluster in truncated file
   1679            if (!seekSet(length)) goto fail;
   \                     ??truncate_2: (+1)
   \       0x2C   0x4621             MOV      R1,R4
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x.... 0x....      BL       _ZN10SdBaseFile7seekSetEj
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD031             BEQ.N    ??truncate_0
   1680          
   1681            if (length == 0) {
   \       0x38   0x69E8             LDR      R0,[R5, #+28]
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD107             BNE.N    ??truncate_3
   1682              // free all clusters
   1683              if (!vol_->freeChain(firstCluster_)) goto fail;
   \       0x3E   0x69A9             LDR      R1,[R5, #+24]
   \       0x40   0x.... 0x....      BL       _ZN8SdVolume9freeChainEj
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD029             BEQ.N    ??truncate_0
   1684              firstCluster_ = 0;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x61A8             STR      R0,[R5, #+24]
   \       0x4C   0xE017             B.N      ??truncate_4
   1685            }
   1686            else {
   1687              uint32_t toFree;
   1688              if (!vol_->fatGet(curCluster_, &toFree)) goto fail;
   \                     ??truncate_3: (+1)
   \       0x4E   0x466A             MOV      R2,SP
   \       0x50   0x6869             LDR      R1,[R5, #+4]
   \       0x52   0x.... 0x....      BL       _ZN8SdVolume6fatGetEjPj
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD020             BEQ.N    ??truncate_0
   1689          
   1690              if (!vol_->isEOC(toFree)) {
   \       0x5A   0x9900             LDR      R1,[SP, #+0]
   \       0x5C   0x69E8             LDR      R0,[R5, #+28]
   \       0x5E   0x.... 0x....      BL       _ZNK8SdVolume5isEOCEj
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD10B             BNE.N    ??truncate_4
   1691                // free extra clusters
   1692                if (!vol_->freeChain(toFree)) goto fail;
   \       0x66   0x9900             LDR      R1,[SP, #+0]
   \       0x68   0x69E8             LDR      R0,[R5, #+28]
   \       0x6A   0x.... 0x....      BL       _ZN8SdVolume9freeChainEj
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD014             BEQ.N    ??truncate_0
   1693          
   1694                // current cluster is end of chain
   1695                if (!vol_->fatPutEOC(curCluster_)) goto fail;
   \       0x72   0x6869             LDR      R1,[R5, #+4]
   \       0x74   0x69E8             LDR      R0,[R5, #+28]
   \       0x76   0x.... 0x....      BL       _ZN8SdVolume9fatPutEOCEj
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD00E             BEQ.N    ??truncate_0
   1696              }
   1697            }
   1698            fileSize_ = length;
   \                     ??truncate_4: (+1)
   \       0x7E   0x616C             STR      R4,[R5, #+20]
   1699          
   1700            // need to update directory entry
   1701            flags_ |= F_FILE_DIR_DIRTY;
   \       0x80   0x7868             LDRB     R0,[R5, #+1]
   \       0x82   0xF040 0x0080      ORR      R0,R0,#0x80
   \       0x86   0x7068             STRB     R0,[R5, #+1]
   1702          
   1703            if (!sync()) goto fail;
   \       0x88   0x4628             MOV      R0,R5
   \       0x8A   0x.... 0x....      BL       _ZN10SdBaseFile4syncEv
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD004             BEQ.N    ??truncate_0
   1704          
   1705            // set file to correct position
   1706            return seekSet(newPos);
   \       0x92   0x4631             MOV      R1,R6
   \       0x94   0x4628             MOV      R0,R5
   \       0x96   0x.... 0x....      BL       _ZN10SdBaseFile7seekSetEj
   \       0x9A   0xBD76             POP      {R1,R2,R4-R6,PC}
   1707          
   1708          fail:
   1709            return false;
   \                     ??truncate_0: (+1)
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1710          }
   1711          //------------------------------------------------------------------------------
   1712          /** Write data to an open file.
   1713           *
   1714           * \note Data is moved to the cache but may not be written to the
   1715           * storage device until sync() is called.
   1716           *
   1717           * \param[in] buf Pointer to the location of the data to be written.
   1718           *
   1719           * \param[in] nbyte Number of bytes to write.
   1720           *
   1721           * \return For success write() returns the number of bytes written, always
   1722           * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
   1723           * include write() is called before a file has been opened, write is called
   1724           * for a read-only file, device is full, a corrupt file system or an I/O error.
   1725           *
   1726           */

   \                                 In section .text, align 2, keep-with-next
   1727          int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
   \                     _ZN10SdBaseFile5writeEPKvt: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4617             MOV      R7,R2
   1728            // convert void* to uint8_t*  -  must be before goto statements
   1729            const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);
   1730          
   1731            // number of bytes left to write  -  must be before goto statements
   1732            uint16_t nToWrite = nbyte;
   \        0xA   0x463C             MOV      R4,R7
   1733          
   1734            // error if not a normal file or is read-only
   1735            if (!isFile() || !(flags_ & O_WRITE)) goto fail;
   \        0xC   0x.... 0x....      BL       _ZNK10SdBaseFile6isFileEv
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD00E             BEQ.N    ??write_0
   \       0x14   0x7870             LDRB     R0,[R6, #+1]
   \       0x16   0x0781             LSLS     R1,R0,#+30
   \       0x18   0xD50B             BPL.N    ??write_0
   1736          
   1737            // seek to end of file if append flag
   1738            if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
   \       0x1A   0x0740             LSLS     R0,R0,#+29
   \       0x1C   0xD534             BPL.N    ??write_1
   \       0x1E   0x68B0             LDR      R0,[R6, #+8]
   \       0x20   0x6971             LDR      R1,[R6, #+20]
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD030             BEQ.N    ??write_1
   1739              if (!seekEnd()) goto fail;
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x4630             MOV      R0,R6
   \       0x2A   0x.... 0x....      BL       _ZN10SdBaseFile7seekEndEi
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD12A             BNE.N    ??write_1
   1740            }
   1741          
   1742            while (nToWrite > 0) {
   1743              uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
   1744              uint16_t blockOffset = curPosition_ & 0X1FF;
   1745              if (blockOfCluster == 0 && blockOffset == 0) {
   1746                // start of new cluster
   1747                if (curCluster_ == 0) {
   1748                  if (firstCluster_ == 0) {
   1749                    // allocate first cluster of file
   1750                    if (!addCluster()) goto fail;
   1751                  }
   1752                  else {
   1753                    curCluster_ = firstCluster_;
   1754                  }
   1755                }
   1756                else {
   1757                  uint32_t next;
   1758                  if (!vol_->fatGet(curCluster_, &next)) goto fail;
   1759                  if (vol_->isEOC(next)) {
   1760                    // add cluster if at end of chain
   1761                    if (!addCluster()) goto fail;
   1762                  }
   1763                  else {
   1764                    curCluster_ = next;
   1765                  }
   1766                }
   1767              }
   1768              // max space in block
   1769              uint16_t n = 512 - blockOffset;
   1770          
   1771              // lesser of space and amount to write
   1772              NOMORE(n, nToWrite);
   1773          
   1774              // block for data write
   1775              uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   1776              if (n == 512) {
   1777                // full block - don't need to use cache
   1778                if (vol_->cacheBlockNumber() == block) {
   1779                  // invalidate cache if block is in cache
   1780                  vol_->cacheSetBlockNumber(0XFFFFFFFF, false);
   1781                }
   1782                if (!vol_->writeBlock(block, src)) goto fail;
   1783              }
   1784              else {
   1785                if (blockOffset == 0 && curPosition_ >= fileSize_) {
   1786                  // start of new block don't need to read into cache
   1787                  if (!vol_->cacheFlush()) goto fail;
   1788                  // set cache dirty and SD address of block
   1789                  vol_->cacheSetBlockNumber(block, true);
   1790                }
   1791                else {
   1792                  // rewrite part of block
   1793                  if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;
   1794                }
   1795                uint8_t* dst = vol_->cache()->data + blockOffset;
   1796                memcpy(dst, src, n);
   1797              }
   1798              curPosition_ += n;
   1799              src += n;
   1800              nToWrite -= n;
   1801            }
   1802            if (curPosition_ > fileSize_) {
   1803              // update fileSize and insure sync will update dir entry
   1804              fileSize_ = curPosition_;
   1805              flags_ |= F_FILE_DIR_DIRTY;
   1806            }
   1807            else if (dateTime_ && nbyte) {
   1808              // insure sync will update modified date and time
   1809              flags_ |= F_FILE_DIR_DIRTY;
   1810            }
   1811          
   1812            if (flags_ & O_SYNC) {
   1813              if (!sync()) goto fail;
   1814            }
   1815            return nbyte;
   1816          
   1817          fail:
   1818            // return for write error
   1819            writeError = true;
   \                     ??write_0: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0x7030             STRB     R0,[R6, #+0]
   1820            return -1;
   \       0x36   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??write_2: (+1)
   \       0x3A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??write_3: (+1)
   \       0x3E   0x2101             MOVS     R1,#+1
   \       0x40   0x4658             MOV      R0,R11
   \       0x42   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD0F3             BEQ.N    ??write_0
   \       0x4A   0xE00E             B.N      ??write_4
   \                     ??write_5: (+1)
   \       0x4C   0x2D00             CMP      R5,#+0
   \       0x4E   0xD1F6             BNE.N    ??write_3
   \       0x50   0x68B0             LDR      R0,[R6, #+8]
   \       0x52   0x6971             LDR      R1,[R6, #+20]
   \       0x54   0x4288             CMP      R0,R1
   \       0x56   0xD3F2             BCC.N    ??write_3
   \       0x58   0x.... 0x....      BL       _ZN8SdVolume10cacheFlushEv
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD0E8             BEQ.N    ??write_0
   \       0x60   0x2201             MOVS     R2,#+1
   \       0x62   0x4659             MOV      R1,R11
   \       0x64   0x69F0             LDR      R0,[R6, #+28]
   \       0x66   0x.... 0x....      BL       _ZN8SdVolume19cacheSetBlockNumberEjb
   \                     ??write_4: (+1)
   \       0x6A   0x69F0             LDR      R0,[R6, #+28]
   \       0x6C   0x.... 0x....      BL       _ZN8SdVolume5cacheEv
   \       0x70   0x4428             ADD      R0,R0,R5
   \       0x72   0x4652             MOV      R2,R10
   \       0x74   0x4641             MOV      R1,R8
   \       0x76   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??write_6: (+1)
   \       0x7A   0x68B0             LDR      R0,[R6, #+8]
   \       0x7C   0x4450             ADD      R0,R10,R0
   \       0x7E   0x60B0             STR      R0,[R6, #+8]
   \       0x80   0x44D0             ADD      R8,R8,R10
   \       0x82   0xEBA4 0x040A      SUB      R4,R4,R10
   \       0x86   0xB2A4             UXTH     R4,R4
   \                     ??write_1: (+1)
   \       0x88   0x68B1             LDR      R1,[R6, #+8]
   \       0x8A   0x2C00             CMP      R4,#+0
   \       0x8C   0xD064             BEQ.N    ??write_7
   \       0x8E   0x69F0             LDR      R0,[R6, #+28]
   \       0x90   0x.... 0x....      BL       _ZNK8SdVolume14blockOfClusterEj
   \       0x94   0x4681             MOV      R9,R0
   \       0x96   0x68B5             LDR      R5,[R6, #+8]
   \       0x98   0xF3C5 0x0508      UBFX     R5,R5,#+0,#+9
   \       0x9C   0xEA55 0x0009      ORRS     R0,R5,R9
   \       0xA0   0xD121             BNE.N    ??write_8
   \       0xA2   0x6871             LDR      R1,[R6, #+4]
   \       0xA4   0x2900             CMP      R1,#+0
   \       0xA6   0xD10A             BNE.N    ??write_9
   \       0xA8   0x69B0             LDR      R0,[R6, #+24]
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD105             BNE.N    ??write_10
   \       0xAE   0x4630             MOV      R0,R6
   \       0xB0   0x.... 0x....      BL       _ZN10SdBaseFile10addClusterEv
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD116             BNE.N    ??write_8
   \       0xB8   0xE7BB             B.N      ??write_0
   \                     ??write_10: (+1)
   \       0xBA   0x6070             STR      R0,[R6, #+4]
   \       0xBC   0xE013             B.N      ??write_8
   \                     ??write_9: (+1)
   \       0xBE   0x466A             MOV      R2,SP
   \       0xC0   0x69F0             LDR      R0,[R6, #+28]
   \       0xC2   0x.... 0x....      BL       _ZN8SdVolume6fatGetEjPj
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD0B3             BEQ.N    ??write_0
   \       0xCA   0x9900             LDR      R1,[SP, #+0]
   \       0xCC   0x69F0             LDR      R0,[R6, #+28]
   \       0xCE   0x.... 0x....      BL       _ZNK8SdVolume5isEOCEj
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD005             BEQ.N    ??write_11
   \       0xD6   0x4630             MOV      R0,R6
   \       0xD8   0x.... 0x....      BL       _ZN10SdBaseFile10addClusterEv
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xD102             BNE.N    ??write_8
   \       0xE0   0xE7A7             B.N      ??write_0
   \                     ??write_11: (+1)
   \       0xE2   0x9800             LDR      R0,[SP, #+0]
   \       0xE4   0x6070             STR      R0,[R6, #+4]
   \                     ??write_8: (+1)
   \       0xE6   0xF5C5 0x7A00      RSB      R10,R5,#+512
   \       0xEA   0xFA1F 0xFA8A      UXTH     R10,R10
   \       0xEE   0x4554             CMP      R4,R10
   \       0xF0   0xDA00             BGE.N    ??write_12
   \       0xF2   0x46A2             MOV      R10,R4
   \                     ??write_12: (+1)
   \       0xF4   0x6871             LDR      R1,[R6, #+4]
   \       0xF6   0x69F0             LDR      R0,[R6, #+28]
   \       0xF8   0x.... 0x....      BL       _ZNK8SdVolume17clusterStartBlockEj
   \       0xFC   0x4683             MOV      R11,R0
   \       0xFE   0x44CB             ADD      R11,R9,R11
   \      0x100   0xF5BA 0x7F00      CMP      R10,#+512
   \      0x104   0xD1A2             BNE.N    ??write_5
   \      0x106   0x69F0             LDR      R0,[R6, #+28]
   \      0x108   0x.... 0x....      BL       _ZN8SdVolume16cacheBlockNumberEv
   \      0x10C   0x4558             CMP      R0,R11
   \      0x10E   0xD105             BNE.N    ??write_13
   \      0x110   0x2200             MOVS     R2,#+0
   \      0x112   0xF04F 0x31FF      MOV      R1,#-1
   \      0x116   0x69F0             LDR      R0,[R6, #+28]
   \      0x118   0x.... 0x....      BL       _ZN8SdVolume19cacheSetBlockNumberEjb
   \                     ??write_13: (+1)
   \      0x11C   0x4642             MOV      R2,R8
   \      0x11E   0x4659             MOV      R1,R11
   \      0x120   0x69F0             LDR      R0,[R6, #+28]
   \      0x122   0x.... 0x....      BL       _ZN8SdVolume10writeBlockEjPKh
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD1A7             BNE.N    ??write_6
   \      0x12A   0xE782             B.N      ??write_0
   \                     ??write_14: (+1)
   \      0x12C   0x....             LDR.N    R0,??DataTable13_2
   \      0x12E   0x6800             LDR      R0,[R0, #+0]
   \      0x130   0x2800             CMP      R0,#+0
   \      0x132   0xD005             BEQ.N    ??write_15
   \      0x134   0x0038             MOVS     R0,R7
   \      0x136   0xD003             BEQ.N    ??write_15
   \      0x138   0x7870             LDRB     R0,[R6, #+1]
   \      0x13A   0xF040 0x0080      ORR      R0,R0,#0x80
   \      0x13E   0x7070             STRB     R0,[R6, #+1]
   \                     ??write_15: (+1)
   \      0x140   0x7870             LDRB     R0,[R6, #+1]
   \      0x142   0x0700             LSLS     R0,R0,#+28
   \      0x144   0xD505             BPL.N    ??write_16
   \      0x146   0x4630             MOV      R0,R6
   \      0x148   0x.... 0x....      BL       _ZN10SdBaseFile4syncEv
   \      0x14C   0x2800             CMP      R0,#+0
   \      0x14E   0xF43F 0xAF70      BEQ.W    ??write_0
   \                     ??write_16: (+1)
   \      0x152   0x4638             MOV      R0,R7
   \      0x154   0xB200             SXTH     R0,R0
   \      0x156   0xE770             B.N      ??write_2
   \                     ??write_7: (+1)
   \      0x158   0x6970             LDR      R0,[R6, #+20]
   \      0x15A   0x4288             CMP      R0,R1
   \      0x15C   0xD2E6             BCS.N    ??write_14
   \      0x15E   0x6171             STR      R1,[R6, #+20]
   \      0x160   0x7870             LDRB     R0,[R6, #+1]
   \      0x162   0xF040 0x0080      ORR      R0,R0,#0x80
   \      0x166   0x7070             STRB     R0,[R6, #+1]
   \      0x168   0xE7EA             B.N      ??write_15
   1821          }
   1822          //------------------------------------------------------------------------------
   1823          // suppress cpplint warnings with NOLINT comment
   1824          #if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)

   \                                 In section .bss, align 4
   1825            void (*SdBaseFile::oldDateTime_)(uint16_t& date, uint16_t& time) = 0;  // NOLINT
   \                     _ZN10SdBaseFile12oldDateTime_E:
   \        0x0                      DS8 4

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x7C 0x3C          DC8 "|<>^+=?/[];,*\"\\"
   \              0x3E 0x5E    
   \              0x2B 0x3D    
   \              0x3F 0x2F    
   \              0x5B 0x5D    
   \              0x3B 0x2C    
   \              0x2A 0x22    
   \              0x5C 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     _ZN8SdVolume12cacheBuffer_E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x....'....        DC32     customizedSerial

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     _ZN10SdBaseFile4cwd_E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x....'....        DC32     _ZN10SdBaseFile9dateTime_E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     _ZN8SdVolume12cacheBuffer_E+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x....'....        DC32     customizedSerial

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x....'....        DC32     _ZN10SdBaseFile9dateTime_E
   1826          #endif  // ALLOW_DEPRECATED_FUNCTIONS
   1827          
   1828          
   1829          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DIR_IS_FILE(dir_t const *)
       0   DIR_IS_FILE_OR_SUBDIR(dir_t const *)
       0   DIR_IS_LONG_NAME(dir_t const *)
       0   DIR_IS_SUBDIR(dir_t const *)
       0   FAT_DATE(uint16_t, uint8_t, uint8_t)
       0   FAT_DAY(uint16_t)
       0   FAT_HOUR(uint16_t)
       0   FAT_MINUTE(uint16_t)
       0   FAT_MONTH(uint16_t)
       0   FAT_SECOND(uint16_t)
       0   FAT_TIME(uint8_t, uint8_t, uint8_t)
       0   FAT_YEAR(uint16_t)
      16   MarlinSerial::print(char const *)
         0   -> MarlinSerial::write(char const *)
         0   -> package_to_wifi
        16   -> strlen
      16   MarlinSerial::write(char const *)
         0   -> BSP_UartIfQueueTxData
        16   -> strlen
       8   MarlinSerial::write(uint8_t)
         8   -> BSP_UartIfQueueTxData
       0   SdBaseFile::SdBaseFile()
       8   SdBaseFile::SdBaseFile(char const *, uint8_t)
         8   -> SdBaseFile::open(char const *, uint8_t)
       8   SdBaseFile::addCluster()
         8   -> SdVolume::allocContiguous(uint32_t, uint32_t *)
      24   SdBaseFile::addDirCluster()
        24   -> SdBaseFile::addCluster()
        24   -> SdVolume::cacheFlush()
        24   -> SdVolume::cacheSetBlockNumber(uint32_t, bool)
        24   -> SdVolume::clusterStartBlock(uint32_t) const
        24   -> SdVolume::writeBlock(uint32_t, uint8_t const *)
        24   -> __aeabi_memset4
       8   SdBaseFile::cacheDirEntry(uint8_t)
         8   -> SdVolume::cache()
         8   -> SdVolume::cacheRawBlock(uint32_t, bool)
       8   SdBaseFile::close()
         8   -> SdBaseFile::sync()
      24   SdBaseFile::contiguousRange(uint32_t *, uint32_t *)
        24   -> SdVolume::clusterStartBlock(uint32_t) const
        24   -> SdVolume::fatGet(uint32_t, uint32_t *)
        24   -> SdVolume::isEOC(uint32_t) const
      16   SdBaseFile::createContiguous(SdBaseFile *, char const *, uint32_t)
        16   -> SdBaseFile::open(SdBaseFile *, char const *, uint8_t)
        16   -> SdBaseFile::remove()
         0   -> SdBaseFile::sync()
        16   -> SdVolume::allocContiguous(uint32_t, uint32_t *)
       0   SdBaseFile::curPosition() const
      16   SdBaseFile::dirEntry(dir_t *)
        16   -> SdBaseFile::cacheDirEntry(uint8_t)
        16   -> SdBaseFile::sync()
        16   -> __aeabi_memcpy
       8   SdBaseFile::dirName(dir_t const &, char *)
      48   SdBaseFile::exists(char const *)
        48   -> SdBaseFile::SdBaseFile()
        48   -> SdBaseFile::open(SdBaseFile *, char const *, uint8_t)
        48   -> SdBaseFile::~SdBaseFile()
      40   SdBaseFile::fgets(char *, int16_t, char *)
        40   -> SdBaseFile::read(void *, uint16_t)
        40   -> __iar_Strchr
      16   SdBaseFile::getFilename(char *)
        16   -> SdBaseFile::cacheDirEntry(uint8_t)
        16   -> SdBaseFile::dirName(dir_t const &, char *)
        16   -> SdBaseFile::isOpen() const
        16   -> SdBaseFile::isRoot() const
       0   SdBaseFile::getpos(filepos_t *)
       0   SdBaseFile::isDir() const
       0   SdBaseFile::isFile() const
       0   SdBaseFile::isOpen() const
       0   SdBaseFile::isRoot() const
       0   SdBaseFile::isSubDir() const
      56   SdBaseFile::ls(uint8_t, uint8_t)
        56   -> SdBaseFile::SdBaseFile()
        56   -> SdBaseFile::curPosition() const
        56   -> SdBaseFile::ls(uint8_t, uint8_t)
        56   -> SdBaseFile::lsPrintNext(uint8_t, uint8_t)
        56   -> SdBaseFile::open(SdBaseFile *, uint16_t, uint8_t)
        56   -> SdBaseFile::rewind()
        56   -> SdBaseFile::seekSet(uint32_t)
        56   -> SdBaseFile::~SdBaseFile()
      56   SdBaseFile::lsPrintNext(uint8_t, uint8_t)
        56   -> DIR_IS_FILE(dir_t const *)
        56   -> DIR_IS_FILE_OR_SUBDIR(dir_t const *)
        56   -> DIR_IS_SUBDIR(dir_t const *)
        56   -> MarlinSerial::print(unsigned int, int)
        56   -> MarlinSerial::println()
        56   -> MarlinSerial::write(uint8_t)
        56   -> SdBaseFile::printFatDate(uint16_t)
        56   -> SdBaseFile::printFatTime(uint16_t)
        56   -> SdBaseFile::read(void *, uint16_t)
      16   SdBaseFile::make83Name(char const *, uint8_t *, char const **)
     104   SdBaseFile::mkdir(SdBaseFile *, char const *, bool)
       104   -> SdBaseFile::SdBaseFile()
       104   -> SdBaseFile::close()
       104   -> SdBaseFile::isOpen() const
       104   -> SdBaseFile::isRoot() const
       104   -> SdBaseFile::make83Name(char const *, uint8_t *, char const **)
       104   -> SdBaseFile::mkdir(SdBaseFile *, uint8_t const *)
       104   -> SdBaseFile::open(SdBaseFile *, uint8_t const *, uint8_t)
       104   -> SdBaseFile::openRoot(SdVolume *)
       104   -> SdBaseFile::~SdBaseFile()
      48   SdBaseFile::mkdir(SdBaseFile *, uint8_t const *)
        48   -> SdBaseFile::addDirCluster()
        48   -> SdBaseFile::cacheDirEntry(uint8_t)
        48   -> SdBaseFile::isDir() const
        48   -> SdBaseFile::isRoot() const
        48   -> SdBaseFile::open(SdBaseFile *, uint8_t const *, uint8_t)
        48   -> SdBaseFile::sync()
        48   -> SdVolume::cache()
        48   -> SdVolume::cacheFlush()
        48   -> SdVolume::cacheRawBlock(uint32_t, bool)
        48   -> SdVolume::clusterStartBlock(uint32_t) const
        48   -> __aeabi_memcpy
     104   SdBaseFile::open(SdBaseFile *, char const *, uint8_t)
       104   -> SdBaseFile::SdBaseFile()
       104   -> SdBaseFile::close()
       104   -> SdBaseFile::isOpen() const
       104   -> SdBaseFile::isRoot() const
       104   -> SdBaseFile::make83Name(char const *, uint8_t *, char const **)
       104   -> SdBaseFile::open(SdBaseFile *, uint8_t const *, uint8_t)
       104   -> SdBaseFile::openRoot(SdVolume *)
       104   -> SdBaseFile::~SdBaseFile()
      24   SdBaseFile::open(SdBaseFile *, uint16_t, uint8_t)
        24   -> SdBaseFile::isOpen() const
         0   -> SdBaseFile::openCachedEntry(uint8_t, uint8_t)
        24   -> SdBaseFile::readDirCache()
        24   -> SdBaseFile::seekSet(uint32_t)
      40   SdBaseFile::open(SdBaseFile *, uint8_t const *, uint8_t)
        40   -- Indirect call
        40   -> SdBaseFile::addDirCluster()
        40   -> SdBaseFile::cacheDirEntry(uint8_t)
         0   -> SdBaseFile::openCachedEntry(uint8_t, uint8_t)
        40   -> SdBaseFile::readDirCache()
        40   -> SdBaseFile::rewind()
        40   -> SdVolume::cache()
        40   -> SdVolume::cacheBlockNumber()
        40   -> SdVolume::cacheFlush()
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> memcmp
       0   SdBaseFile::open(char const *, uint8_t)
         0   -> SdBaseFile::open(SdBaseFile *, char const *, uint8_t)
      24   SdBaseFile::openCachedEntry(uint8_t, uint8_t)
        24   -> DIR_IS_FILE(dir_t const *)
        24   -> DIR_IS_SUBDIR(dir_t const *)
         0   -> SdBaseFile::seekEnd(int32_t)
        24   -> SdBaseFile::truncate(uint32_t)
        24   -> SdVolume::cache()
        24   -> SdVolume::cacheBlockNumber()
        24   -> SdVolume::chainSize(uint32_t, uint32_t *)
      24   SdBaseFile::openNext(SdBaseFile *, uint8_t)
        24   -> DIR_IS_FILE_OR_SUBDIR(dir_t const *)
        24   -> SdBaseFile::isOpen() const
         0   -> SdBaseFile::openCachedEntry(uint8_t, uint8_t)
        24   -> SdBaseFile::readDirCache()
      80   SdBaseFile::openParent(SdBaseFile *)
        80   -> SdBaseFile::SdBaseFile()
        80   -> SdBaseFile::curPosition() const
        80   -> SdBaseFile::isDir() const
        80   -> SdBaseFile::isOpen() const
        80   -> SdBaseFile::isRoot() const
        80   -> SdBaseFile::open(SdBaseFile *, uint16_t, uint8_t)
        80   -> SdBaseFile::openCachedEntry(uint8_t, uint8_t)
        80   -> SdBaseFile::openRoot(SdVolume *)
        80   -> SdBaseFile::read(void *, uint16_t)
        80   -> SdBaseFile::readDir(dir_t *, char *)
        80   -> SdBaseFile::seekSet(uint32_t)
        80   -> SdBaseFile::volume() const
        80   -> SdBaseFile::~SdBaseFile()
        80   -> SdVolume::cacheRawBlock(uint32_t, bool)
        80   -> SdVolume::clusterStartBlock(uint32_t) const
      16   SdBaseFile::openRoot(SdVolume *)
        16   -> SdBaseFile::isOpen() const
        16   -> SdVolume::chainSize(uint32_t, uint32_t *)
        16   -> SdVolume::fatType() const
        16   -> SdVolume::rootDirEntryCount() const
        16   -> SdVolume::rootDirStart() const
      24   SdBaseFile::peek()
        24   -> SdBaseFile::getpos(filepos_t *)
        24   -> SdBaseFile::read()
        24   -> SdBaseFile::setpos(filepos_t *)
        24   -> filepos_t::filepos_t()
      32   SdBaseFile::printDirName(dir_t const &, uint8_t, bool)
        32   -> DIR_IS_SUBDIR(dir_t const *)
        32   -> MarlinSerial::write(uint8_t)
      16   SdBaseFile::printFatDate(uint16_t)
        16   -> FAT_DAY(uint16_t)
        16   -> FAT_MONTH(uint16_t)
        16   -> FAT_YEAR(uint16_t)
        16   -> MarlinSerial::print(int, int)
        16   -> MarlinSerial::write(uint8_t)
         0   -> print2u(uint8_t)
        16   -> print2u(uint8_t)
      16   SdBaseFile::printFatTime(uint16_t)
        16   -> FAT_HOUR(uint16_t)
        16   -> FAT_MINUTE(uint16_t)
        16   -> FAT_SECOND(uint16_t)
        16   -> MarlinSerial::write(uint8_t)
         0   -> print2u(uint8_t)
        16   -> print2u(uint8_t)
      24   SdBaseFile::printName()
        24   -> MarlinSerial::print(char const *)
        24   -> SdBaseFile::getFilename(char *)
       8   SdBaseFile::read()
         8   -> SdBaseFile::read(void *, uint16_t)
      32   SdBaseFile::read(void *, uint16_t)
        32   -> SdBaseFile::isOpen() const
        32   -> SdVolume::blockOfCluster(uint32_t) const
        32   -> SdVolume::cache()
        32   -> SdVolume::cacheBlockNumber()
        32   -> SdVolume::cacheRawBlock(uint32_t, bool)
        32   -> SdVolume::clusterStartBlock(uint32_t) const
        32   -> SdVolume::fatGet(uint32_t, uint32_t *)
        32   -> SdVolume::readBlock(uint32_t, uint8_t *)
        32   -> SdVolume::rootDirStart() const
        32   -> __aeabi_memcpy
      24   SdBaseFile::readDir(dir_t *, char *)
        24   -> DIR_IS_FILE_OR_SUBDIR(dir_t const *)
        24   -> DIR_IS_LONG_NAME(dir_t const *)
        24   -> SdBaseFile::isDir() const
        24   -> SdBaseFile::read(void *, uint16_t)
      16   SdBaseFile::readDirCache()
        16   -> SdBaseFile::isDir() const
        16   -> SdBaseFile::read()
        16   -> SdVolume::cache()
       8   SdBaseFile::remove()
         8   -> SdBaseFile::cacheDirEntry(uint8_t)
         8   -> SdBaseFile::truncate(uint32_t)
         0   -> SdVolume::cacheFlush()
      48   SdBaseFile::remove(SdBaseFile *, char const *)
        48   -> SdBaseFile::SdBaseFile()
        48   -> SdBaseFile::open(SdBaseFile *, char const *, uint8_t)
        48   -> SdBaseFile::remove()
        48   -> SdBaseFile::~SdBaseFile()
      88   SdBaseFile::rename(SdBaseFile *, char const *)
        88   -> SdBaseFile::SdBaseFile()
        88   -> SdBaseFile::cacheDirEntry(uint8_t)
        88   -> SdBaseFile::isFile() const
        88   -> SdBaseFile::isSubDir() const
        88   -> SdBaseFile::mkdir(SdBaseFile *, char const *, bool)
        88   -> SdBaseFile::open(SdBaseFile *, char const *, uint8_t)
        88   -> SdBaseFile::sync()
        88   -> SdBaseFile::~SdBaseFile()
        88   -> SdVolume::cache()
        88   -> SdVolume::cacheFlush()
        88   -> SdVolume::cacheRawBlock(uint32_t, bool)
        88   -> SdVolume::clusterStartBlock(uint32_t) const
        88   -> SdVolume::freeChain(uint32_t)
        88   -> __aeabi_memcpy
       0   SdBaseFile::rewind()
         0   -> SdBaseFile::seekSet(uint32_t)
      48   SdBaseFile::rmRfStar()
        48   -> DIR_IS_FILE_OR_SUBDIR(dir_t const *)
        48   -> SdBaseFile::SdBaseFile()
        48   -> SdBaseFile::isRoot() const
        48   -> SdBaseFile::isSubDir() const
        48   -> SdBaseFile::open(SdBaseFile *, uint16_t, uint8_t)
        48   -> SdBaseFile::readDirCache()
        48   -> SdBaseFile::remove()
        48   -> SdBaseFile::rewind()
        48   -> SdBaseFile::rmRfStar()
        48   -> SdBaseFile::rmdir()
        48   -> SdBaseFile::seekSet(uint32_t)
        48   -> SdBaseFile::~SdBaseFile()
       8   SdBaseFile::rmdir()
         8   -> DIR_IS_FILE_OR_SUBDIR(dir_t const *)
         8   -> SdBaseFile::isSubDir() const
         8   -> SdBaseFile::readDirCache()
         0   -> SdBaseFile::remove()
         8   -> SdBaseFile::rewind()
       0   SdBaseFile::seekEnd(int32_t)
         0   -> SdBaseFile::seekSet(uint32_t)
      16   SdBaseFile::seekSet(uint32_t)
        16   -> SdBaseFile::isOpen() const
        16   -> SdVolume::fatGet(uint32_t, uint32_t *)
       0   SdBaseFile::setpos(filepos_t *)
       0   SdBaseFile::subobject SdBaseFile(char const *, uint8_t)
         0   -> SdBaseFile::SdBaseFile(char const *, uint8_t)
      16   SdBaseFile::sync()
        16   -- Indirect call
        16   -> SdBaseFile::cacheDirEntry(uint8_t)
        16   -> SdBaseFile::isDir() const
        16   -> SdBaseFile::isOpen() const
         0   -> SdVolume::cacheFlush()
      40   SdBaseFile::timestamp(SdBaseFile *)
        40   -> SdBaseFile::cacheDirEntry(uint8_t)
        40   -> SdBaseFile::dirEntry(dir_t *)
        40   -> SdBaseFile::sync()
        40   -> SdVolume::cacheFlush()
      40   SdBaseFile::timestamp(uint8_t, uint16_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
        40   -> FAT_DATE(uint16_t, uint8_t, uint8_t)
        40   -> FAT_TIME(uint8_t, uint8_t, uint8_t)
        40   -> SdBaseFile::cacheDirEntry(uint8_t)
        40   -> SdBaseFile::isOpen() const
        40   -> SdBaseFile::sync()
         0   -> SdVolume::cacheFlush()
      24   SdBaseFile::truncate(uint32_t)
        24   -> SdBaseFile::isFile() const
        24   -> SdBaseFile::seekSet(uint32_t)
        24   -> SdBaseFile::sync()
        24   -> SdVolume::fatGet(uint32_t, uint32_t *)
        24   -> SdVolume::fatPutEOC(uint32_t)
        24   -> SdVolume::freeChain(uint32_t)
        24   -> SdVolume::isEOC(uint32_t) const
       0   SdBaseFile::volume() const
      40   SdBaseFile::write(void const *, uint16_t)
        40   -> SdBaseFile::addCluster()
        40   -> SdBaseFile::isFile() const
        40   -> SdBaseFile::seekEnd(int32_t)
        40   -> SdBaseFile::sync()
        40   -> SdVolume::blockOfCluster(uint32_t) const
        40   -> SdVolume::cache()
        40   -> SdVolume::cacheBlockNumber()
        40   -> SdVolume::cacheFlush()
        40   -> SdVolume::cacheRawBlock(uint32_t, bool)
        40   -> SdVolume::cacheSetBlockNumber(uint32_t, bool)
        40   -> SdVolume::clusterStartBlock(uint32_t) const
        40   -> SdVolume::fatGet(uint32_t, uint32_t *)
        40   -> SdVolume::isEOC(uint32_t) const
        40   -> SdVolume::writeBlock(uint32_t, uint8_t const *)
        40   -> __aeabi_memcpy
       8   SdBaseFile::~SdBaseFile()
         8   -> SdBaseFile::close()
         8   -> SdBaseFile::isOpen() const
       0   SdVolume::blockOfCluster(uint32_t) const
       0   SdVolume::cache()
       0   SdVolume::cacheBlockNumber()
       0   SdVolume::cacheSetBlockNumber(uint32_t, bool)
       0   SdVolume::clusterStartBlock(uint32_t) const
       0   SdVolume::fatPutEOC(uint32_t)
         0   -> SdVolume::fatPut(uint32_t, uint32_t)
       0   SdVolume::fatType() const
       0   SdVolume::isEOC(uint32_t) const
       0   SdVolume::readBlock(uint32_t, uint8_t *)
         0   -> Sd2Card::readBlock(uint32_t, uint8_t *)
       0   SdVolume::rootDirEntryCount() const
       0   SdVolume::rootDirStart() const
       0   SdVolume::writeBlock(uint32_t, uint8_t const *)
         0   -> Sd2Card::writeBlock(uint32_t, uint8_t const *)
       0   filepos_t::filepos_t()
      16   print2u(uint8_t)
         0   -> MarlinSerial::print(unsigned char, int)
        16   -> MarlinSerial::write(uint8_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
      16  ?_0
      14  DIR_IS_FILE(dir_t const *)
      14  DIR_IS_FILE_OR_SUBDIR(dir_t const *)
      18  DIR_IS_LONG_NAME(dir_t const *)
      18  DIR_IS_SUBDIR(dir_t const *)
      20  FAT_DATE(uint16_t, uint8_t, uint8_t)
       6  FAT_DAY(uint16_t)
       4  FAT_HOUR(uint16_t)
       8  FAT_MINUTE(uint16_t)
       8  FAT_MONTH(uint16_t)
       8  FAT_SECOND(uint16_t)
      16  FAT_TIME(uint8_t, uint8_t, uint8_t)
      10  FAT_YEAR(uint16_t)
      64  MarlinSerial::print(char const *)
      28  MarlinSerial::write(char const *)
      12  MarlinSerial::write(uint8_t)
       8  SdBaseFile::SdBaseFile()
      20  SdBaseFile::SdBaseFile(char const *, uint8_t)
      44  SdBaseFile::addCluster()
     132  SdBaseFile::addDirCluster()
      44  SdBaseFile::cacheDirEntry(uint8_t)
      14  SdBaseFile::close()
      86  SdBaseFile::contiguousRange(uint32_t *, uint32_t *)
      72  SdBaseFile::createContiguous(SdBaseFile *, char const *, uint32_t)
       4  SdBaseFile::curPosition() const
       4  SdBaseFile::cwd_
       4  SdBaseFile::dateTime_
      42  SdBaseFile::dirEntry(dir_t *)
      54  SdBaseFile::dirName(dir_t const &, char *)
      38  SdBaseFile::exists(char const *)
     120  SdBaseFile::fgets(char *, int16_t, char *)
      66  SdBaseFile::getFilename(char *)
      10  SdBaseFile::getpos(filepos_t *)
      14  SdBaseFile::isDir() const
      14  SdBaseFile::isFile() const
      12  SdBaseFile::isOpen() const
      18  SdBaseFile::isRoot() const
      14  SdBaseFile::isSubDir() const
     108  SdBaseFile::ls(uint8_t, uint8_t)
     274  SdBaseFile::lsPrintNext(uint8_t, uint8_t)
     134  SdBaseFile::make83Name(char const *, uint8_t *, char const **)
     234  SdBaseFile::mkdir(SdBaseFile *, char const *, bool)
     218  SdBaseFile::mkdir(SdBaseFile *, uint8_t const *)
       4  SdBaseFile::oldDateTime_
     218  SdBaseFile::open(SdBaseFile *, char const *, uint8_t)
      90  SdBaseFile::open(SdBaseFile *, uint16_t, uint8_t)
     286  SdBaseFile::open(SdBaseFile *, uint8_t const *, uint8_t)
      10  SdBaseFile::open(char const *, uint8_t)
     164  SdBaseFile::openCachedEntry(uint8_t, uint8_t)
      80  SdBaseFile::openNext(SdBaseFile *, uint8_t)
     284  SdBaseFile::openParent(SdBaseFile *)
     106  SdBaseFile::openRoot(SdVolume *)
      40  SdBaseFile::peek()
     116  SdBaseFile::printDirName(dir_t const &, uint8_t, bool)
      58  SdBaseFile::printFatDate(uint16_t)
      52  SdBaseFile::printFatTime(uint16_t)
      32  SdBaseFile::printName()
      26  SdBaseFile::read()
     240  SdBaseFile::read(void *, uint16_t)
     194  SdBaseFile::readDir(dir_t *, char *)
      52  SdBaseFile::readDirCache()
      46  SdBaseFile::remove()
      56  SdBaseFile::remove(SdBaseFile *, char const *)
     302  SdBaseFile::rename(SdBaseFile *, char const *)
       6  SdBaseFile::rewind()
     188  SdBaseFile::rmRfStar()
      82  SdBaseFile::rmdir()
       8  SdBaseFile::seekEnd(int32_t)
     104  SdBaseFile::seekSet(uint32_t)
      10  SdBaseFile::setpos(filepos_t *)
       4  SdBaseFile::subobject SdBaseFile(char const *, uint8_t)
     106  SdBaseFile::sync()
      88  SdBaseFile::timestamp(SdBaseFile *)
     176  SdBaseFile::timestamp(uint8_t, uint16_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
     160  SdBaseFile::truncate(uint32_t)
       4  SdBaseFile::volume() const
     362  SdBaseFile::write(void const *, uint16_t)
      22  SdBaseFile::~SdBaseFile()
      14  SdVolume::blockOfCluster(uint32_t) const
       8  SdVolume::cache()
      12  SdVolume::cacheBlockNumber()
      20  SdVolume::cacheSetBlockNumber(uint32_t, bool)
      14  SdVolume::clusterStartBlock(uint32_t) const
       8  SdVolume::fatPutEOC(uint32_t)
       6  SdVolume::fatType() const
      40  SdVolume::isEOC(uint32_t) const
      12  SdVolume::readBlock(uint32_t, uint8_t *)
       4  SdVolume::rootDirEntryCount() const
       4  SdVolume::rootDirStart() const
      12  SdVolume::writeBlock(uint32_t, uint8_t const *)
       8  filepos_t::filepos_t()
      32  print2u(uint8_t)

 
    12 bytes in section .bss
 6 052 bytes in section .text
 
 5 662 bytes of CODE memory (+ 390 bytes shared)
    12 bytes of DATA memory

Errors: none
Warnings: 15
