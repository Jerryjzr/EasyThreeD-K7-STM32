###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  21:36:45
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\chessengine.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWED24.tmp
#        (F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\chessengine.c -D
#        USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\chessengine.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\chessengine.o
#
###############################################################################

F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\chessengine.c
      1          /*
      2            chessengine.c
      3            
      4            "Little Rook Chess" (lrc)
      5          
      6            Port to u8g library
      7          
      8            chess for embedded 8-Bit controllers
      9          
     10            Copyright (c) 2012, olikraus@gmail.com
     11            All rights reserved.
     12          
     13            Redistribution and use in source and binary forms, with or without modification, 
     14            are permitted provided that the following conditions are met:
     15          
     16            * Redistributions of source code must retain the above copyright notice, this list 
     17              of conditions and the following disclaimer.
     18              
     19            * Redistributions in binary form must reproduce the above copyright notice, this 
     20              list of conditions and the following disclaimer in the documentation and/or other 
     21              materials provided with the distribution.
     22          
     23            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
     24            CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
     25            INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
     26            MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
     27            DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
     28            CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     29            SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
     30            NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
     31            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
     32            CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     33            STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
     34            ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
     35            ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
     36          
     37            Note:
     38              UNIX_MAIN --> unix console executable
     39          
     40            Current Rule Limitation
     41              - no minor promotion, only "Queening" of the pawn
     42              - threefold repetition is not detected (same board situation appears three times)
     43          	Note: Could be implemented, but requires tracking of the complete game
     44              - Fifty-move rule is not checked (no pawn move, no capture within last 50 moves)
     45          	
     46            Words
     47              Ply		a half move
     48              
     49            General Links
     50              http://chessprogramming.wikispaces.com/
     51          
     52            Arduino specific
     53              http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1260055596
     54              
     55            Prefixes  
     56              chess_		Generic Chess Application Interface
     57              ce_		Chess engine, used internally, these function should not be called directly
     58              cu_		Chess utility function
     59              stack_		Internal function for stack handling
     60          
     61            Issues
     62              10.01.2011
     63                - castling to the right does not move the rook
     64          	  --> done
     65                - castling to the left: King can only move two squares
     66          	  --> done
     67                
     68              11.01.2011	
     69                Next Steps:
     70          	- replace stack_NextCurrentPos with cu_NextPos, cleanup code according to the loop variable
     71          	    --> done
     72          	- Castling: Need to check for fields under attack
     73          	    --> done
     74          	
     75          	- Check for WIN / LOOSE situation, perhaps call ce_Eval() once on the top-level board setup
     76          	    just after the real move
     77          	- cleanup cu_Move
     78          	    --> almost done
     79          	- add some heuristics to the eval procedure
     80          	- add right side menu
     81          	  --> done
     82          	- clean up chess_ManualMove
     83          	  --> done
     84          	- finish menu (consider is_game_end, undo move)
     85                  - end condition: if KING is under attack and if KING can not move to a field which is under attack...
     86          	      then the game is lost. What will be returned by the Eval procedure? is it -INF?
     87          	    --> finished
     88          	    
     89          	- reduce the use of variable color, all should be reduced to board_orientation and ply&1
     90          	
     91          	- chess_GetNextMarked shoud make use of cu_NextPos
     92          	    --> done
     93          	- chess_ManualMove: again cleanup, solve draw issue (KING is not in check and no legal moves are available)
     94          	    --> done
     95              22.01.2011
     96          	- simplify eval_t ce_Eval(void)
     97          	- position eval does not work, still moves side pawn :-(
     98          	      maybe because all pieces are considered
     99          	    --> done
    100          
    101          */
    102          
    103          #include "u8g.h"
    104          
    105          //#ifndef __unix__
    106          //#else
    107          //#include <assert.h>
    108          //#define U8G_NOINLINE
    109          //#endif
    110          
    111          /*
    112          SAN identifies each piece by a single upper case letter.  The standard English
    113          values: pawn = "P", knight = "N", bishop = "B", rook = "R", queen = "Q", and
    114          king = "K".
    115          */
    116          
    117          /* numbers for the various pieces */
    118          #define PIECE_NONE	0
    119          #define PIECE_PAWN 	1
    120          #define PIECE_KNIGHT  	2
    121          #define PIECE_BISHOP 	3
    122          #define PIECE_ROOK	4
    123          #define PIECE_QUEEN 	5
    124          #define PIECE_KING		6
    125          
    126          /* color definitions */
    127          #define COLOR_WHITE	0
    128          #define COLOR_BLACK	1
    129          
    130          /* a mask, which includes COLOR and PIECE number */
    131          #define COLOR_PIECE_MASK 0x01f
    132          
    133          #define CP_MARK_MASK 0x20
    134          
    135          #define ILLEGAL_POSITION 255
    136          
    137          /* This is the build in upper limit of the search stack */
    138          /* This value defines the amount of memory allocated for the search stack */
    139          /* The search depth of this chess engine can never exceed this value */
    140          #define STACK_MAX_SIZE 5
    141          
    142          /* chess half move stack: twice the number of undo's, a user can do */ 
    143          #define CHM_USER_SIZE 6
    144          
    145          /* the CHM_LIST_SIZE must be larger than the maximum search depth */
    146          /* the overall size of ste half move stack */
    147          #define CHM_LIST_SIZE (STACK_MAX_SIZE+CHM_USER_SIZE+2)
    148          
    149          typedef int16_t eval_t;	/* a variable type to store results from the evaluation */ 
    150          //#define EVAL_T_LOST -32768
    151          #define EVAL_T_MIN -32767
    152          #define EVAL_T_MAX 32767
    153          //#define EVAL_T_WIN 32767
    154          
    155          /* for maintainance of our own stack: this is the definition of one element on the stack */
    156          struct _stack_element_struct
    157          {
    158            /* the current source position which is investigated */
    159            uint8_t current_pos;
    160            uint8_t current_cp;
    161            uint8_t current_color;	/* COLOR_WHITE or COLOR_BLACK: must be predefines */
    162            
    163            /* the move which belongs to that value, both values are game positions */
    164            uint8_t best_from_pos;
    165            uint8_t best_to_pos;
    166            /* the best value, which has been dicovered so far */
    167            eval_t best_eval;
    168          };
    169          typedef struct _stack_element_struct stack_element_t;
    170          typedef struct _stack_element_struct *stack_element_p;
    171          
    172          /* chess half move history */
    173          struct _chm_struct
    174          {
    175            uint8_t main_cp;		/* the main piece, which is moved */
    176            uint8_t main_src;		/* the source position of the main piece */
    177            uint8_t main_dest; 	/* the destination of the main piece */
    178            
    179            uint8_t other_cp;		/* another piece: the captured one, the ROOK in case of castling or PIECE_NONE */
    180            uint8_t other_src;		/* the delete position of other_cp. Often identical to main_dest except for e.p. and castling */
    181            uint8_t other_dest;		/* only used for castling: ROOK destination pos */
    182            
    183            /* the position of the last pawn, which did a double move forward */
    184            /* this is required to check en passant conditions */
    185            /* this array can be indexed by the color of the current player */
    186            /* this is the condition BEFORE the move was done */
    187            uint8_t pawn_dbl_move[2];
    188            
    189            /* flags for the movement of rook and king; required for castling */
    190            /* a 1 means: castling is (still) possible */
    191            /* a 0 means: castling not possible */
    192            /*  bit 0 left side white */
    193            /*  bit 1 right side white */
    194            /*  bit 2 left side black */
    195            /*  bit 3 right side black */
    196            /* this is the condition BEFORE the move was done */
    197            uint8_t castling_possible;   
    198          };
    199          
    200          typedef struct _chm_struct chm_t;
    201          typedef struct _chm_struct *chm_p;
    202          
    203          /* little rook chess, main structure */
    204          struct _lrc_struct
    205          {  
    206            /* half-move (ply) counter: Counts the number of half-moves so far. Starts with 0 */
    207            /* the lowest bit is used to derive the color of the current player */
    208            /* will be set to zero in chess_SetupBoard() */
    209            uint8_t ply_count;
    210            
    211            /* the half move stack position counter, counts the number of elements in chm_list */
    212            uint8_t chm_pos;
    213            
    214            /* each element contains a colored piece, empty fields have value 0 */
    215            /* the field with index 0 is black (lower left) */
    216            uint8_t board[64];	
    217            /* the position of the last pawn, which did a double move forward */
    218            /* this is required to check en passant conditions */
    219            /* this array can be indexed by the color of the current player */
    220            uint8_t pawn_dbl_move[2]; 
    221            
    222            /* flags for the movement of rook and king; required for castling */
    223            /* a 1 means: castling is (still) possible */
    224            /* a 0 means: castling not possible */
    225            /*  bit 0 left side white */
    226            /*  bit 1 right side white */
    227            /*  bit 2 left side black */
    228            /*  bit 3 right side black */
    229            uint8_t castling_possible; 
    230            
    231            /* board orientation */
    232            /* 0: white is below COLOR_WHITE */
    233            /* 1: black is below COLOR_BLACK */
    234            /* bascially, this can be used as a color */
    235            uint8_t orientation;
    236            
    237            /* exchange colors of the pieces */
    238            /* 0: white has an empty body, use this for bright background color */
    239            /* 1: black has an empty body, use this for dark backround color */
    240            uint8_t strike_out_color;
    241            
    242            /* 0, when the game is ongoing */
    243            /* 1, when the game is stopped (lost or draw) */
    244            uint8_t is_game_end;
    245            /* the color of the side which lost the game */
    246            /* this value is only valid, when is_game_end is not 0 */
    247            /* values 0 and 1 represent WHITE and BLACK, 2 means a draw */
    248            uint8_t lost_side_color;
    249            
    250            
    251            
    252            /* checks are executed in ce_LoopRecur */
    253            /* these checks will put some marks on the board */
    254            /* this will be used by the interface to find out */
    255            /* legal moves */
    256            uint8_t check_src_pos;
    257            uint8_t check_mode;		/* CHECK_MODE_NONE, CHECK_MODE_MOVEABLE, CHECK_MODE_TARGET_MOVE */
    258            
    259            
    260            /* count of the attacking pieces, indexed by color */
    261            uint8_t find_piece_cnt[2];
    262          
    263            /* sum of the attacking pieces, indexed by color */
    264            uint8_t find_piece_weight[2];
    265          
    266            /* points to the current element of the search stack */
    267            /* this stack is NEVER empty. The value 0 points to the first element of the stack */
    268            /* actually "curr_depth" represent half-moves (plies) */
    269            uint8_t curr_depth;
    270            uint8_t max_depth;
    271            stack_element_p curr_element;
    272            
    273            /* allocated memory for the search stack */
    274            stack_element_t stack_memory[STACK_MAX_SIZE];
    275          
    276            /* the half move stack, used for move undo and depth search, size is stored in chm_pos */
    277            chm_t chm_list[CHM_LIST_SIZE];
    278          };
    279          typedef struct _lrc_struct lrc_t;
    280          
    281          #define CHECK_MODE_NONE 0
    282          #define CHECK_MODE_MOVEABLE 1
    283          #define CHECK_MODE_TARGET_MOVE 2
    284          
    285          
    286          
    287          /*==============================================================*/
    288          /* global variables */
    289          /*==============================================================*/
    290          
    291          u8g_t *lrc_u8g;
    292          

   \                                 In section .bss, align 4
    293          lrc_t lrc_obj;
   \                     lrc_obj:
   \   00000000                      DS8 248
    294          
    295          
    296          /*==============================================================*/
    297          /* forward declarations */
    298          /*==============================================================*/
    299          
    300          /* 
    301            apply no inline to some of the functions:
    302            avr-gcc very often inlines functions, however not inline saves a lot of program memory!
    303            On the other hand there are some really short procedures which should be inlined (like cp_GetColor)
    304            These procedures are marked static to prevent the generation of the expanded procedure, which
    305            also saves space.
    306          */
    307          
    308          uint8_t stack_Push(uint8_t color) U8G_NOINLINE;
    309          void stack_Pop(void) U8G_NOINLINE;
    310          void stack_InitCurrElement(void) U8G_NOINLINE;
    311          void stack_Init(uint8_t max) U8G_NOINLINE;
    312          void stack_SetMove(eval_t val, uint8_t to_pos) U8G_NOINLINE;
    313          uint8_t cu_NextPos(uint8_t pos) U8G_NOINLINE;
    314          static uint8_t cu_gpos2bpos(uint8_t gpos);
    315          static uint8_t cp_Construct(uint8_t color, uint8_t piece);
    316          static uint8_t cp_GetPiece(uint8_t cp);
    317          static uint8_t cp_GetColor(uint8_t cp);
    318          uint8_t cp_GetFromBoard(uint8_t pos) U8G_NOINLINE;
    319          void cp_SetOnBoard(uint8_t pos, uint8_t cp) U8G_NOINLINE;
    320          
    321          void cu_ClearBoard(void) U8G_NOINLINE;
    322          void chess_SetupBoard(void) U8G_NOINLINE;
    323          eval_t ce_Eval(void);
    324          
    325          void cu_ClearMoveHistory(void) U8G_NOINLINE;
    326          void cu_ReduceHistoryByFullMove(void) U8G_NOINLINE;
    327          void cu_UndoHalfMove(void) U8G_NOINLINE;
    328          chm_p cu_PushHalfMove(void) U8G_NOINLINE;
    329          
    330          
    331          void ce_CalculatePositionWeight(uint8_t pos);
    332          uint8_t ce_GetPositionAttackWeight(uint8_t pos, uint8_t color);
    333          
    334          void chess_Thinking(void);
    335          void ce_LoopPieces(void);
    336          
    337          
    338          /*==============================================================*/
    339          /* search stack */
    340          /*==============================================================*/
    341          
    342          /* get current element from stack */

   \                                 In section .text, align 2, keep-with-next
    343          stack_element_p stack_GetCurrElement(void)
    344          {
    345            return lrc_obj.curr_element;
   \                     stack_GetCurrElement: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000004   0x6D40             LDR      R0,[R0, #+84]
   \   00000006   0x4770             BX       LR               ;; return
    346          }
    347          

   \                                 In section .text, align 2, keep-with-next
    348          uint8_t stack_Push(uint8_t color)
    349          {
   \                     stack_Push: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    350            if ( lrc_obj.curr_depth == lrc_obj.max_depth )
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000008   0xF100 0x014F      ADD      R1,R0,#+79
   \   0000000C   0x780A             LDRB     R2,[R1, #+0]
   \   0000000E   0x784B             LDRB     R3,[R1, #+1]
   \   00000010   0x429A             CMP      R2,R3
   \   00000012   0xD101             BNE.N    ??stack_Push_0
    351              return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD10             POP      {R4,PC}
    352            lrc_obj.curr_depth++;
   \                     ??stack_Push_0: (+1)
   \   00000018   0x1C52             ADDS     R2,R2,#+1
   \   0000001A   0x700A             STRB     R2,[R1, #+0]
    353            lrc_obj.curr_element = lrc_obj.stack_memory+lrc_obj.curr_depth;
   \   0000001C   0xB2D2             UXTB     R2,R2
   \   0000001E   0xEB00 0x01C2      ADD      R1,R0,R2, LSL #+3
   \   00000022   0x3158             ADDS     R1,R1,#+88
   \   00000024   0x6541             STR      R1,[R0, #+84]
    354            
    355            /* change view for the evaluation */
    356            color ^= 1;
    357            stack_GetCurrElement()->current_color = color;
   \   00000026   0x.... 0x....      BL       stack_GetCurrElement
   \   0000002A   0xF084 0x0401      EOR      R4,R4,#0x1
   \   0000002E   0x7084             STRB     R4,[R0, #+2]
    358          
    359            return 1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    360          }
    361          

   \                                 In section .text, align 2, keep-with-next
    362          void stack_Pop(void)
    363          {
    364            lrc_obj.curr_depth--;
   \                     stack_Pop: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000004   0xF890 0x104F      LDRB     R1,[R0, #+79]
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \   0000000A   0xF880 0x104F      STRB     R1,[R0, #+79]
    365            lrc_obj.curr_element = lrc_obj.stack_memory+lrc_obj.curr_depth;
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0xEB00 0x01C1      ADD      R1,R0,R1, LSL #+3
   \   00000014   0x3158             ADDS     R1,R1,#+88
   \   00000016   0x6541             STR      R1,[R0, #+84]
    366          }
   \   00000018   0x4770             BX       LR               ;; return
    367          
    368          /* reset the current element on the stack */

   \                                 In section .text, align 2, keep-with-next
    369          void stack_InitCurrElement(void)
    370          {
   \                     stack_InitCurrElement: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    371            stack_element_p e = stack_GetCurrElement();
   \   00000002   0x.... 0x....      BL       stack_GetCurrElement
    372            e->best_eval = EVAL_T_MIN;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable43  ;; 0xffff8001
   \   0000000A   0x80C1             STRH     R1,[R0, #+6]
    373            e->best_from_pos = ILLEGAL_POSITION;
   \   0000000C   0x21FF             MOVS     R1,#+255
   \   0000000E   0x70C1             STRB     R1,[R0, #+3]
    374            e->best_to_pos = ILLEGAL_POSITION;
   \   00000010   0x7101             STRB     R1,[R0, #+4]
    375          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    376          
    377          /* resets the search stack (and the check mode) */

   \                                 In section .text, align 2, keep-with-next
    378          void stack_Init(uint8_t max)
    379          {
   \                     stack_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    380            lrc_obj.curr_depth = 0;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable42
   \   00000006   0xF104 0x014A      ADD      R1,R4,#+74
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x714A             STRB     R2,[R1, #+5]
    381            lrc_obj.curr_element = lrc_obj.stack_memory;
   \   0000000E   0xF104 0x0258      ADD      R2,R4,#+88
   \   00000012   0x6562             STR      R2,[R4, #+84]
    382            lrc_obj.max_depth = max;
   \   00000014   0x7188             STRB     R0,[R1, #+6]
    383            lrc_obj.check_mode = CHECK_MODE_NONE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    384            stack_InitCurrElement();
   \   0000001A   0x.... 0x....      BL       stack_InitCurrElement
    385            stack_GetCurrElement()->current_color = lrc_obj.ply_count;
   \   0000001E   0x.... 0x....      BL       stack_GetCurrElement
   \   00000022   0x7821             LDRB     R1,[R4, #+0]
   \   00000024   0x7081             STRB     R1,[R0, #+2]
    386            stack_GetCurrElement()->current_color &= 1;
   \   00000026   0x.... 0x....      BL       stack_GetCurrElement
   \   0000002A   0x7881             LDRB     R1,[R0, #+2]
   \   0000002C   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000030   0x7081             STRB     R1,[R0, #+2]
    387          }
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    388          
    389          /* assign evaluation value and store the move, if this is the best move */
    390          /* assumes, that current_pos contains the source position */

   \                                 In section .text, align 2, keep-with-next
    391          void stack_SetMove(eval_t val, uint8_t to_pos)
    392          {
   \                     stack_SetMove: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    393            stack_element_p e = stack_GetCurrElement();
   \   00000006   0x.... 0x....      BL       stack_GetCurrElement
    394            if ( e->best_eval < val )
   \   0000000A   0xF9B0 0x1006      LDRSH    R1,[R0, #+6]
   \   0000000E   0x4622             MOV      R2,R4
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xDA03             BGE.N    ??stack_SetMove_0
    395            {
    396              e->best_eval = val;
   \   00000014   0x80C4             STRH     R4,[R0, #+6]
    397              e->best_from_pos = e->current_pos;
   \   00000016   0x7801             LDRB     R1,[R0, #+0]
   \   00000018   0x70C1             STRB     R1,[R0, #+3]
    398              e->best_to_pos = to_pos;
   \   0000001A   0x7105             STRB     R5,[R0, #+4]
    399            }
    400          }
   \                     ??stack_SetMove_0: (+1)
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    401          
    402          /* 
    403            calculate next position on a 0x88 board 
    404            loop is constructed in this way:
    405            i = 0;
    406            do
    407            {
    408              ...
    409              i = cu_NextPos(i);
    410            } while( i != 0 );
    411          
    412            next pos might be started with an illegal position like 255
    413          */

   \                                 In section .text, align 2, keep-with-next
    414          uint8_t cu_NextPos(uint8_t pos)
    415          {
    416            /* calculate next gpos */
    417            pos++;
   \                     cu_NextPos: (+1)
   \   00000000   0x1C40             ADDS     R0,R0,#+1
    418            if ( ( pos & 0x08 ) != 0 )
   \   00000002   0x0701             LSLS     R1,R0,#+28
   \   00000004   0xD502             BPL.N    ??cu_NextPos_0
    419            {
    420              pos+= 0x10;
    421              pos&= 0xf0; 
   \   00000006   0x3010             ADDS     R0,R0,#+16
   \   00000008   0xF000 0x00F0      AND      R0,R0,#0xF0
    422            }
    423            if ( ( pos & 0x80 ) != 0 )
   \                     ??cu_NextPos_0: (+1)
   \   0000000C   0x0601             LSLS     R1,R0,#+24
   \   0000000E   0xD500             BPL.N    ??cu_NextPos_1
    424              pos = 0;
   \   00000010   0x2000             MOVS     R0,#+0
    425            return pos;
   \                     ??cu_NextPos_1: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x4770             BX       LR               ;; return
    426          }
    427          

   \                                 In section .text, align 2, keep-with-next
    428          uint8_t cu_PrevPos(uint8_t pos)
    429          {
    430            /* calculate prev gpos */
    431            pos--;
   \                     cu_PrevPos: (+1)
   \   00000000   0x1E40             SUBS     R0,R0,#+1
    432            if ( ( pos & 0x80 ) != 0 )
   \   00000002   0x0601             LSLS     R1,R0,#+24
   \   00000004   0xD501             BPL.N    ??cu_PrevPos_0
    433              pos = 0x077;
   \   00000006   0x2077             MOVS     R0,#+119
   \   00000008   0xE005             B.N      ??cu_PrevPos_1
    434            else if ( ( pos & 0x08 ) != 0 )
   \                     ??cu_PrevPos_0: (+1)
   \   0000000A   0x0701             LSLS     R1,R0,#+28
   \   0000000C   0xD503             BPL.N    ??cu_PrevPos_1
    435            {
    436              pos &= 0xf0; 
    437              pos |= 0x07;
   \   0000000E   0xF000 0x00F0      AND      R0,R0,#0xF0
   \   00000012   0xF040 0x0007      ORR      R0,R0,#0x7
    438            }
    439            return pos;
   \                     ??cu_PrevPos_1: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0x4770             BX       LR               ;; return
    440          }
    441          
    442          
    443          /*==============================================================*/
    444          /* position transltion */
    445          /*==============================================================*/
    446          /*
    447            there are two positions
    448              1. game position (gpos): BCD encoded x-y values
    449              2. board position (bpos): a number between 0 and 63, only used to access the board.
    450          */
    451          /*
    452            gpos:	game position value
    453            returns:	board position
    454            note:	does not do any checks
    455          */

   \                                 In section .text, align 2, keep-with-next
    456          static uint8_t cu_gpos2bpos(uint8_t gpos)
    457          {
    458            uint8_t bpos = gpos;
    459            bpos &= 0xf0;
    460            bpos >>= 1;
    461            gpos &= 0x0f;
    462            bpos |= gpos;
    463            return bpos;
   \                     cu_gpos2bpos: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x0849             LSRS     R1,R1,#+1
   \   00000004   0xF001 0x0178      AND      R1,R1,#0x78
   \   00000008   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000C   0x4308             ORRS     R0,R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    464          }
    465          
    466          #define gpos_IsIllegal(gpos) ((gpos) & 0x088)
    467          
    468          
    469          /*==============================================================*/
    470          /* colored piece handling */
    471          /*==============================================================*/
    472          
    473          #define cp_IsMarked(cp)  ((cp) & CP_MARK_MASK)
    474          
    475          
    476          /*
    477            piece: one of PIECE_xxx
    478            color: COLOR_WHITE or COLOR_BLACK
    479          
    480            returns: A colored piece
    481          */

   \                                 In section .text, align 2, keep-with-next
    482          static uint8_t cp_Construct(uint8_t color, uint8_t piece)
    483          {
    484            color <<= 4;
    485            color |= piece;
    486            return color;
   \                     cp_Construct: (+1)
   \   00000000   0xEA41 0x1100      ORR      R1,R1,R0, LSL #+4
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x4770             BX       LR               ;; return
    487          }
    488          
    489          /* inline is better than a macro */

   \                                 In section .text, align 2, keep-with-next
    490          static uint8_t cp_GetPiece(uint8_t cp)
    491          {
    492            cp &= 0x0f;
    493            return cp;
   \                     cp_GetPiece: (+1)
   \   00000000   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000004   0x4770             BX       LR               ;; return
    494          }
    495          
    496          /*
    497            we could use a macro:
    498            #define cp_GetColor(cp)	(((cp) >> 4)&1)
    499            however, inlined functions are sometimes much better
    500          */

   \                                 In section .text, align 2, keep-with-next
    501          static uint8_t cp_GetColor(uint8_t cp)
    502          {
    503            cp >>= 4;
    504            cp &= 1;
    505            return cp;
   \                     cp_GetColor: (+1)
   \   00000000   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \   00000004   0x4770             BX       LR               ;; return
    506          }
    507          
    508          /*
    509            pos: game position
    510            returns the colored piece at the given position
    511          */

   \                                 In section .text, align 2, keep-with-next
    512          uint8_t cp_GetFromBoard(uint8_t pos)
    513          {
   \                     cp_GetFromBoard: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    514            return lrc_obj.board[cu_gpos2bpos(pos)];
   \   00000002   0x.... 0x....      BL       cu_gpos2bpos
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable42
   \   0000000A   0x4408             ADD      R0,R1,R0
   \   0000000C   0x7880             LDRB     R0,[R0, #+2]
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    515          }
    516          
    517          /*
    518            pos: game position
    519            cp: colored piece
    520          */

   \                                 In section .text, align 2, keep-with-next
    521          void cp_SetOnBoard(uint8_t pos, uint8_t cp)
    522          {
   \                     cp_SetOnBoard: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    523            /*printf("cp_SetOnBoard gpos:%02x cp:%02x\n", pos, cp);*/
    524            lrc_obj.board[cu_gpos2bpos(pos)] = cp;
   \   00000004   0x.... 0x....      BL       cu_gpos2bpos
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable42
   \   0000000C   0x4408             ADD      R0,R1,R0
   \   0000000E   0x7084             STRB     R4,[R0, #+2]
    525          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    526          
    527          /*==============================================================*/
    528          /* global board access */
    529          /*==============================================================*/
    530          

   \                                 In section .text, align 2, keep-with-next
    531          void cu_ClearBoard(void)
    532          {
    533            uint8_t i;
    534            /* clear the board */
    535            for( i = 0; i < 64; i++ )
   \                     cu_ClearBoard: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable42
   \   00000006   0x4603             MOV      R3,R0
   \   00000008   0xE002             B.N      ??cu_ClearBoard_0
    536              lrc_obj.board[i] = PIECE_NONE;
   \                     ??cu_ClearBoard_1: (+1)
   \   0000000A   0x4411             ADD      R1,R2,R1
   \   0000000C   0x708B             STRB     R3,[R1, #+2]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \                     ??cu_ClearBoard_0: (+1)
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0xB2C9             UXTB     R1,R1
   \   00000014   0x2940             CMP      R1,#+64
   \   00000016   0xDBF8             BLT.N    ??cu_ClearBoard_1
    537            
    538            lrc_obj.ply_count = 0;
   \   00000018   0x4618             MOV      R0,R3
   \   0000001A   0x7010             STRB     R0,[R2, #+0]
    539            lrc_obj.orientation = COLOR_WHITE;
   \   0000001C   0xF102 0x0042      ADD      R0,R2,#+66
   \   00000020   0x4619             MOV      R1,R3
   \   00000022   0x70C1             STRB     R1,[R0, #+3]
    540            
    541            lrc_obj.pawn_dbl_move[0] = ILLEGAL_POSITION;
   \   00000024   0x21FF             MOVS     R1,#+255
   \   00000026   0x7001             STRB     R1,[R0, #+0]
    542            lrc_obj.pawn_dbl_move[1] = ILLEGAL_POSITION;
   \   00000028   0x7041             STRB     R1,[R0, #+1]
    543            
    544            lrc_obj.castling_possible = 0x0f;
   \   0000002A   0x210F             MOVS     R1,#+15
   \   0000002C   0x7081             STRB     R1,[R0, #+2]
    545            
    546            lrc_obj.is_game_end = 0;
   \   0000002E   0x4619             MOV      R1,R3
   \   00000030   0x7141             STRB     R1,[R0, #+5]
    547            lrc_obj.lost_side_color = 0;
   \   00000032   0x7181             STRB     R1,[R0, #+6]
    548          
    549            /* clear half move history */
    550            cu_ClearMoveHistory();
   \   00000034   0x....             B.N      cu_ClearMoveHistory
    551          
    552          }
    553          
    554          /*
    555            test setup
    556            white wins in one move
    557          */

   \                                 In section .text, align 2, keep-with-next
    558          void chess_SetupBoardTest01(void)
    559          {
   \                     chess_SetupBoardTest01: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    560            cu_ClearBoard();
   \   00000002   0x.... 0x....      BL       cu_ClearBoard
    561            lrc_obj.board[7+7*8] = cp_Construct(COLOR_BLACK, PIECE_KING);
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable42
   \   0000000A   0xF104 0x0531      ADD      R5,R4,#+49
   \   0000000E   0x2106             MOVS     R1,#+6
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       cp_Construct
   \   00000016   0x7428             STRB     R0,[R5, #+16]
    562            lrc_obj.board[7+5*8] = cp_Construct(COLOR_WHITE, PIECE_PAWN);
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       cp_Construct
   \   00000020   0x7028             STRB     R0,[R5, #+0]
    563            lrc_obj.board[3] = cp_Construct(COLOR_WHITE, PIECE_KING);
   \   00000022   0x2106             MOVS     R1,#+6
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       cp_Construct
   \   0000002A   0x7160             STRB     R0,[R4, #+5]
    564            lrc_obj.board[0+7*8] = cp_Construct(COLOR_BLACK, PIECE_ROOK);
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       cp_Construct
   \   00000034   0x7268             STRB     R0,[R5, #+9]
    565            lrc_obj.board[6] = cp_Construct(COLOR_WHITE, PIECE_QUEEN);
   \   00000036   0x2105             MOVS     R1,#+5
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       cp_Construct
   \   0000003E   0x7220             STRB     R0,[R4, #+8]
    566          } 
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    567          
    568          /* setup the global board */

   \                                 In section .text, align 2, keep-with-next
    569          void chess_SetupBoard(void)
    570          {
   \                     chess_SetupBoard: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    571            uint8_t i;
    572            register uint8_t bp, wp;
    573            
    574            /* clear the board */
    575            cu_ClearBoard();
   \   00000002   0x.... 0x....      BL       cu_ClearBoard
    576            
    577            /* precronstruct pawns */
    578            wp = cp_Construct(COLOR_WHITE, PIECE_PAWN);
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       cp_Construct
   \   0000000E   0x4604             MOV      R4,R0
    579            bp = cp_Construct(COLOR_BLACK, PIECE_PAWN);
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0x.... 0x....      BL       cp_Construct
    580            
    581            /* setup pawn */
    582            for( i = 0; i < 8; i++ )
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable42
   \   0000001E   0xE004             B.N      ??chess_SetupBoard_0
    583            {
    584              lrc_obj.board[i+8] = wp;
   \                     ??chess_SetupBoard_1: (+1)
   \   00000020   0x186A             ADDS     R2,R5,R1
   \   00000022   0x7294             STRB     R4,[R2, #+10]
    585              lrc_obj.board[i+6*8] = bp;
   \   00000024   0xF882 0x0032      STRB     R0,[R2, #+50]
    586            }
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \                     ??chess_SetupBoard_0: (+1)
   \   0000002A   0x2907             CMP      R1,#+7
   \   0000002C   0xDDF8             BLE.N    ??chess_SetupBoard_1
    587            
    588            /* assign remaining pieces */
    589            
    590            lrc_obj.board[0] = cp_Construct(COLOR_WHITE, PIECE_ROOK);
   \   0000002E   0x2104             MOVS     R1,#+4
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       cp_Construct
   \   00000036   0x70A8             STRB     R0,[R5, #+2]
    591            lrc_obj.board[1] = cp_Construct(COLOR_WHITE, PIECE_KNIGHT);
   \   00000038   0x2102             MOVS     R1,#+2
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      BL       cp_Construct
   \   00000040   0x70E8             STRB     R0,[R5, #+3]
    592            lrc_obj.board[2] = cp_Construct(COLOR_WHITE, PIECE_BISHOP);
   \   00000042   0x2103             MOVS     R1,#+3
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      BL       cp_Construct
   \   0000004A   0x7128             STRB     R0,[R5, #+4]
    593            lrc_obj.board[3] = cp_Construct(COLOR_WHITE, PIECE_QUEEN);
   \   0000004C   0x2105             MOVS     R1,#+5
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x.... 0x....      BL       cp_Construct
   \   00000054   0x7168             STRB     R0,[R5, #+5]
    594            lrc_obj.board[4] = cp_Construct(COLOR_WHITE, PIECE_KING);
   \   00000056   0x2106             MOVS     R1,#+6
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       cp_Construct
   \   0000005E   0x71A8             STRB     R0,[R5, #+6]
    595            lrc_obj.board[5] = cp_Construct(COLOR_WHITE, PIECE_BISHOP);
   \   00000060   0x2103             MOVS     R1,#+3
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      BL       cp_Construct
   \   00000068   0x71E8             STRB     R0,[R5, #+7]
    596            lrc_obj.board[6] = cp_Construct(COLOR_WHITE, PIECE_KNIGHT);
   \   0000006A   0x2102             MOVS     R1,#+2
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      BL       cp_Construct
   \   00000072   0x7228             STRB     R0,[R5, #+8]
    597            lrc_obj.board[7] = cp_Construct(COLOR_WHITE, PIECE_ROOK);
   \   00000074   0x2104             MOVS     R1,#+4
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x.... 0x....      BL       cp_Construct
   \   0000007C   0x7268             STRB     R0,[R5, #+9]
    598          
    599            lrc_obj.board[0+7*8] = cp_Construct(COLOR_BLACK, PIECE_ROOK);
   \   0000007E   0xF105 0x043A      ADD      R4,R5,#+58
   \   00000082   0x2104             MOVS     R1,#+4
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      BL       cp_Construct
   \   0000008A   0x7020             STRB     R0,[R4, #+0]
    600            lrc_obj.board[1+7*8] = cp_Construct(COLOR_BLACK, PIECE_KNIGHT);
   \   0000008C   0x2102             MOVS     R1,#+2
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x.... 0x....      BL       cp_Construct
   \   00000094   0x7060             STRB     R0,[R4, #+1]
    601            lrc_obj.board[2+7*8] = cp_Construct(COLOR_BLACK, PIECE_BISHOP);
   \   00000096   0x2103             MOVS     R1,#+3
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x.... 0x....      BL       cp_Construct
   \   0000009E   0x70A0             STRB     R0,[R4, #+2]
    602            lrc_obj.board[3+7*8] = cp_Construct(COLOR_BLACK, PIECE_QUEEN);
   \   000000A0   0x2105             MOVS     R1,#+5
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x.... 0x....      BL       cp_Construct
   \   000000A8   0x70E0             STRB     R0,[R4, #+3]
    603            lrc_obj.board[4+7*8] = cp_Construct(COLOR_BLACK, PIECE_KING);
   \   000000AA   0x2106             MOVS     R1,#+6
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x.... 0x....      BL       cp_Construct
   \   000000B2   0x7120             STRB     R0,[R4, #+4]
    604            lrc_obj.board[5+7*8] = cp_Construct(COLOR_BLACK, PIECE_BISHOP);
   \   000000B4   0x2103             MOVS     R1,#+3
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x.... 0x....      BL       cp_Construct
   \   000000BC   0x7160             STRB     R0,[R4, #+5]
    605            lrc_obj.board[6+7*8] = cp_Construct(COLOR_BLACK, PIECE_KNIGHT);
   \   000000BE   0x2102             MOVS     R1,#+2
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x.... 0x....      BL       cp_Construct
   \   000000C6   0x71A0             STRB     R0,[R4, #+6]
    606            lrc_obj.board[7+7*8] = cp_Construct(COLOR_BLACK, PIECE_ROOK);
   \   000000C8   0x2104             MOVS     R1,#+4
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x.... 0x....      BL       cp_Construct
   \   000000D0   0x71E0             STRB     R0,[R4, #+7]
    607          
    608            //chess_SetupBoardTest01();
    609          
    610          }
   \   000000D2   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    611          
    612          
    613          
    614          /*==============================================================*/
    615          /* checks */
    616          /*==============================================================*/
    617          
    618          /*
    619            checks if the position is somehow illegal
    620          */

   \                                 In section .text, align 2, keep-with-next
    621          uint8_t cu_IsIllegalPosition(uint8_t pos, uint8_t my_color)
    622          {
   \                     cu_IsIllegalPosition: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    623            uint8_t board_cp;
    624            /* check, if the position is offboard */
    625            if ( gpos_IsIllegal(pos) != 0 )
   \   00000004   0xF010 0x0F88      TST      R0,#0x88
   \   00000008   0xD107             BNE.N    ??cu_IsIllegalPosition_0
    626              return 1;
    627            /* get the piece from the board */
    628            board_cp = cp_GetFromBoard(pos);
   \   0000000A   0x.... 0x....      BL       cp_GetFromBoard
    629            /* check if hit our own pieces */
    630            if ( board_cp != 0 ) 
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0xD005             BEQ.N    ??cu_IsIllegalPosition_1
    631              if ( cp_GetColor(board_cp) == my_color )
   \   00000012   0x.... 0x....      BL       cp_GetColor
   \   00000016   0x42A0             CMP      R0,R4
   \   00000018   0xD101             BNE.N    ??cu_IsIllegalPosition_1
    632                return 1;
   \                     ??cu_IsIllegalPosition_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD10             POP      {R4,PC}
    633            /* all ok, we could go to this position */
    634            return 0;
   \                     ??cu_IsIllegalPosition_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    635          }
    636          
    637          /*==============================================================*/
    638          /* evaluation procedure */
    639          /*==============================================================*/
    640          
    641          /*
    642            basic idea is to return a value between EVAL_T_MIN and EVAL_T_MAX
    643          */
    644          
    645          /*
    646            the weight table uses the PIECE number as index:
    647                #define PIECE_NONE	0
    648                #define PIECE_PAWN 	1
    649                #define PIECE_KNIGHT  	2
    650                #define PIECE_BISHOP 	3
    651                #define PIECE_ROOK	4
    652                #define PIECE_QUEEN 	5
    653                #define PIECE_KING		6
    654            the king itself is not counted
    655          */
    656          uint8_t ce_piece_weight[] = { 0, 1, 3, 3, 5, 9, 0 };
    657          uint8_t ce_pos_weight[] = { 0, 1, 1, 2, 2, 1, 1, 0};
    658          /*
    659            evaluate the current situation on the global board
    660          */

   \                                 In section .text, align 2, keep-with-next
    661          eval_t ce_Eval(void)
    662          {
   \                     ce_Eval: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    663            uint8_t cp;
    664            uint8_t is_my_king_present = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    665            uint8_t is_opposit_king_present = 0;
   \   00000006   0x4607             MOV      R7,R0
    666            eval_t material_my_color = 0;
   \   00000008   0x4680             MOV      R8,R0
    667            eval_t material_opposit_color = 0;
   \   0000000A   0x4681             MOV      R9,R0
    668            eval_t position_my_color = 0;
   \   0000000C   0x4605             MOV      R5,R0
    669            eval_t position_opposit_color = 0;
   \   0000000E   0x4606             MOV      R6,R0
    670            eval_t result;
    671            uint8_t pos;
    672            
    673            pos = 0;
   \   00000010   0x4604             MOV      R4,R0
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
    674            do
    675            {
    676              /* get colored piece from the board */
    677              cp = cp_GetFromBoard(pos);
   \                     ??ce_Eval_0: (+1)
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       cp_GetFromBoard
   \   0000001C   0x4682             MOV      R10,R0
    678              
    679              if ( cp_GetPiece(cp) != PIECE_NONE )
   \   0000001E   0x.... 0x....      BL       cp_GetPiece
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD057             BEQ.N    ??ce_Eval_1
    680              {
    681                if ( stack_GetCurrElement()->current_color == cp_GetColor(cp) )
   \   00000026   0x.... 0x....      BL       stack_GetCurrElement
   \   0000002A   0x4683             MOV      R11,R0
   \   0000002C   0x4650             MOV      R0,R10
   \   0000002E   0x.... 0x....      BL       cp_GetColor
   \   00000032   0xF89B 0x1002      LDRB     R1,[R11, #+2]
   \   00000036   0x4281             CMP      R1,R0
   \   00000038   0x4650             MOV      R0,R10
   \   0000003A   0xD127             BNE.N    ??ce_Eval_2
    682                {
    683          	/* this is our color */
    684          	/* check if we found our king */
    685          	if ( cp_GetPiece(cp) == PIECE_KING  )
   \   0000003C   0x.... 0x....      BL       cp_GetPiece
   \   00000040   0x2806             CMP      R0,#+6
   \   00000042   0xD102             BNE.N    ??ce_Eval_3
    686          	  is_my_king_present = 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
    687          	material_my_color += ce_piece_weight[cp_GetPiece(cp)];
   \                     ??ce_Eval_3: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R11,??DataTable48
   \   0000004E   0x4650             MOV      R0,R10
   \   00000050   0x.... 0x....      BL       cp_GetPiece
   \   00000054   0xF81B 0x0000      LDRB     R0,[R11, R0]
   \   00000058   0x4480             ADD      R8,R0,R8
    688          	if ( cp_GetPiece(cp) == PIECE_PAWN || cp_GetPiece(cp) == PIECE_KNIGHT  )
   \   0000005A   0x4650             MOV      R0,R10
   \   0000005C   0x.... 0x....      BL       cp_GetPiece
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD004             BEQ.N    ??ce_Eval_4
   \   00000064   0x4650             MOV      R0,R10
   \   00000066   0x.... 0x....      BL       cp_GetPiece
   \   0000006A   0x2802             CMP      R0,#+2
   \   0000006C   0xD133             BNE.N    ??ce_Eval_1
    689          	{
    690          	  position_my_color += ce_pos_weight[pos&7]*ce_pos_weight[(pos>>4)&7];
   \                     ??ce_Eval_4: (+1)
   \   0000006E   0xF10B 0x0008      ADD      R0,R11,#+8
   \   00000072   0xF004 0x0107      AND      R1,R4,#0x7
   \   00000076   0x5C40             LDRB     R0,[R0, R1]
   \   00000078   0xF10B 0x0108      ADD      R1,R11,#+8
   \   0000007C   0x4622             MOV      R2,R4
   \   0000007E   0x1112             ASRS     R2,R2,#+4
   \   00000080   0xF002 0x0207      AND      R2,R2,#0x7
   \   00000084   0x5C89             LDRB     R1,[R1, R2]
   \   00000086   0xFB01 0x5500      MLA      R5,R1,R0,R5
   \   0000008A   0xE024             B.N      ??ce_Eval_1
    691          	}
    692                }
    693                else
    694                {
    695          	/* this is the opposit color */
    696          	if ( cp_GetPiece(cp) == PIECE_KING  )
   \                     ??ce_Eval_2: (+1)
   \   0000008C   0x.... 0x....      BL       cp_GetPiece
   \   00000090   0x2806             CMP      R0,#+6
   \   00000092   0xD100             BNE.N    ??ce_Eval_5
    697          	  is_opposit_king_present = 1;
   \   00000094   0x2701             MOVS     R7,#+1
    698          	material_opposit_color += ce_piece_weight[cp_GetPiece(cp)];
   \                     ??ce_Eval_5: (+1)
   \   00000096   0x.... 0x....      LDR.W    R11,??DataTable48
   \   0000009A   0x4650             MOV      R0,R10
   \   0000009C   0x.... 0x....      BL       cp_GetPiece
   \   000000A0   0xF81B 0x0000      LDRB     R0,[R11, R0]
   \   000000A4   0x4481             ADD      R9,R0,R9
    699          	if ( cp_GetPiece(cp) == PIECE_PAWN || cp_GetPiece(cp) == PIECE_KNIGHT )
   \   000000A6   0x4650             MOV      R0,R10
   \   000000A8   0x.... 0x....      BL       cp_GetPiece
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD004             BEQ.N    ??ce_Eval_6
   \   000000B0   0x4650             MOV      R0,R10
   \   000000B2   0x.... 0x....      BL       cp_GetPiece
   \   000000B6   0x2802             CMP      R0,#+2
   \   000000B8   0xD10D             BNE.N    ??ce_Eval_1
    700          	{
    701          	  position_opposit_color += ce_pos_weight[pos&7]*ce_pos_weight[(pos>>4)&7];
   \                     ??ce_Eval_6: (+1)
   \   000000BA   0xF10B 0x0008      ADD      R0,R11,#+8
   \   000000BE   0xF004 0x0107      AND      R1,R4,#0x7
   \   000000C2   0x5C40             LDRB     R0,[R0, R1]
   \   000000C4   0xF10B 0x0108      ADD      R1,R11,#+8
   \   000000C8   0x4622             MOV      R2,R4
   \   000000CA   0x1112             ASRS     R2,R2,#+4
   \   000000CC   0xF002 0x0207      AND      R2,R2,#0x7
   \   000000D0   0x5C89             LDRB     R1,[R1, R2]
   \   000000D2   0xFB01 0x6600      MLA      R6,R1,R0,R6
    702          	}
    703                }
    704              }
    705              pos = cu_NextPos(pos);
   \                     ??ce_Eval_1: (+1)
   \   000000D6   0x4620             MOV      R0,R4
   \   000000D8   0x.... 0x....      BL       cu_NextPos
   \   000000DC   0x0004             MOVS     R4,R0
    706            } while( pos != 0 );
   \   000000DE   0xD19A             BNE.N    ??ce_Eval_0
   \   000000E0   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000E4   0x4628             MOV      R0,R5
    707          
    708              
    709            /* decide if we lost or won the game */
    710            if ( is_my_king_present == 0 )
   \   000000E6   0x2900             CMP      R1,#+0
   \   000000E8   0xD102             BNE.N    ??ce_Eval_7
    711              return EVAL_T_MIN;	/*_LOST*/
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0xffff8001
   \   000000EE   0xE00A             B.N      ??ce_Eval_8
    712            if ( is_opposit_king_present == 0 )
   \                     ??ce_Eval_7: (+1)
   \   000000F0   0x2F00             CMP      R7,#+0
   \   000000F2   0xD102             BNE.N    ??ce_Eval_9
    713              return EVAL_T_MAX;	/*_WIN*/
   \   000000F4   0xF647 0x70FF      MOVW     R0,#+32767
   \   000000F8   0xE005             B.N      ??ce_Eval_8
    714            
    715            /* here is the evaluation function */
    716            
    717            result = material_my_color - material_opposit_color;
    718            result <<= 3;
    719            result += position_my_color - position_opposit_color;
    720            return result;
   \                     ??ce_Eval_9: (+1)
   \   000000FA   0xEBA8 0x0809      SUB      R8,R8,R9
   \   000000FE   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \   00000102   0x1B80             SUBS     R0,R0,R6
   \   00000104   0xB200             SXTH     R0,R0
   \                     ??ce_Eval_8: (+1)
   \   00000106   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    721          }
    722          
    723          /*==============================================================*/
    724          /* move backup and restore */
    725          /*==============================================================*/
    726          
    727          
    728          /* this procedure must be called to keep the size as low as possible */
    729          /* if the chm_list is large enough, it could hold the complete history */
    730          /* but for an embedded controler... it is deleted for every engine search */

   \                                 In section .text, align 2, keep-with-next
    731          void cu_ClearMoveHistory(void)
    732          {
    733            lrc_obj.chm_pos = 0;
   \                     cu_ClearMoveHistory: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable42
   \   00000006   0x7048             STRB     R0,[R1, #+1]
    734          }
   \   00000008   0x4770             BX       LR               ;; return
    735          

   \                                 In section .text, align 2, keep-with-next
    736          void cu_ReduceHistoryByFullMove(void)
    737          {
   \                     cu_ReduceHistoryByFullMove: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable42
   \   00000006   0xE011             B.N      ??cu_ReduceHistoryByFullMove_0
    738            uint8_t i;
    739            while( lrc_obj.chm_pos > CHM_USER_SIZE )
    740            {
    741              i = 0;
    742              for(;;)
    743              {
    744                if ( i+2 >= lrc_obj.chm_pos )
    745          	break;
    746                lrc_obj.chm_list[i] = lrc_obj.chm_list[i+2];
   \                     ??cu_ReduceHistoryByFullMove_1: (+1)
   \   00000008   0xEB05 0x00C5      ADD      R0,R5,R5, LSL #+3
   \   0000000C   0x1821             ADDS     R1,R4,R0
   \   0000000E   0xF101 0x0080      ADD      R0,R1,#+128
   \   00000012   0x3192             ADDS     R1,R1,#+146
   \   00000014   0x2209             MOVS     R2,#+9
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
    747                i++;
   \   0000001A   0x1C6D             ADDS     R5,R5,#+1
   \   0000001C   0xB2ED             UXTB     R5,R5
   \                     ??cu_ReduceHistoryByFullMove_2: (+1)
   \   0000001E   0x7860             LDRB     R0,[R4, #+1]
   \   00000020   0x1CA9             ADDS     R1,R5,#+2
   \   00000022   0x4602             MOV      R2,R0
   \   00000024   0x4291             CMP      R1,R2
   \   00000026   0xDBEF             BLT.N    ??cu_ReduceHistoryByFullMove_1
    748              }
    749              lrc_obj.chm_pos -= 2;
   \   00000028   0x1E80             SUBS     R0,R0,#+2
   \   0000002A   0x7060             STRB     R0,[R4, #+1]
   \                     ??cu_ReduceHistoryByFullMove_0: (+1)
   \   0000002C   0x7860             LDRB     R0,[R4, #+1]
   \   0000002E   0x2807             CMP      R0,#+7
   \   00000030   0xDB01             BLT.N    ??cu_ReduceHistoryByFullMove_3
   \   00000032   0x2500             MOVS     R5,#+0
   \   00000034   0xE7F3             B.N      ??cu_ReduceHistoryByFullMove_2
    750            }
    751          }
   \                     ??cu_ReduceHistoryByFullMove_3: (+1)
   \   00000036   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    752          

   \                                 In section .text, align 2, keep-with-next
    753          void cu_UndoHalfMove(void)
    754          {
   \                     cu_UndoHalfMove: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable42
   \   00000004   0x7848             LDRB     R0,[R1, #+1]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD100             BNE.N    ??cu_UndoHalfMove_0
   \   0000000A   0x4770             BX       LR
   \                     ??cu_UndoHalfMove_0: (+1)
   \   0000000C   0xB510             PUSH     {R4,LR}
    755            chm_p chm;
    756            
    757            if ( lrc_obj.chm_pos == 0 )
    758              return;
    759            
    760            lrc_obj.chm_pos--;
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x7048             STRB     R0,[R1, #+1]
    761          
    762            chm = lrc_obj.chm_list+lrc_obj.chm_pos;
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0xEB00 0x00C0      ADD      R0,R0,R0, LSL #+3
   \   00000018   0x4408             ADD      R0,R1,R0
   \   0000001A   0xF100 0x0480      ADD      R4,R0,#+128
    763            
    764            lrc_obj.pawn_dbl_move[0] = chm->pawn_dbl_move[0];
   \   0000001E   0xF101 0x0042      ADD      R0,R1,#+66
   \   00000022   0x79A1             LDRB     R1,[R4, #+6]
   \   00000024   0x7001             STRB     R1,[R0, #+0]
    765            lrc_obj.pawn_dbl_move[1] = chm->pawn_dbl_move[1];
   \   00000026   0x79E1             LDRB     R1,[R4, #+7]
   \   00000028   0x7041             STRB     R1,[R0, #+1]
    766            lrc_obj.castling_possible = chm->castling_possible;
   \   0000002A   0x7A21             LDRB     R1,[R4, #+8]
   \   0000002C   0x7081             STRB     R1,[R0, #+2]
    767            
    768            cp_SetOnBoard(chm->main_src, chm->main_cp);
   \   0000002E   0x7821             LDRB     R1,[R4, #+0]
   \   00000030   0x7860             LDRB     R0,[R4, #+1]
   \   00000032   0x.... 0x....      BL       cp_SetOnBoard
    769            cp_SetOnBoard(chm->main_dest, PIECE_NONE);
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x78A0             LDRB     R0,[R4, #+2]
   \   0000003A   0x.... 0x....      BL       cp_SetOnBoard
    770            
    771            if ( chm->other_src != ILLEGAL_POSITION )
   \   0000003E   0x7920             LDRB     R0,[R4, #+4]
   \   00000040   0x4601             MOV      R1,R0
   \   00000042   0x29FF             CMP      R1,#+255
   \   00000044   0xD002             BEQ.N    ??cu_UndoHalfMove_1
    772              cp_SetOnBoard(chm->other_src, chm->other_cp);
   \   00000046   0x78E1             LDRB     R1,[R4, #+3]
   \   00000048   0x.... 0x....      BL       cp_SetOnBoard
    773            if ( chm->other_dest != ILLEGAL_POSITION )
   \                     ??cu_UndoHalfMove_1: (+1)
   \   0000004C   0x7960             LDRB     R0,[R4, #+5]
   \   0000004E   0x4601             MOV      R1,R0
   \   00000050   0x29FF             CMP      R1,#+255
   \   00000052   0xD003             BEQ.N    ??cu_UndoHalfMove_2
    774              cp_SetOnBoard(chm->other_dest, PIECE_NONE);
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xE8BD 0x4010      POP      {R4,LR}
   \   0000005A   0x....             B.N      cp_SetOnBoard
    775          
    776          }
   \                     ??cu_UndoHalfMove_2: (+1)
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    777          
    778          /*
    779            assumes, that the following members of the returned chm structure are filled 
    780            uint8_t main_cp;		the main piece, which is moved
    781            uint8_t main_src;		the source position of the main piece
    782            uint8_t main_dest; 	the destination of the main piece
    783            
    784            uint8_t other_cp;		another piece: the captured one, the ROOK in case of castling or PIECE_NONE
    785            uint8_t other_src;		the delete position of other_cp. Often identical to main_dest except for e.p. and castling
    786            uint8_t other_dest;		only used for castling: ROOK destination pos
    787          
    788          */

   \                                 In section .text, align 2, keep-with-next
    789          chm_p cu_PushHalfMove(void)
    790          {
    791            chm_p chm;
    792            
    793            chm = lrc_obj.chm_list+lrc_obj.chm_pos;
   \                     cu_PushHalfMove: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable42
   \   00000004   0x784A             LDRB     R2,[R1, #+1]
   \   00000006   0x4613             MOV      R3,R2
   \   00000008   0xEB03 0x00C3      ADD      R0,R3,R3, LSL #+3
   \   0000000C   0x4408             ADD      R0,R1,R0
   \   0000000E   0x3080             ADDS     R0,R0,#+128
    794            if ( lrc_obj.chm_pos < CHM_LIST_SIZE-1)
   \   00000010   0x2B0C             CMP      R3,#+12
   \   00000012   0xDA01             BGE.N    ??cu_PushHalfMove_0
    795              lrc_obj.chm_pos++;
   \   00000014   0x1C52             ADDS     R2,R2,#+1
   \   00000016   0x704A             STRB     R2,[R1, #+1]
    796          
    797            chm->pawn_dbl_move[0] = lrc_obj.pawn_dbl_move[0];
   \                     ??cu_PushHalfMove_0: (+1)
   \   00000018   0x3142             ADDS     R1,R1,#+66
   \   0000001A   0x780A             LDRB     R2,[R1, #+0]
   \   0000001C   0x7182             STRB     R2,[R0, #+6]
    798            chm->pawn_dbl_move[1] = lrc_obj.pawn_dbl_move[1];
   \   0000001E   0x784A             LDRB     R2,[R1, #+1]
   \   00000020   0x71C2             STRB     R2,[R0, #+7]
    799            chm->castling_possible = lrc_obj.castling_possible;
   \   00000022   0x7889             LDRB     R1,[R1, #+2]
   \   00000024   0x7201             STRB     R1,[R0, #+8]
    800            return chm;
   \   00000026   0x4770             BX       LR               ;; return
    801          }
    802          
    803          
    804          char chess_piece_to_char[] = "NBRQK";
    805          
    806          /*
    807            simple moves on empty field: 	Ka1-b2
    808            capture moves:				Ka1xb2
    809            castling:						0-0 or 0-0-0
    810          */
    811          
    812          static void cu_add_pos(char *s, uint8_t pos) U8G_NOINLINE;
    813          

   \                                 In section .text, align 2, keep-with-next
    814          static void cu_add_pos(char *s, uint8_t pos)
    815          {
    816            *s = pos;
   \                     cu_add_pos: (+1)
   \   00000000   0x7001             STRB     R1,[R0, #+0]
    817            *s >>= 4;
   \   00000002   0xF990 0x2000      LDRSB    R2,[R0, #+0]
   \   00000006   0x4613             MOV      R3,R2
   \   00000008   0x111B             ASRS     R3,R3,#+4
   \   0000000A   0x7003             STRB     R3,[R0, #+0]
    818            *s += 'a';
   \   0000000C   0x3361             ADDS     R3,R3,#+97
   \   0000000E   0x7003             STRB     R3,[R0, #+0]
    819            s++;
    820            *s = pos;
   \   00000010   0x7041             STRB     R1,[R0, #+1]
    821            *s &= 15;
   \   00000012   0xF002 0x020F      AND      R2,R2,#0xF
   \   00000016   0x7042             STRB     R2,[R0, #+1]
    822            *s += '1';
   \   00000018   0x3231             ADDS     R2,R2,#+49
   \   0000001A   0x7042             STRB     R2,[R0, #+1]
    823          }
   \   0000001C   0x4770             BX       LR               ;; return
    824          

   \                                 In section .text, align 2, keep-with-next
    825          const char *cu_GetHalfMoveStr(uint8_t idx)
    826          {
   \                     cu_GetHalfMoveStr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    827            chm_p chm;
    828            static char buf[7];		/*Ka1-b2*/
    829            char *p = buf;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable48_1
   \   00000006   0x4626             MOV      R6,R4
    830            chm = lrc_obj.chm_list+idx;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable42
   \   0000000C   0xEB00 0x00C0      ADD      R0,R0,R0, LSL #+3
   \   00000010   0x4408             ADD      R0,R1,R0
   \   00000012   0xF100 0x0580      ADD      R5,R0,#+128
    831            
    832            if ( cp_GetPiece(chm->main_cp) != PIECE_NONE )
   \   00000016   0x7828             LDRB     R0,[R5, #+0]
   \   00000018   0x.... 0x....      BL       cp_GetPiece
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD020             BEQ.N    ??cu_GetHalfMoveStr_0
    833            {
    834              if ( cp_GetPiece(chm->main_cp) > PIECE_PAWN )
   \   00000020   0x7828             LDRB     R0,[R5, #+0]
   \   00000022   0x.... 0x....      BL       cp_GetPiece
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xDB06             BLT.N    ??cu_GetHalfMoveStr_1
    835              {
    836                *p++ = chess_piece_to_char[cp_GetPiece(chm->main_cp)-2];
   \   0000002A   0x7828             LDRB     R0,[R5, #+0]
   \   0000002C   0x.... 0x....      BL       cp_GetPiece
   \   00000030   0x4420             ADD      R0,R4,R0
   \   00000032   0x7980             LDRB     R0,[R0, #+6]
   \   00000034   0x7020             STRB     R0,[R4, #+0]
   \   00000036   0x1C66             ADDS     R6,R4,#+1
    837              }
    838              cu_add_pos(p, chm->main_src);
   \                     ??cu_GetHalfMoveStr_1: (+1)
   \   00000038   0x7869             LDRB     R1,[R5, #+1]
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x.... 0x....      BL       cu_add_pos
    839              p+=2;
    840              if ( cp_GetPiece(chm->other_cp) == PIECE_NONE )
   \   00000040   0x78E8             LDRB     R0,[R5, #+3]
   \   00000042   0x.... 0x....      BL       cp_GetPiece
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD103             BNE.N    ??cu_GetHalfMoveStr_2
    841                *p++ = '-';
   \   0000004A   0x202D             MOVS     R0,#+45
   \   0000004C   0x70B0             STRB     R0,[R6, #+2]
   \   0000004E   0x1CF6             ADDS     R6,R6,#+3
   \   00000050   0xE002             B.N      ??cu_GetHalfMoveStr_3
    842              else
    843                *p++ = 'x';
   \                     ??cu_GetHalfMoveStr_2: (+1)
   \   00000052   0x2078             MOVS     R0,#+120
   \   00000054   0x70B0             STRB     R0,[R6, #+2]
   \   00000056   0x1CF6             ADDS     R6,R6,#+3
    844              cu_add_pos(p, chm->main_dest);
   \                     ??cu_GetHalfMoveStr_3: (+1)
   \   00000058   0x78A9             LDRB     R1,[R5, #+2]
   \   0000005A   0x4630             MOV      R0,R6
   \   0000005C   0x.... 0x....      BL       cu_add_pos
    845              p+=2;
   \   00000060   0x1CB6             ADDS     R6,R6,#+2
    846            }
    847            *p = '\0';
   \                     ??cu_GetHalfMoveStr_0: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x7030             STRB     R0,[R6, #+0]
    848            return buf;
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
    849          }
    850          
    851          
    852          
    853          
    854          
    855          /*==============================================================*/
    856          /* move */
    857          /*==============================================================*/
    858          
    859          /*
    860            Move a piece from source position to a destination on the board
    861            This function
    862              - does not perform any checking
    863              - however it processes "en passant" and casteling
    864              - backup the move and allow 1x undo
    865            
    866            2011-02-05: 
    867              - fill pawn_dbl_move[] for double pawn moves
    868          	--> done
    869              - Implement casteling 
    870          	--> done
    871              - en passant
    872          	--> done
    873              - pawn conversion/promotion
    874          	--> done
    875              - half-move backup 
    876          	--> done
    877              - cleanup everything, minimize variables
    878          	--> done
    879          */
    880          

   \                                 In section .text, align 2, keep-with-next
    881          void cu_Move(uint8_t src, uint8_t dest)
    882          {  
   \                     cu_Move: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
    883            /* start backup structure */
    884            chm_p chm = cu_PushHalfMove();
   \   00000006   0x.... 0x....      BL       cu_PushHalfMove
   \   0000000A   0x4681             MOV      R9,R0
    885          
    886            /* these are the values from the board at the positions, provided as arguments to this function */
    887            uint8_t cp_src, cp_dest;
    888            
    889            /* Maybe a second position is cleared and one additional location is set */
    890            uint8_t clr_pos2;
    891            uint8_t set_pos2;
    892            uint8_t set_cp2;
    893            
    894            /* get values from board */
    895            cp_src = cp_GetFromBoard(src);
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       cp_GetFromBoard
   \   00000012   0x4606             MOV      R6,R0
    896            cp_dest = cp_GetFromBoard(dest);
   \   00000014   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000018   0x.... 0x....      BL       cp_GetFromBoard
   \   0000001C   0x4682             MOV      R10,R0
    897          
    898            /* fill backup structure */
    899            
    900            chm->main_cp = cp_src;
   \   0000001E   0xF889 0x6000      STRB     R6,[R9, #+0]
    901            chm->main_src = src;
   \   00000022   0xF889 0x5001      STRB     R5,[R9, #+1]
    902            chm->main_dest = dest;
   \   00000026   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002A   0xF889 0x0002      STRB     R0,[R9, #+2]
    903            
    904            chm->other_cp = cp_dest;		/* prepace capture backup */
   \   0000002E   0xF889 0xA003      STRB     R10,[R9, #+3]
    905            chm->other_src = dest;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0xF889 0x0004      STRB     R0,[R9, #+4]
    906            chm->other_dest = ILLEGAL_POSITION;
   \   0000003A   0x27FF             MOVS     R7,#+255
   \   0000003C   0xF889 0x7005      STRB     R7,[R9, #+5]
    907            
    908            /* setup results as far as possible with some suitable values */
    909            
    910            clr_pos2 = ILLEGAL_POSITION;	/* for en passant and castling, two positions might be cleared */
   \   00000040   0x463C             MOV      R4,R7
    911            set_pos2 = ILLEGAL_POSITION;	/* only used for castling */
    912            set_cp2 = PIECE_NONE;			/* ROOK for castling */
   \   00000042   0xF04F 0x0800      MOV      R8,#+0
    913            
    914            /* check for PAWN */
    915            if ( cp_GetPiece(cp_src) == PIECE_PAWN )
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0x.... 0x....      BL       cp_GetPiece
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD132             BNE.N    ??cu_Move_0
    916            {
    917              
    918              /* double step: is the distance 2 rows */
    919              if ( (src - dest == 32) || ( dest - src == 32 ) )
   \   00000050   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000054   0x462A             MOV      R2,R5
   \   00000056   0x1A50             SUBS     R0,R2,R1
   \   00000058   0x2820             CMP      R0,#+32
   \   0000005A   0xD002             BEQ.N    ??cu_Move_1
   \   0000005C   0x1A88             SUBS     R0,R1,R2
   \   0000005E   0x2820             CMP      R0,#+32
   \   00000060   0xD108             BNE.N    ??cu_Move_2
    920              {
    921                /* remember the destination position */
    922                lrc_obj.pawn_dbl_move[cp_GetColor(cp_src)] = dest;
   \                     ??cu_Move_1: (+1)
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0x.... 0x....      BL       cp_GetColor
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable50
   \   0000006C   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000070   0x540A             STRB     R2,[R1, R0]
   \   00000072   0xE08A             B.N      ??cu_Move_3
    923              }
    924              
    925              /* check if the PAWN is able to promote */
    926              else if ( (dest>>4) == 0 || (dest>>4) == 7 )
   \                     ??cu_Move_2: (+1)
   \   00000074   0x4608             MOV      R0,R1
   \   00000076   0x0900             LSRS     R0,R0,#+4
   \   00000078   0xD001             BEQ.N    ??cu_Move_4
   \   0000007A   0x2807             CMP      R0,#+7
   \   0000007C   0xD102             BNE.N    ??cu_Move_5
    927              {
    928                /* do simple "queening" */
    929                cp_src &= ~PIECE_PAWN;
    930                cp_src |= PIECE_QUEEN;
   \                     ??cu_Move_4: (+1)
   \   0000007E   0xF046 0x0605      ORR      R6,R6,#0x5
   \   00000082   0xE082             B.N      ??cu_Move_3
    931              }
    932              
    933              /* is it en passant capture? */
    934              /* check for side move */
    935              else if ( ((src + dest) & 1) != 0 )
   \                     ??cu_Move_5: (+1)
   \   00000084   0x1889             ADDS     R1,R1,R2
   \   00000086   0x07C8             LSLS     R0,R1,#+31
   \   00000088   0xF140 0x807F      BPL.W    ??cu_Move_3
    936              {
    937                /* check, if target field is empty */
    938                if (  cp_GetPiece(cp_dest) == PIECE_NONE )
   \   0000008C   0x4650             MOV      R0,R10
   \   0000008E   0x.... 0x....      BL       cp_GetPiece
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD179             BNE.N    ??cu_Move_3
    939                {
    940          	/* this is en passant */
    941          	/* no further checking required, because legal moves are assumed here */
    942          	/* however... the captured pawn position must be valid */
    943          	clr_pos2 = lrc_obj.pawn_dbl_move[cp_GetColor(cp_src) ^ 1];
   \   00000096   0x4630             MOV      R0,R6
   \   00000098   0x.... 0x....      BL       cp_GetColor
   \   0000009C   0xF080 0x0001      EOR      R0,R0,#0x1
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable50
   \   000000A4   0x5C0C             LDRB     R4,[R1, R0]
    944          	chm->other_src = clr_pos2;
   \   000000A6   0xF889 0x4004      STRB     R4,[R9, #+4]
    945          	chm->other_cp = cp_GetFromBoard(clr_pos2);
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       cp_GetFromBoard
   \   000000B0   0xF889 0x0003      STRB     R0,[R9, #+3]
   \   000000B4   0xE069             B.N      ??cu_Move_3
    946                }
    947              }    
    948            }
    949            
    950            /* check for the KING */
    951            else if ( cp_GetPiece(cp_src) == PIECE_KING )
   \                     ??cu_Move_0: (+1)
   \   000000B6   0x4630             MOV      R0,R6
   \   000000B8   0x.... 0x....      BL       cp_GetPiece
   \   000000BC   0x2806             CMP      R0,#+6
   \   000000BE   0xD136             BNE.N    ??cu_Move_6
    952            {
    953              /* disallow castling, if the KING has moved */
    954              if ( cp_GetColor(cp_src) == COLOR_WHITE )
   \   000000C0   0x.... 0x....      LDR.W    R10,??DataTable42
   \   000000C4   0xF89A 0xB044      LDRB     R11,[R10, #+68]
   \   000000C8   0x4630             MOV      R0,R6
   \   000000CA   0x.... 0x....      BL       cp_GetColor
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD104             BNE.N    ??cu_Move_7
    955              {
    956                /* if white KING has moved, disallow castling for white */
    957                lrc_obj.castling_possible &= 0x0c;
   \   000000D2   0xF00B 0x0B0C      AND      R11,R11,#0xC
   \   000000D6   0xF88A 0xB044      STRB     R11,[R10, #+68]
   \   000000DA   0xE003             B.N      ??cu_Move_8
    958              }
    959              else
    960              {
    961                /* if black KING has moved, disallow castling for black */
    962                lrc_obj.castling_possible &= 0x03;
   \                     ??cu_Move_7: (+1)
   \   000000DC   0xF00B 0x0B03      AND      R11,R11,#0x3
   \   000000E0   0xF88A 0xB044      STRB     R11,[R10, #+68]
    963              }
    964              
    965              /* has it been castling to the left? */
    966              if ( src - dest == 2 )
   \                     ??cu_Move_8: (+1)
   \   000000E4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E8   0x4629             MOV      R1,R5
   \   000000EA   0x1A0A             SUBS     R2,R1,R0
   \   000000EC   0x2A02             CMP      R2,#+2
   \   000000EE   0xD10D             BNE.N    ??cu_Move_9
    967              {
    968                /* let the ROOK move to pos2 */
    969                set_pos2 = src-1;
   \   000000F0   0x1E6F             SUBS     R7,R5,#+1
    970                set_cp2 = cp_GetFromBoard(src-4);
   \   000000F2   0x1F2C             SUBS     R4,R5,#+4
   \   000000F4   0x4620             MOV      R0,R4
   \   000000F6   0xB2C0             UXTB     R0,R0
   \   000000F8   0x.... 0x....      BL       cp_GetFromBoard
   \   000000FC   0x4680             MOV      R8,R0
    971                
    972                /* the ROOK must be cleared from the original position */
    973                clr_pos2 = src-4;
    974                
    975                chm->other_cp = set_cp2;
   \   000000FE   0xF889 0x8003      STRB     R8,[R9, #+3]
    976                chm->other_src = clr_pos2;
   \   00000102   0xF889 0x4004      STRB     R4,[R9, #+4]
    977                chm->other_dest = set_pos2;
   \   00000106   0xF889 0x7005      STRB     R7,[R9, #+5]
   \   0000010A   0xE03E             B.N      ??cu_Move_3
    978              }
    979              
    980              /* has it been castling to the right? */
    981              else if ( dest - src == 2 )
   \                     ??cu_Move_9: (+1)
   \   0000010C   0x1A40             SUBS     R0,R0,R1
   \   0000010E   0x2802             CMP      R0,#+2
   \   00000110   0xD13B             BNE.N    ??cu_Move_3
    982              {
    983                /* let the ROOK move to pos2 */
    984                set_pos2 = src+1;
   \   00000112   0x1C6F             ADDS     R7,R5,#+1
    985                set_cp2 = cp_GetFromBoard(src+3);
   \   00000114   0x1CEC             ADDS     R4,R5,#+3
   \   00000116   0x4620             MOV      R0,R4
   \   00000118   0xB2C0             UXTB     R0,R0
   \   0000011A   0x.... 0x....      BL       cp_GetFromBoard
   \   0000011E   0x4680             MOV      R8,R0
    986                
    987                /* the ROOK must be cleared from the original position */
    988                clr_pos2 = src+3;
    989                
    990                chm->other_cp = set_cp2;
   \   00000120   0xF889 0x8003      STRB     R8,[R9, #+3]
    991                chm->other_src = clr_pos2;
   \   00000124   0xF889 0x4004      STRB     R4,[R9, #+4]
    992                chm->other_dest = set_pos2;
   \   00000128   0xF889 0x7005      STRB     R7,[R9, #+5]
   \   0000012C   0xE02D             B.N      ??cu_Move_3
    993                
    994              }
    995              
    996            }
    997            
    998            /* check for the ROOK */
    999            else if ( cp_GetPiece(cp_src) == PIECE_ROOK )
   \                     ??cu_Move_6: (+1)
   \   0000012E   0x4630             MOV      R0,R6
   \   00000130   0x.... 0x....      BL       cp_GetPiece
   \   00000134   0x2804             CMP      R0,#+4
   \   00000136   0xD128             BNE.N    ??cu_Move_3
   1000            {
   1001              /* disallow white left castling */
   1002              if ( src == 0x00 )
   \   00000138   0x0028             MOVS     R0,R5
   \   0000013A   0xD107             BNE.N    ??cu_Move_10
   1003                lrc_obj.castling_possible &= ~0x01;
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000140   0xF890 0x1044      LDRB     R1,[R0, #+68]
   \   00000144   0xF001 0x01FE      AND      R1,R1,#0xFE
   \   00000148   0xF880 0x1044      STRB     R1,[R0, #+68]
   1004              /* disallow white right castling */
   1005              if ( src == 0x07 )
   \                     ??cu_Move_10: (+1)
   \   0000014C   0x4628             MOV      R0,R5
   \   0000014E   0x2807             CMP      R0,#+7
   \   00000150   0xD107             BNE.N    ??cu_Move_11
   1006                lrc_obj.castling_possible &= ~0x02;
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable42
   \   00000156   0xF891 0x2044      LDRB     R2,[R1, #+68]
   \   0000015A   0xF002 0x02FD      AND      R2,R2,#0xFD
   \   0000015E   0xF881 0x2044      STRB     R2,[R1, #+68]
   1007              /* disallow black left castling */
   1008              if ( src == 0x70 )
   \                     ??cu_Move_11: (+1)
   \   00000162   0x2870             CMP      R0,#+112
   \   00000164   0xD107             BNE.N    ??cu_Move_12
   1009                lrc_obj.castling_possible &= ~0x04;
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable42
   \   0000016A   0xF891 0x2044      LDRB     R2,[R1, #+68]
   \   0000016E   0xF002 0x02FB      AND      R2,R2,#0xFB
   \   00000172   0xF881 0x2044      STRB     R2,[R1, #+68]
   1010              /* disallow black right castling */
   1011              if ( src == 0x77 )
   \                     ??cu_Move_12: (+1)
   \   00000176   0x2877             CMP      R0,#+119
   \   00000178   0xD107             BNE.N    ??cu_Move_3
   1012                lrc_obj.castling_possible &= ~0x08;
   \   0000017A   0x.... 0x....      LDR.W    R0,??DataTable42
   \   0000017E   0xF890 0x1044      LDRB     R1,[R0, #+68]
   \   00000182   0xF001 0x01F7      AND      R1,R1,#0xF7
   \   00000186   0xF880 0x1044      STRB     R1,[R0, #+68]
   1013            }
   1014            
   1015            
   1016            /* apply new board situation */
   1017            
   1018            cp_SetOnBoard(dest, cp_src);
   \                     ??cu_Move_3: (+1)
   \   0000018A   0x4631             MOV      R1,R6
   \   0000018C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000190   0x.... 0x....      BL       cp_SetOnBoard
   1019            
   1020            if ( set_pos2 != ILLEGAL_POSITION )
   \   00000194   0x4638             MOV      R0,R7
   \   00000196   0xB2C0             UXTB     R0,R0
   \   00000198   0x28FF             CMP      R0,#+255
   \   0000019A   0xD004             BEQ.N    ??cu_Move_13
   1021              cp_SetOnBoard(set_pos2, set_cp2);
   \   0000019C   0x4641             MOV      R1,R8
   \   0000019E   0x4638             MOV      R0,R7
   \   000001A0   0xB2C0             UXTB     R0,R0
   \   000001A2   0x.... 0x....      BL       cp_SetOnBoard
   1022            
   1023            cp_SetOnBoard(src, PIECE_NONE);
   \                     ??cu_Move_13: (+1)
   \   000001A6   0x2100             MOVS     R1,#+0
   \   000001A8   0x4628             MOV      R0,R5
   \   000001AA   0x.... 0x....      BL       cp_SetOnBoard
   1024            
   1025            if ( clr_pos2 != ILLEGAL_POSITION )
   \   000001AE   0x4620             MOV      R0,R4
   \   000001B0   0xB2C0             UXTB     R0,R0
   \   000001B2   0x28FF             CMP      R0,#+255
   \   000001B4   0xD005             BEQ.N    ??cu_Move_14
   1026              cp_SetOnBoard(clr_pos2, PIECE_NONE);
   \   000001B6   0x2100             MOVS     R1,#+0
   \   000001B8   0x4620             MOV      R0,R4
   \   000001BA   0xB2C0             UXTB     R0,R0
   \   000001BC   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   000001C0   0x....             B.N      cp_SetOnBoard
   1027            
   1028            
   1029          }
   \                     ??cu_Move_14: (+1)
   \   000001C2   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   1030          
   1031          /*
   1032            this subprocedure decides for evaluation of the current board situation or further (deeper) investigation
   1033            Argument pos is the new target position if the current piece 
   1034          
   1035          */

   \                                 In section .text, align 2, keep-with-next
   1036          uint8_t ce_LoopRecur(uint8_t pos)
   1037          {
   \                     ce_LoopRecur: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   1038            eval_t eval;
   1039            
   1040            /* 1. check if target position is occupied by the same player (my_color) */
   1041            /*     of if pos is somehow illegal or not valid */
   1042            if ( cu_IsIllegalPosition(pos, stack_GetCurrElement()->current_color) != 0 )
   \   00000004   0x.... 0x....      BL       stack_GetCurrElement
   \   00000008   0x7881             LDRB     R1,[R0, #+2]
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       cu_IsIllegalPosition
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??ce_LoopRecur_0
   1043              return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD70             POP      {R4-R6,PC}
   1044          
   1045            /* 2. move piece to the specified position, capture opponent piece if required */
   1046            cu_Move(stack_GetCurrElement()->current_pos, pos);
   \                     ??ce_LoopRecur_0: (+1)
   \   00000018   0x.... 0x....      BL       stack_GetCurrElement
   \   0000001C   0x4629             MOV      R1,R5
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x.... 0x....      BL       cu_Move
   1047          
   1048            
   1049            /* 3. */
   1050            /* if depth reached: evaluate */
   1051            /* else: go down next level */
   1052            /* no eval if there had been any valid half-moves, so the default value (MIN) will be returned. */
   1053            if ( stack_Push(stack_GetCurrElement()->current_color) == 0 )
   \   00000024   0x.... 0x....      BL       stack_GetCurrElement
   \   00000028   0x7880             LDRB     R0,[R0, #+2]
   \   0000002A   0x.... 0x....      BL       stack_Push
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD103             BNE.N    ??ce_LoopRecur_1
   1054            {
   1055              eval = ce_Eval();
   \   00000032   0x.... 0x....      BL       ce_Eval
   \   00000036   0x4604             MOV      R4,R0
   \   00000038   0xE00A             B.N      ??ce_LoopRecur_2
   1056            }
   1057            else
   1058            {
   1059              /* init the element, which has been pushed */
   1060              stack_InitCurrElement();
   \                     ??ce_LoopRecur_1: (+1)
   \   0000003A   0x.... 0x....      BL       stack_InitCurrElement
   1061              /* start over with ntext level */
   1062              ce_LoopPieces();
   \   0000003E   0x.... 0x....      BL       ce_LoopPieces
   1063              /* get the best move from opponents view, so invert the result */
   1064              eval = -stack_GetCurrElement()->best_eval;
   \   00000042   0x.... 0x....      BL       stack_GetCurrElement
   \   00000046   0xF9B0 0x4006      LDRSH    R4,[R0, #+6]
   \   0000004A   0x4264             RSBS     R4,R4,#+0
   1065              stack_Pop();
   \   0000004C   0x.... 0x....      BL       stack_Pop
   1066            }
   1067            
   1068            /* 4. store result */
   1069            stack_SetMove(eval, pos);
   \                     ??ce_LoopRecur_2: (+1)
   \   00000050   0x4629             MOV      R1,R5
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0xB200             SXTH     R0,R0
   \   00000056   0x.... 0x....      BL       stack_SetMove
   1070            
   1071            /* 5. undo the move */
   1072            cu_UndoHalfMove();
   \   0000005A   0x.... 0x....      BL       cu_UndoHalfMove
   1073            
   1074            /* 6. check special modes */
   1075            /* the purpose of these checks is to mark special pieces and positions on the board */
   1076            /* these marks can be checked by the user interface to highlight special positions */
   1077            if ( lrc_obj.check_mode != 0 )
   \   0000005E   0x.... 0x....      LDR.W    R6,??DataTable51
   \   00000062   0x7874             LDRB     R4,[R6, #+1]
   \   00000064   0x2C00             CMP      R4,#+0
   \   00000066   0xD019             BEQ.N    ??ce_LoopRecur_3
   1078            {
   1079              stack_element_p e = stack_GetCurrElement();
   \   00000068   0x.... 0x....      BL       stack_GetCurrElement
   1080              if ( lrc_obj.check_mode == CHECK_MODE_MOVEABLE )
   \   0000006C   0x2C01             CMP      R4,#+1
   \   0000006E   0xD106             BNE.N    ??ce_LoopRecur_4
   1081              {
   1082                cp_SetOnBoard(e->current_pos, e->current_cp | CP_MARK_MASK );
   \   00000070   0x7841             LDRB     R1,[R0, #+1]
   \   00000072   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x.... 0x....      BL       cp_SetOnBoard
   \   0000007C   0xE00E             B.N      ??ce_LoopRecur_3
   1083              }
   1084              else if ( lrc_obj.check_mode == CHECK_MODE_TARGET_MOVE )
   \                     ??ce_LoopRecur_4: (+1)
   \   0000007E   0x2C02             CMP      R4,#+2
   \   00000080   0xD10C             BNE.N    ??ce_LoopRecur_3
   1085              {
   1086                if ( e->current_pos == lrc_obj.check_src_pos )
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x7831             LDRB     R1,[R6, #+0]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD108             BNE.N    ??ce_LoopRecur_3
   1087                {
   1088          	cp_SetOnBoard(pos, cp_GetFromBoard(pos)  | CP_MARK_MASK );
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0x.... 0x....      BL       cp_GetFromBoard
   \   00000090   0x4601             MOV      R1,R0
   \   00000092   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000096   0x4628             MOV      R0,R5
   \   00000098   0x.... 0x....      BL       cp_SetOnBoard
   1089                }
   1090              }
   1091            }
   1092            return 1;
   \                     ??ce_LoopRecur_3: (+1)
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xBD70             POP      {R4-R6,PC}       ;; return
   1093          }
   1094          
   1095          /*==============================================================*/
   1096          /* move pieces which can move one or more steps into a direction */
   1097          /*==============================================================*/
   1098          
   1099          /*
   1100            subprocedure to generate various target positions for some pieces
   1101            special cases are handled in the piece specific sub-procedure
   1102          
   1103            Arguments:
   1104              d: a list of potential directions
   1105              is_multi_step: if the piece can only do one step (zero for KING and KNIGHT)
   1106          */

   \                                 In section .text, align 4, keep-with-next
   1107          static const uint8_t ce_dir_offset_rook[] PROGMEM = { 1, 16, -16, -1, 0 };
                                                                              ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \                     ce_dir_offset_rook:
   \   00000000   0x01 0x10          DC8 1, 16, 240, 255, 0, 0, 0, 0
   \              0xF0 0xFF    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   1108          static const uint8_t ce_dir_offset_bishop[] PROGMEM = { 15, 17, -17, -15, 0 };
                                                                                 ^
Warning[Pe068]: integer conversion resulted in a change of sign

  static const uint8_t ce_dir_offset_bishop[] PROGMEM = { 15, 17, -17, -15, 0 };
                                                                       ^
"F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\chessengine.c",1108  Warning[Pe068]: 
          integer conversion resulted in a change of sign
   \                     ce_dir_offset_bishop:
   \   00000000   0x0F 0x11          DC8 15, 17, 239, 241, 0, 0, 0, 0
   \              0xEF 0xF1    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   1109          static const uint8_t ce_dir_offset_queen[] PROGMEM = { 1, 16, -16, -1, 15, 17, -17, -15, 0 };
                                                                               ^
Warning[Pe068]: integer conversion resulted in a change of sign

  static const uint8_t ce_dir_offset_queen[] PROGMEM = { 1, 16, -16, -1, 15, 17, -17, -15, 0 };
                                                                                 ^
"F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\chessengine.c",1109  Warning[Pe068]: 
          integer conversion resulted in a change of sign

  static const uint8_t ce_dir_offset_queen[] PROGMEM = { 1, 16, -16, -1, 15, 17, -17, -15, 0 };
                                                                                      ^
"F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\chessengine.c",1109  Warning[Pe068]: 
          integer conversion resulted in a change of sign
   \                     ce_dir_offset_queen:
   \   00000000   0x01 0x10          DC8 1, 16, 240, 255, 15, 17, 239, 241, 0, 0, 0, 0
   \              0xF0 0xFF    
   \              0x0F 0x11    
   \              0xEF 0xF1    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   1110          static const uint8_t ce_dir_offset_knight[] PROGMEM = {14, -14, 18, -18, 31, -31, 33, -33, 0};
                                                                            ^
Warning[Pe068]: integer conversion resulted in a change of sign

  static const uint8_t ce_dir_offset_knight[] PROGMEM = {14, -14, 18, -18, 31, -31, 33, -33, 0};
                                                                      ^
"F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\chessengine.c",1110  Warning[Pe068]: 
          integer conversion resulted in a change of sign

  static const uint8_t ce_dir_offset_knight[] PROGMEM = {14, -14, 18, -18, 31, -31, 33, -33, 0};
                                                                               ^
"F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\chessengine.c",1110  Warning[Pe068]: 
          integer conversion resulted in a change of sign

  static const uint8_t ce_dir_offset_knight[] PROGMEM = {14, -14, 18, -18, 31, -31, 33, -33, 0};
                                                                                        ^
"F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\chessengine.c",1110  Warning[Pe068]: 
          integer conversion resulted in a change of sign
Warning[Ms014]: some characters could not be correctly encoded in
          "F:\nano\EWARM\mksRobinLite\List\chessengine.s", and have been
          replaced with '@'. The first such character has unicode code point
          0x9ef6 ("@")
   \                     ce_dir_offset_knight:
   \   00000000   0x0E 0xF2          DC8 14, 242, 18, 238, 31, 225, 33, 223, 0, 0, 0, 0
   \              0x12 0xEE    
   \              0x1F 0xE1    
   \              0x21 0xDF    
   \              0x00 0x00    
   \              0x00 0x00    
   1111          

   \                                 In section .text, align 2, keep-with-next
   1112          void ce_LoopDirsSingleMultiStep(const uint8_t *d, uint8_t is_multi_step)
   1113          {
   \                     ce_LoopDirsSingleMultiStep: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xE015             B.N      ??ce_LoopDirsSingleMultiStep_0
   1114            uint8_t loop_pos;
   1115            
   1116            /* with all directions */
   1117            for(;;)
   1118            {
   1119              if ( u8g_pgm_read(d) == 0 )
   1120                break;
   1121              
   1122              /* start again from the initial position */
   1123              loop_pos = stack_GetCurrElement()->current_pos;
   \                     ??ce_LoopDirsSingleMultiStep_1: (+1)
   \   00000008   0x.... 0x....      BL       stack_GetCurrElement
   \   0000000C   0x7806             LDRB     R6,[R0, #+0]
   1124              
   1125              /* check direction */
   1126              do
   1127              {
   1128                /* check next position into one direction */
   1129                loop_pos += u8g_pgm_read(d);
   \                     ??ce_LoopDirsSingleMultiStep_2: (+1)
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x1986             ADDS     R6,R0,R6
   1130                
   1131                /*
   1132          	go further to ce_LoopRecur()
   1133          	0 will be returned if the target position is illegal or a piece of the own color
   1134          	this is used to stop walking into one direction
   1135                */
   1136                if ( ce_LoopRecur(loop_pos) == 0 )
   \   00000012   0x4630             MOV      R0,R6
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x.... 0x....      BL       ce_LoopRecur
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD009             BEQ.N    ??ce_LoopDirsSingleMultiStep_3
   1137          	break;
   1138                
   1139                /* stop if we had hit another piece */
   1140                if ( cp_GetPiece(cp_GetFromBoard(loop_pos)) != PIECE_NONE )
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0x.... 0x....      BL       cp_GetFromBoard
   \   00000026   0x.... 0x....      BL       cp_GetPiece
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD101             BNE.N    ??ce_LoopDirsSingleMultiStep_3
   1141          	break;
   1142              } while( is_multi_step );
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xD1ED             BNE.N    ??ce_LoopDirsSingleMultiStep_2
   1143              d++;
   \                     ??ce_LoopDirsSingleMultiStep_3: (+1)
   \   00000032   0x1C64             ADDS     R4,R4,#+1
   \                     ??ce_LoopDirsSingleMultiStep_0: (+1)
   \   00000034   0x7820             LDRB     R0,[R4, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD1E6             BNE.N    ??ce_LoopDirsSingleMultiStep_1
   1144            }
   1145          }
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
   1146          

   \                                 In section .text, align 2, keep-with-next
   1147          void ce_LoopRook(void)
   1148          {
   1149            ce_LoopDirsSingleMultiStep(ce_dir_offset_rook, 1);
   \                     ce_LoopRook: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x.... 0x....      ADR.W    R0,ce_dir_offset_rook
   \   00000006   0x....             B.N      ce_LoopDirsSingleMultiStep
   1150          }
   1151          

   \                                 In section .text, align 2, keep-with-next
   1152          void ce_LoopBishop(void)
   1153          {
   1154            ce_LoopDirsSingleMultiStep(ce_dir_offset_bishop, 1);
   \                     ce_LoopBishop: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x.... 0x....      ADR.W    R0,ce_dir_offset_bishop
   \   00000006   0x....             B.N      ce_LoopDirsSingleMultiStep
   1155          }
   1156          

   \                                 In section .text, align 2, keep-with-next
   1157          void ce_LoopQueen(void)
   1158          {
   1159            ce_LoopDirsSingleMultiStep(ce_dir_offset_queen, 1);
   \                     ce_LoopQueen: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x.... 0x....      ADR.W    R0,ce_dir_offset_queen
   \   00000006   0x....             B.N      ce_LoopDirsSingleMultiStep
   1160          }
   1161          

   \                                 In section .text, align 2, keep-with-next
   1162          void ce_LoopKnight(void)
   1163          {
   1164            ce_LoopDirsSingleMultiStep(ce_dir_offset_knight, 0);
   \                     ce_LoopKnight: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      ADR.W    R0,ce_dir_offset_knight
   \   00000006   0x....             B.N      ce_LoopDirsSingleMultiStep
   1165          }
   1166          
   1167          
   1168          
   1169          /*==============================================================*/
   1170          /* move king */
   1171          /*==============================================================*/
   1172          
   1173          uint8_t cu_IsKingCastling(uint8_t mask, int8_t direction, uint8_t cnt) U8G_NOINLINE;
   1174          
   1175          /*
   1176            checks, if the king can do castling
   1177          
   1178            Arguments:
   1179              mask:		the bit-mask for the global "castling possible" flag
   1180              direction:	left castling: -1, right castling 1
   1181              cnt:		number of fields to be checked: 3 or 2
   1182          */

   \                                 In section .text, align 2, keep-with-next
   1183          uint8_t cu_IsKingCastling(uint8_t mask, int8_t direction, uint8_t cnt)
   1184          {
   \                     cu_IsKingCastling: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
   1185            uint8_t pos;
   1186            uint8_t opponent_color;
   1187            
   1188            /* check if the current board state allows castling */
   1189            if ( (lrc_obj.castling_possible & mask) == 0 )
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable52
   \   0000000A   0xF891 0x1044      LDRB     R1,[R1, #+68]
   \   0000000E   0x4201             TST      R1,R0
   \   00000010   0xD026             BEQ.N    ??cu_IsKingCastling_0
   1190              return 0; 	/* castling not allowed */
   1191            
   1192            /* get the position of the KING, could be white or black king */
   1193            pos = stack_GetCurrElement()->current_pos;
   \   00000012   0x.... 0x....      BL       stack_GetCurrElement
   \   00000016   0x7806             LDRB     R6,[R0, #+0]
   1194            
   1195            /* calculate the color of the opponent */
   1196            opponent_color = 1;
   1197            opponent_color -= stack_GetCurrElement()->current_color;
   \   00000018   0x.... 0x....      BL       stack_GetCurrElement
   \   0000001C   0x7887             LDRB     R7,[R0, #+2]
   \   0000001E   0xF1C7 0x0701      RSB      R7,R7,#+1
   1198            
   1199            /* if the KING itself is given check... */
   1200            if ( ce_GetPositionAttackWeight(pos, opponent_color) > 0 )
   \   00000022   0x4639             MOV      R1,R7
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       ce_GetPositionAttackWeight
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD117             BNE.N    ??cu_IsKingCastling_0
   1201              return 0;
   1202          
   1203            
   1204            /* check if fields in the desired direction are emtpy */
   1205            for(;;)
   1206            {
   1207              /* go to the next field */
   1208              pos += direction;
   \                     ??cu_IsKingCastling_1: (+1)
   \   00000030   0x19A6             ADDS     R6,R4,R6
   1209              /* check for a piece */
   1210              if ( cp_GetPiece(cp_GetFromBoard(pos)) != PIECE_NONE )
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0x.... 0x....      BL       cp_GetFromBoard
   \   0000003A   0x.... 0x....      BL       cp_GetPiece
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD10E             BNE.N    ??cu_IsKingCastling_0
   1211                return 0;		/* castling not allowed */
   1212          
   1213              /* if some of the fields are under attack */
   1214              if ( ce_GetPositionAttackWeight(pos, opponent_color) > 0 )
   \   00000042   0x4639             MOV      R1,R7
   \   00000044   0xB2C9             UXTB     R1,R1
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0xB2C0             UXTB     R0,R0
   \   0000004A   0x.... 0x....      BL       ce_GetPositionAttackWeight
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD106             BNE.N    ??cu_IsKingCastling_0
   1215                return 0;
   1216              
   1217              cnt--;
   \   00000052   0x1E6D             SUBS     R5,R5,#+1
   1218              if ( cnt == 0 )
   \   00000054   0x4628             MOV      R0,R5
   \   00000056   0xB2C0             UXTB     R0,R0
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD1E9             BNE.N    ??cu_IsKingCastling_1
   1219                break;
   1220            }
   1221            return 1; /* castling allowed */
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??cu_IsKingCastling_0: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}
   1222          }
   1223          

   \                                 In section .text, align 2, keep-with-next
   1224          void ce_LoopKing(void)
   1225          {
   \                     ce_LoopKing: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1226            /*
   1227              there is an interessting timing problem in this procedure
   1228              it must be checked for castling first and as second step the normal
   1229              KING movement. If we would first check for normal moves, than
   1230              any marks might be overwritten by the ROOK in the case of castling.
   1231            */
   1232            
   1233            /* castling (this must be done before checking normal moves (see above) */
   1234            if ( stack_GetCurrElement()->current_color == COLOR_WHITE )
   \   00000002   0x.... 0x....      BL       stack_GetCurrElement
   \   00000006   0x7880             LDRB     R0,[R0, #+2]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD11D             BNE.N    ??ce_LoopKing_0
   1235            {
   1236              /* white left castling */
   1237              if ( cu_IsKingCastling(1, -1, 3) != 0 )
   \   0000000C   0x2203             MOVS     R2,#+3
   \   0000000E   0xF04F 0x31FF      MOV      R1,#-1
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       cu_IsKingCastling
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD006             BEQ.N    ??ce_LoopKing_1
   1238              {
   1239                /* check for attacked fields */
   1240                ce_LoopRecur(stack_GetCurrElement()->current_pos-2);
   \   0000001C   0x.... 0x....      BL       stack_GetCurrElement
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x1E80             SUBS     R0,R0,#+2
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x.... 0x....      BL       ce_LoopRecur
   1241              }
   1242              /* white right castling */
   1243              if ( cu_IsKingCastling(2, 1, 2) != 0 )
   \                     ??ce_LoopKing_1: (+1)
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x4610             MOV      R0,R2
   \   00000030   0x.... 0x....      BL       cu_IsKingCastling
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD024             BEQ.N    ??ce_LoopKing_2
   1244              {
   1245                /* check for attacked fields */
   1246                ce_LoopRecur(stack_GetCurrElement()->current_pos+2);
   \   00000038   0x.... 0x....      BL       stack_GetCurrElement
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x1C80             ADDS     R0,R0,#+2
   \   00000040   0xB2C0             UXTB     R0,R0
   \   00000042   0x.... 0x....      BL       ce_LoopRecur
   \   00000046   0xE01C             B.N      ??ce_LoopKing_2
   1247              }
   1248            }
   1249            else
   1250            {
   1251              /* black left castling */
   1252              if ( cu_IsKingCastling(4, -1, 3) != 0 )
   \                     ??ce_LoopKing_0: (+1)
   \   00000048   0x2203             MOVS     R2,#+3
   \   0000004A   0xF04F 0x31FF      MOV      R1,#-1
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x.... 0x....      BL       cu_IsKingCastling
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD006             BEQ.N    ??ce_LoopKing_3
   1253              {
   1254                /* check for attacked fields */
   1255                ce_LoopRecur(stack_GetCurrElement()->current_pos-2);
   \   00000058   0x.... 0x....      BL       stack_GetCurrElement
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x1E80             SUBS     R0,R0,#+2
   \   00000060   0xB2C0             UXTB     R0,R0
   \   00000062   0x.... 0x....      BL       ce_LoopRecur
   1256              }
   1257              /* black right castling */
   1258              if ( cu_IsKingCastling(8, 1, 2) != 0 )
   \                     ??ce_LoopKing_3: (+1)
   \   00000066   0x2202             MOVS     R2,#+2
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x2008             MOVS     R0,#+8
   \   0000006C   0x.... 0x....      BL       cu_IsKingCastling
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD006             BEQ.N    ??ce_LoopKing_2
   1259              {
   1260                /* check for attacked fields */
   1261                ce_LoopRecur(stack_GetCurrElement()->current_pos+2);
   \   00000074   0x.... 0x....      BL       stack_GetCurrElement
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x1C80             ADDS     R0,R0,#+2
   \   0000007C   0xB2C0             UXTB     R0,R0
   \   0000007E   0x.... 0x....      BL       ce_LoopRecur
   1262              }
   1263            }
   1264            
   1265            /* reuse queen directions */
   1266            ce_LoopDirsSingleMultiStep(ce_dir_offset_queen, 0);
   \                     ??ce_LoopKing_2: (+1)
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x.... 0x....      ADR.W    R0,ce_dir_offset_queen
   \   00000088   0xE8BD 0x4004      POP      {R2,LR}
   \   0000008C   0x....             B.N      ce_LoopDirsSingleMultiStep
   1267          }
   1268          
   1269          
   1270          /*==============================================================*/
   1271          /* move pawn */
   1272          /*==============================================================*/
   1273          
   1274          /*
   1275            doppelschritt: nur von der grundlinie aus, beide (!) felder vor dem bauern m@sen frei sein
   1276            en passant: nur unmittelbar nachdem ein doppelschritt ausgef@rt wurde.
   1277          */

   \                                 In section .text, align 2, keep-with-next
   1278          void ce_LoopPawnSideCapture(uint8_t loop_pos)
   1279          {
   \                     ce_LoopPawnSideCapture: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1280            if ( gpos_IsIllegal(loop_pos) == 0 )
   \   00000004   0xF014 0x0F88      TST      R4,#0x88
   \   00000008   0xD121             BNE.N    ??ce_LoopPawnSideCapture_0
   1281            {
   1282              /* get the piece from the board */
   1283              /* if the field is NOT empty */
   1284              if ( cp_GetPiece(cp_GetFromBoard(loop_pos)) != PIECE_NONE )
   \   0000000A   0x.... 0x....      BL       cp_GetFromBoard
   \   0000000E   0x.... 0x....      BL       cp_GetPiece
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??ce_LoopPawnSideCapture_1
   1285              {
   1286                /* normal capture */
   1287                ce_LoopRecur(loop_pos);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x....             B.N      ce_LoopRecur
   1288                /* TODO: check for pawn conversion/promotion */
   1289              }
   1290              else
   1291              {
   1292                /* check conditions for en passant capture */
   1293                if ( stack_GetCurrElement()->current_color == COLOR_WHITE )
   \                     ??ce_LoopPawnSideCapture_1: (+1)
   \   0000001E   0x.... 0x....      BL       stack_GetCurrElement
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable50
   \   00000026   0x4622             MOV      R2,R4
   \   00000028   0x7880             LDRB     R0,[R0, #+2]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD107             BNE.N    ??ce_LoopPawnSideCapture_2
   1294                {
   1295          	if ( lrc_obj.pawn_dbl_move[COLOR_BLACK]+16 == loop_pos )
   \   0000002E   0x7848             LDRB     R0,[R1, #+1]
   \   00000030   0x3010             ADDS     R0,R0,#+16
   \   00000032   0x4290             CMP      R0,R2
   \   00000034   0xD10B             BNE.N    ??ce_LoopPawnSideCapture_0
   1296          	{
   1297          	  ce_LoopRecur(loop_pos);
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003C   0x....             B.N      ce_LoopRecur
   1298          	  /* note: pawn conversion/promotion can not occur */
   1299          	}
   1300                }
   1301                else
   1302                {
   1303          	if ( lrc_obj.pawn_dbl_move[COLOR_WHITE] == loop_pos+16 )
   \                     ??ce_LoopPawnSideCapture_2: (+1)
   \   0000003E   0x7808             LDRB     R0,[R1, #+0]
   \   00000040   0x3210             ADDS     R2,R2,#+16
   \   00000042   0x4290             CMP      R0,R2
   \   00000044   0xD103             BNE.N    ??ce_LoopPawnSideCapture_0
   1304          	{
   1305          	  ce_LoopRecur(loop_pos);
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004C   0x....             B.N      ce_LoopRecur
   1306          	  /* note: pawn conversion/promotion can not occur */
   1307          	}
   1308                }
   1309              }
   1310            }
   1311          }
   \                     ??ce_LoopPawnSideCapture_0: (+1)
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   1312          

   \                                 In section .text, align 2, keep-with-next
   1313          void ce_LoopPawn(void)
   1314          {
   \                     ce_LoopPawn: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1315            uint8_t initial_pos = stack_GetCurrElement()->current_pos; 
   \   00000002   0x.... 0x....      BL       stack_GetCurrElement
   \   00000006   0x7805             LDRB     R5,[R0, #+0]
   1316            uint8_t my_color = stack_GetCurrElement()->current_color;
   \   00000008   0x.... 0x....      BL       stack_GetCurrElement
   \   0000000C   0x7884             LDRB     R4,[R0, #+2]
   1317            
   1318            uint8_t loop_pos;
   1319            uint8_t line;
   1320            
   1321            /* one step forward */
   1322            
   1323            loop_pos = initial_pos;
   1324            line = initial_pos;
   1325            line >>= 4;
   \   0000000E   0x462E             MOV      R6,R5
   \   00000010   0x0936             LSRS     R6,R6,#+4
   1326            if ( my_color == COLOR_WHITE )
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD102             BNE.N    ??ce_LoopPawn_0
   1327              loop_pos += 16;
   \   00000016   0xF105 0x0710      ADD      R7,R5,#+16
   \   0000001A   0xE001             B.N      ??ce_LoopPawn_1
   1328            else
   1329              loop_pos -= 16;
   \                     ??ce_LoopPawn_0: (+1)
   \   0000001C   0xF1A5 0x0710      SUB      R7,R5,#+16
   1330            if ( gpos_IsIllegal(loop_pos) == 0 )
   \                     ??ce_LoopPawn_1: (+1)
   \   00000020   0xF017 0x0F88      TST      R7,#0x88
   \   00000024   0xD124             BNE.N    ??ce_LoopPawn_2
   1331            {
   1332              /* if the field is empty */
   1333              if ( cp_GetPiece(cp_GetFromBoard(loop_pos)) == PIECE_NONE )
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0xB2C0             UXTB     R0,R0
   \   0000002A   0x.... 0x....      BL       cp_GetFromBoard
   \   0000002E   0x.... 0x....      BL       cp_GetPiece
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD11C             BNE.N    ??ce_LoopPawn_2
   1334              {
   1335                /* TODO: check for and loop through piece conversion/promotion */
   1336                ce_LoopRecur(loop_pos);      
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0xB2C0             UXTB     R0,R0
   \   0000003A   0x.... 0x....      BL       ce_LoopRecur
   1337          
   1338                /* second step forward */
   1339                
   1340                /* if pawn is on his starting line */
   1341                if ( (my_color == COLOR_WHITE && line == 1) || (my_color == COLOR_BLACK && line == 6 ) )
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD101             BNE.N    ??ce_LoopPawn_3
   \   00000042   0x2E01             CMP      R6,#+1
   \   00000044   0xD003             BEQ.N    ??ce_LoopPawn_4
   \                     ??ce_LoopPawn_3: (+1)
   \   00000046   0x2C01             CMP      R4,#+1
   \   00000048   0xD112             BNE.N    ??ce_LoopPawn_2
   \   0000004A   0x2E06             CMP      R6,#+6
   \   0000004C   0xD110             BNE.N    ??ce_LoopPawn_2
   1342                {
   1343          	/* the place before the pawn is not occupied, so we can do double moves, see above */
   1344          	
   1345          	if ( my_color == COLOR_WHITE )
   \                     ??ce_LoopPawn_4: (+1)
   \   0000004E   0x2C00             CMP      R4,#+0
   \   00000050   0xD101             BNE.N    ??ce_LoopPawn_5
   1346          	  loop_pos += 16;
   \   00000052   0x3710             ADDS     R7,R7,#+16
   \   00000054   0xE000             B.N      ??ce_LoopPawn_6
   1347          	else
   1348          	  loop_pos -= 16;
   \                     ??ce_LoopPawn_5: (+1)
   \   00000056   0x3F10             SUBS     R7,R7,#+16
   1349          	if ( cp_GetPiece(cp_GetFromBoard(loop_pos)) == PIECE_NONE )
   \                     ??ce_LoopPawn_6: (+1)
   \   00000058   0x4638             MOV      R0,R7
   \   0000005A   0xB2C0             UXTB     R0,R0
   \   0000005C   0x.... 0x....      BL       cp_GetFromBoard
   \   00000060   0x.... 0x....      BL       cp_GetPiece
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD103             BNE.N    ??ce_LoopPawn_2
   1350          	{
   1351          	  /* this is a special case, other promotions of the pawn can not occur */
   1352          	  ce_LoopRecur(loop_pos);
   \   00000068   0x4638             MOV      R0,R7
   \   0000006A   0xB2C0             UXTB     R0,R0
   \   0000006C   0x.... 0x....      BL       ce_LoopRecur
   1353          	}
   1354                }
   1355              }
   1356            }
   1357          
   1358            /* capture */
   1359            
   1360            loop_pos = initial_pos;
   1361            if ( my_color == COLOR_WHITE )
   \                     ??ce_LoopPawn_2: (+1)
   \   00000070   0x2C00             CMP      R4,#+0
   \   00000072   0xD102             BNE.N    ??ce_LoopPawn_7
   1362              loop_pos += 15;
   \   00000074   0xF105 0x000F      ADD      R0,R5,#+15
   \   00000078   0xE001             B.N      ??ce_LoopPawn_8
   1363            else
   1364              loop_pos -= 15;
   \                     ??ce_LoopPawn_7: (+1)
   \   0000007A   0xF1A5 0x000F      SUB      R0,R5,#+15
   1365            ce_LoopPawnSideCapture(loop_pos);
   \                     ??ce_LoopPawn_8: (+1)
   \   0000007E   0xB2C0             UXTB     R0,R0
   \   00000080   0x.... 0x....      BL       ce_LoopPawnSideCapture
   1366          
   1367          
   1368            loop_pos = initial_pos;
   1369            if ( my_color == COLOR_WHITE )
   \   00000084   0x2C00             CMP      R4,#+0
   \   00000086   0xD101             BNE.N    ??ce_LoopPawn_9
   1370              loop_pos += 17;
   \   00000088   0x3511             ADDS     R5,R5,#+17
   \   0000008A   0xE000             B.N      ??ce_LoopPawn_10
   1371            else
   1372              loop_pos -= 17;
   \                     ??ce_LoopPawn_9: (+1)
   \   0000008C   0x3D11             SUBS     R5,R5,#+17
   1373            ce_LoopPawnSideCapture(loop_pos);
   \                     ??ce_LoopPawn_10: (+1)
   \   0000008E   0x4628             MOV      R0,R5
   \   00000090   0xB2C0             UXTB     R0,R0
   \   00000092   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000096   0x....             B.N      ce_LoopPawnSideCapture
   1374          }
   1375          
   1376          /*==============================================================*/
   1377          /* attacked */
   1378          /*==============================================================*/
   1379          
   1380          /*
   1381            from a starting position, search for a piece, that might jump to that postion.
   1382            return:
   1383              the two global variables
   1384                lrc_obj.find_piece_weight[0];
   1385                lrc_obj.find_piece_weight[1];
   1386            will be increased by the weight of the attacked pieces of that color.
   1387            it is usually required to reset these global variables to zero, before using
   1388            this function.
   1389          */
   1390          

   \                                 In section .text, align 2, keep-with-next
   1391          void ce_FindPieceByStep(uint8_t start_pos, uint8_t piece, const uint8_t *d, uint8_t is_multi_step)
   1392          {
   \                     ce_FindPieceByStep: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461F             MOV      R7,R3
   \   0000000C   0xE005             B.N      ??ce_FindPieceByStep_0
   1393            uint8_t loop_pos, cp;
   1394            
   1395            /* with all directions */
   1396            for(;;)
   1397            {
   1398              if ( u8g_pgm_read(d) == 0 )
   1399                break;
   1400              
   1401              /* start again from the initial position */
   1402              loop_pos = start_pos;
   1403              
   1404              /* check direction */
   1405              do
   1406              {
   1407                /* check next position into one direction */
   1408                loop_pos += u8g_pgm_read(d);
   1409                
   1410                /* check if the board boundary has been crossed */
   1411                if ( (loop_pos & 0x088) != 0 )
   1412          	break;
   1413                
   1414                /* get the colored piece from the board */
   1415                cp = cp_GetFromBoard(loop_pos);
   1416                
   1417                /* stop if we had hit another piece */
   1418                if ( cp_GetPiece(cp) != PIECE_NONE )
   1419                {
   1420          	/* if it is the piece we are looking for, then add the weight */
   1421          	if ( cp_GetPiece(cp) == piece )
   1422          	{
   1423          	  lrc_obj.find_piece_weight[cp_GetColor(cp)] += ce_piece_weight[piece];
   1424          	  lrc_obj.find_piece_cnt[cp_GetColor(cp)]++;
   1425          	}
   1426          	/* in any case, break out of the inner loop */
   1427          	break;
   1428                }
   1429              } while( is_multi_step );
   1430              d++;
   1431            }
   1432          }
   \                     ??ce_FindPieceByStep_1: (+1)
   \   0000000E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??ce_FindPieceByStep_2: (+1)
   \   00000012   0x0038             MOVS     R0,R7
   \   00000014   0xD106             BNE.N    ??ce_FindPieceByStep_3
   \                     ??ce_FindPieceByStep_4: (+1)
   \   00000016   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??ce_FindPieceByStep_0: (+1)
   \   0000001A   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD0F5             BEQ.N    ??ce_FindPieceByStep_1
   \   00000022   0x46A9             MOV      R9,R5
   \                     ??ce_FindPieceByStep_3: (+1)
   \   00000024   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000028   0x4481             ADD      R9,R0,R9
   \   0000002A   0xF019 0x0F88      TST      R9,#0x88
   \   0000002E   0xD1F2             BNE.N    ??ce_FindPieceByStep_4
   \   00000030   0x4648             MOV      R0,R9
   \   00000032   0xB2C0             UXTB     R0,R0
   \   00000034   0x.... 0x....      BL       cp_GetFromBoard
   \   00000038   0x4604             MOV      R4,R0
   \   0000003A   0x.... 0x....      BL       cp_GetPiece
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD0E7             BEQ.N    ??ce_FindPieceByStep_2
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       cp_GetPiece
   \   00000048   0x4631             MOV      R1,R6
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD1E3             BNE.N    ??ce_FindPieceByStep_4
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       cp_GetColor
   \   00000054   0x.... 0x....      LDR.W    R9,??DataTable42
   \   00000058   0xEB09 0x0100      ADD      R1,R9,R0
   \   0000005C   0xF891 0x204D      LDRB     R2,[R1, #+77]
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable48
   \   00000064   0x4633             MOV      R3,R6
   \   00000066   0x5CC0             LDRB     R0,[R0, R3]
   \   00000068   0x1882             ADDS     R2,R0,R2
   \   0000006A   0xF881 0x204D      STRB     R2,[R1, #+77]
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       cp_GetColor
   \   00000074   0x4448             ADD      R0,R9,R0
   \   00000076   0xF890 0x104B      LDRB     R1,[R0, #+75]
   \   0000007A   0x1C49             ADDS     R1,R1,#+1
   \   0000007C   0xF880 0x104B      STRB     R1,[R0, #+75]
   \   00000080   0xE7C9             B.N      ??ce_FindPieceByStep_4
   1433          

   \                                 In section .text, align 2, keep-with-next
   1434          void ce_FindPawnPiece(uint8_t dest_pos, uint8_t color)
   1435          {
   \                     ce_FindPawnPiece: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   1436            uint8_t cp;
   1437            /* check if the board boundary has been crossed */
   1438            if ( (dest_pos & 0x088) == 0 )
   \   00000004   0xF010 0x0F88      TST      R0,#0x88
   \   00000008   0xD116             BNE.N    ??ce_FindPawnPiece_0
   1439            {
   1440              /* get the colored piece from the board */
   1441              cp = cp_GetFromBoard(dest_pos);
   \   0000000A   0x.... 0x....      BL       cp_GetFromBoard
   \   0000000E   0x4605             MOV      R5,R0
   1442              /* only if there is a pawn of the matching color */
   1443              if ( cp_GetPiece(cp) == PIECE_PAWN )
   \   00000010   0x.... 0x....      BL       cp_GetPiece
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD10F             BNE.N    ??ce_FindPawnPiece_0
   1444              {
   1445                if ( cp_GetColor(cp) == color )
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       cp_GetColor
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD109             BNE.N    ??ce_FindPawnPiece_0
   1446                {
   1447          	/* the weight of the PAWN */
   1448          	lrc_obj.find_piece_weight[color] += 1;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable52
   \   00000028   0x4420             ADD      R0,R0,R4
   \   0000002A   0x304B             ADDS     R0,R0,#+75
   \   0000002C   0x7881             LDRB     R1,[R0, #+2]
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \   00000030   0x7081             STRB     R1,[R0, #+2]
   1449          	lrc_obj.find_piece_cnt[color]++;
   \   00000032   0x7801             LDRB     R1,[R0, #+0]
   \   00000034   0x1C49             ADDS     R1,R1,#+1
   \   00000036   0x7001             STRB     R1,[R0, #+0]
   1450                }
   1451              }
   1452            }
   1453          }
   \                     ??ce_FindPawnPiece_0: (+1)
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1454          
   1455          
   1456          /*
   1457            find out, which pieces do attack a specified field
   1458            used to
   1459            - check if the KING can do castling
   1460            - check if the KING must move
   1461          
   1462            may be used in the eval procedure ... once...
   1463          
   1464            the result is stored in the global array
   1465              uint8_t lrc_obj.find_piece_weight[2];
   1466            which is indexed with the color.
   1467            lrc_obj.find_piece_weight[COLOR_WHITE] is the sum of all white pieces
   1468            which can directly move to this field.
   1469          
   1470            example:
   1471              if the black KING is at "pos" and lrc_obj.find_piece_weight[COLOR_WHITE] is not zero 
   1472              (after executing ce_CalculatePositionWeight(pos)) then the KING must be protected or moveed, because 
   1473              the KING was given check.
   1474          */
   1475          

   \                                 In section .text, align 4, keep-with-next
   1476          void ce_CalculatePositionWeight(uint8_t pos)
   1477          {
   \                     ce_CalculatePositionWeight: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1478            
   1479            lrc_obj.find_piece_weight[0] = 0;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable52_1
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
   1480            lrc_obj.find_piece_weight[1] = 0;
   \   0000000C   0x70C1             STRB     R1,[R0, #+3]
   1481            lrc_obj.find_piece_cnt[0] = 0;
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
   1482            lrc_obj.find_piece_cnt[1] = 0;
   \   00000010   0x7041             STRB     R1,[R0, #+1]
   1483            
   1484            if ( (pos & 0x088) != 0 )
   \   00000012   0xF014 0x0F88      TST      R4,#0x88
   \   00000016   0xD139             BNE.N    ??ce_CalculatePositionWeight_0
   1485              return;
   1486          
   1487            ce_FindPieceByStep(pos, PIECE_ROOK, ce_dir_offset_rook, 1);
   \   00000018   0xF05F 0x0301      MOVS.W   R3,#+1
   \   0000001C   0x....             ADR.N    R2,ce_dir_offset_rook
   \   0000001E   0x2104             MOVS     R1,#+4
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       ce_FindPieceByStep
   1488            ce_FindPieceByStep(pos, PIECE_BISHOP, ce_dir_offset_bishop, 1);
   \   00000026   0x2301             MOVS     R3,#+1
   \   00000028   0x....             ADR.N    R2,ce_dir_offset_bishop
   \   0000002A   0x2103             MOVS     R1,#+3
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       ce_FindPieceByStep
   1489            ce_FindPieceByStep(pos, PIECE_QUEEN, ce_dir_offset_queen, 1);
   \   00000032   0xBF00             Nop      
   \   00000034   0x....             ADR.N    R5,ce_dir_offset_queen
   \   00000036   0x2301             MOVS     R3,#+1
   \   00000038   0x462A             MOV      R2,R5
   \   0000003A   0x2105             MOVS     R1,#+5
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       ce_FindPieceByStep
   1490            ce_FindPieceByStep(pos, PIECE_KNIGHT, ce_dir_offset_knight, 0);
   \   00000042   0x2300             MOVS     R3,#+0
   \   00000044   0x....             ADR.N    R2,ce_dir_offset_knight
   \   00000046   0x2102             MOVS     R1,#+2
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       ce_FindPieceByStep
   1491            ce_FindPieceByStep(pos, PIECE_KING, ce_dir_offset_queen, 0);
   \   0000004E   0x2300             MOVS     R3,#+0
   \   00000050   0x462A             MOV      R2,R5
   \   00000052   0x2106             MOVS     R1,#+6
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       ce_FindPieceByStep
   1492          
   1493            ce_FindPawnPiece(pos+17, COLOR_BLACK);
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0xF104 0x0011      ADD      R0,R4,#+17
   \   00000060   0xB2C0             UXTB     R0,R0
   \   00000062   0x.... 0x....      BL       ce_FindPawnPiece
   1494            ce_FindPawnPiece(pos+15, COLOR_BLACK);
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0xF104 0x000F      ADD      R0,R4,#+15
   \   0000006C   0xB2C0             UXTB     R0,R0
   \   0000006E   0x.... 0x....      BL       ce_FindPawnPiece
   1495            ce_FindPawnPiece(pos-17, COLOR_WHITE);
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0xF1A4 0x0011      SUB      R0,R4,#+17
   \   00000078   0xB2C0             UXTB     R0,R0
   \   0000007A   0x.... 0x....      BL       ce_FindPawnPiece
   1496            ce_FindPawnPiece(pos-15, COLOR_WHITE);
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0xF1A4 0x000F      SUB      R0,R4,#+15
   \   00000084   0xB2C0             UXTB     R0,R0
   \   00000086   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000008A   0x....             B.N      ce_FindPawnPiece
   \                     ??ce_CalculatePositionWeight_0: (+1)
   \   0000008C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1497          }
   1498          
   1499          /*
   1500            calculate the summed weight of pieces with specified color which can move to a specified position
   1501          
   1502            argument:
   1503              pos: 	the position which should be analysed
   1504              color: 	the color of those pieces which should be analysed
   1505          		e.g. if a black piece is at 'pos' and 'color' is white then this procedure returns the white atting count
   1506          */

   \                                 In section .text, align 2, keep-with-next
   1507          uint8_t ce_GetPositionAttackWeight(uint8_t pos, uint8_t color)
   1508          {
   \                     ce_GetPositionAttackWeight: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   1509            ce_CalculatePositionWeight(pos);
   \   00000004   0x.... 0x....      BL       ce_CalculatePositionWeight
   1510            return lrc_obj.find_piece_weight[color];
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable52
   \   0000000C   0x4420             ADD      R0,R0,R4
   \   0000000E   0xF890 0x004D      LDRB     R0,[R0, #+77]
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
   1511          }
   1512          

   \                                 In section .text, align 2, keep-with-next
   1513          uint8_t ce_GetPositionAttackCount(uint8_t pos, uint8_t color)
   1514          {
   \                     ce_GetPositionAttackCount: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   1515            ce_CalculatePositionWeight(pos);
   \   00000004   0x.... 0x....      BL       ce_CalculatePositionWeight
   1516            return lrc_obj.find_piece_cnt[color];
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable52
   \   0000000C   0x4420             ADD      R0,R0,R4
   \   0000000E   0xF890 0x004B      LDRB     R0,[R0, #+75]
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
   1517          }
   1518          
   1519          
   1520          /*==============================================================*/
   1521          /* depth search starts here: loop over all pieces of the current color on the board */
   1522          /*==============================================================*/
   1523          

   \                                 In section .text, align 4, keep-with-next
   1524          void ce_LoopPieces(void)
   1525          {
   \                     ce_LoopPieces: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1526            stack_element_p e = stack_GetCurrElement();
   \   00000002   0x.... 0x....      BL       stack_GetCurrElement
   \   00000006   0x4604             MOV      R4,R0
   1527            /* start with lower left position (A1) */
   1528            e->current_pos = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x7020             STRB     R0,[R4, #+0]
   1529            do
   1530            {
   1531              e->current_cp = cp_GetFromBoard(e->current_pos);
   \                     ??ce_LoopPieces_1: (+1)
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       cp_GetFromBoard
   \   00000012   0x7060             STRB     R0,[R4, #+1]
   1532              /* check if the position on the board is empty */
   1533              if ( e->current_cp != 0 )
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD022             BEQ.N    ??ce_LoopPieces_2
   1534              {
   1535                /* only generate moves for the current color */
   1536                if ( e->current_color == cp_GetColor(e->current_cp) )
   \   00000018   0x.... 0x....      BL       cp_GetColor
   \   0000001C   0x78A1             LDRB     R1,[R4, #+2]
   \   0000001E   0x4281             CMP      R1,R0
   \   00000020   0xD11D             BNE.N    ??ce_LoopPieces_2
   1537                {
   1538          	chess_Thinking();
   \   00000022   0x.... 0x....      BL       chess_Thinking
   1539          	
   1540          	/* find out which piece is used */
   1541          	switch(cp_GetPiece(e->current_cp))
   \   00000026   0x7860             LDRB     R0,[R4, #+1]
   \   00000028   0x.... 0x....      BL       cp_GetPiece
   \   0000002C   0x1E40             SUBS     R0,R0,#+1
   \   0000002E   0x2805             CMP      R0,#+5
   \   00000030   0xD815             BHI.N    ??ce_LoopPieces_2
   \   00000032   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??ce_LoopPieces_0:
   \   00000036   0x03 0x06          DC8      0x3,0x6,0x9,0xC
   \              0x09 0x0C    
   \   0000003A   0x0F 0x12          DC8      0xF,0x12
   1542          	{
   1543          	  case PIECE_NONE:
   1544          	    break;
   1545          	  case PIECE_PAWN:
   1546          	    ce_LoopPawn();
   \                     ??ce_LoopPieces_3: (+1)
   \   0000003C   0x.... 0x....      BL       ce_LoopPawn
   1547          	    break;
   \   00000040   0xE00D             B.N      ??ce_LoopPieces_2
   1548          	  case PIECE_KNIGHT:
   1549          	    ce_LoopKnight();
   \                     ??ce_LoopPieces_4: (+1)
   \   00000042   0x.... 0x....      BL       ce_LoopKnight
   1550          	    break;
   \   00000046   0xE00A             B.N      ??ce_LoopPieces_2
   1551          	  case PIECE_BISHOP:
   1552          	    ce_LoopBishop();
   \                     ??ce_LoopPieces_5: (+1)
   \   00000048   0x.... 0x....      BL       ce_LoopBishop
   1553          	    break;
   \   0000004C   0xE007             B.N      ??ce_LoopPieces_2
   1554          	  case PIECE_ROOK:
   1555          	    ce_LoopRook();
   \                     ??ce_LoopPieces_6: (+1)
   \   0000004E   0x.... 0x....      BL       ce_LoopRook
   1556          	    break;
   \   00000052   0xE004             B.N      ??ce_LoopPieces_2
   1557          	  case PIECE_QUEEN:
   1558          	    ce_LoopQueen();
   \                     ??ce_LoopPieces_7: (+1)
   \   00000054   0x.... 0x....      BL       ce_LoopQueen
   1559          	    break;
   \   00000058   0xE001             B.N      ??ce_LoopPieces_2
   1560          	  case PIECE_KING:
   1561          	    ce_LoopKing();
   \                     ??ce_LoopPieces_8: (+1)
   \   0000005A   0x.... 0x....      BL       ce_LoopKing
   1562          	    break;
   1563          	}
   1564                }
   1565              }    
   1566              e->current_pos = cu_NextPos(e->current_pos);
   \                     ??ce_LoopPieces_2: (+1)
   \   0000005E   0x7820             LDRB     R0,[R4, #+0]
   \   00000060   0x.... 0x....      BL       cu_NextPos
   \   00000064   0x7020             STRB     R0,[R4, #+0]
   1567            } while( e->current_pos != 0 );
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD1D0             BNE.N    ??ce_LoopPieces_1
   1568          }
   \   0000006A   0xBD10             POP      {R4,PC}          ;; return
   1569          
   1570          /*==============================================================*/
   1571          /* user interface */
   1572          /*==============================================================*/
   1573          
   1574          /*
   1575          eval_t chess_EvalCurrBoard(uint8_t color)
   1576          {
   1577            stack_Init(0);
   1578            stack_GetCurrElement()->current_color = color;
   1579            ce_LoopPieces();
   1580            return stack_GetCurrElement()->best_eval;
   1581          }
   1582          */
   1583          
   1584          /* clear any marks on the board */

   \                                 In section .text, align 2, keep-with-next
   1585          void chess_ClearMarks(void)
   1586          {
   1587            uint8_t i;
   1588            for( i = 0; i < 64; i++ )
   \                     chess_ClearMarks: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE007             B.N      ??chess_ClearMarks_0
   1589               lrc_obj.board[i] &= ~CP_MARK_MASK;
   \                     ??chess_ClearMarks_1: (+1)
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable52
   \   00000008   0x4401             ADD      R1,R1,R0
   \   0000000A   0x788A             LDRB     R2,[R1, #+2]
   \   0000000C   0xF002 0x02DF      AND      R2,R2,#0xDF
   \   00000010   0x708A             STRB     R2,[R1, #+2]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \                     ??chess_ClearMarks_0: (+1)
   \   00000014   0x2840             CMP      R0,#+64
   \   00000016   0xDBF5             BLT.N    ??chess_ClearMarks_1
   1590          }
   \   00000018   0x4770             BX       LR               ;; return
   1591          
   1592          /*
   1593            Mark all pieces which can do moves. This is done by setting flags on the global board
   1594          */

   \                                 In section .text, align 2, keep-with-next
   1595          void chess_MarkMovable(void)
   1596          {
   \                     chess_MarkMovable: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1597            stack_Init(0);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       stack_Init
   1598            //stack_GetCurrElement()->current_color = color;
   1599            lrc_obj.check_mode = CHECK_MODE_MOVEABLE;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable52
   \   0000000E   0xF881 0x004A      STRB     R0,[R1, #+74]
   1600            ce_LoopPieces();
   \   00000012   0xE8BD 0x4001      POP      {R0,LR}
   \   00000016   0x....             B.N      ce_LoopPieces
   1601          }
   1602          
   1603          /*
   1604            Checks, if the piece can move from src_pos to dest_pos
   1605          
   1606            src_pos: The game position of a piece on the chess board
   1607          */

   \                                 In section .text, align 2, keep-with-next
   1608          void chess_MarkTargetMoves(uint8_t src_pos)
   1609          {
   \                     chess_MarkTargetMoves: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1610            stack_Init(0);
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       stack_Init
   1611            stack_GetCurrElement()->current_color = cp_GetColor(cp_GetFromBoard(src_pos));
   \   0000000A   0x.... 0x....      BL       stack_GetCurrElement
   \   0000000E   0x4605             MOV      R5,R0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       cp_GetFromBoard
   \   00000016   0x.... 0x....      BL       cp_GetColor
   \   0000001A   0x70A8             STRB     R0,[R5, #+2]
   1612            lrc_obj.check_src_pos = src_pos;
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable51
   \   00000020   0x7004             STRB     R4,[R0, #+0]
   1613            lrc_obj.check_mode = CHECK_MODE_TARGET_MOVE;  
   \   00000022   0x2102             MOVS     R1,#+2
   \   00000024   0x7041             STRB     R1,[R0, #+1]
   1614            ce_LoopPieces();
   \   00000026   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000002A   0x....             B.N      ce_LoopPieces
   1615          }
   1616          
   1617          /*
   1618            first call should start with 255
   1619            this procedure will return 255 if 
   1620                - there are no marks at all
   1621                - it has looped over all marks once
   1622          */

   \                                 In section .text, align 2, keep-with-next
   1623          uint8_t chess_GetNextMarked(uint8_t arg, uint8_t is_prev)
   1624          {
   \                     chess_GetNextMarked: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1625            uint8_t i;
   1626            uint8_t pos = arg;
   \   00000006   0x4626             MOV      R6,R4
   1627            for(i = 0; i < 64; i++)
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xE000             B.N      ??chess_GetNextMarked_0
   \                     ??chess_GetNextMarked_1: (+1)
   \   0000000C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??chess_GetNextMarked_0: (+1)
   \   0000000E   0x4638             MOV      R0,R7
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x2840             CMP      R0,#+64
   \   00000014   0xDA15             BGE.N    ??chess_GetNextMarked_2
   1628            {
   1629              if ( is_prev != 0 )
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x4630             MOV      R0,R6
   \   0000001A   0xD003             BEQ.N    ??chess_GetNextMarked_3
   1630                pos = cu_PrevPos(pos);
   \   0000001C   0x.... 0x....      BL       cu_PrevPos
   \   00000020   0x4606             MOV      R6,R0
   \   00000022   0xE002             B.N      ??chess_GetNextMarked_4
   1631              else
   1632                pos = cu_NextPos(pos);
   \                     ??chess_GetNextMarked_3: (+1)
   \   00000024   0x.... 0x....      BL       cu_NextPos
   \   00000028   0x4606             MOV      R6,R0
   1633              if ( arg != 255 && pos == 0 )
   \                     ??chess_GetNextMarked_4: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x28FF             CMP      R0,#+255
   \   0000002E   0xD001             BEQ.N    ??chess_GetNextMarked_5
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0xD006             BEQ.N    ??chess_GetNextMarked_2
   1634                return 255;
   1635              if ( cp_IsMarked(cp_GetFromBoard(pos)) )
   \                     ??chess_GetNextMarked_5: (+1)
   \   00000034   0x4630             MOV      R0,R6
   \   00000036   0x.... 0x....      BL       cp_GetFromBoard
   \   0000003A   0x0680             LSLS     R0,R0,#+26
   \   0000003C   0xD5E6             BPL.N    ??chess_GetNextMarked_1
   1636                return pos;
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}
   1637            }
   1638            return 255;
   \                     ??chess_GetNextMarked_2: (+1)
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1639          }
   1640          
   1641          
   1642          /* make a manual move: this is a little bit more than cu_Move() */

   \                                 In section .text, align 2, keep-with-next
   1643          void chess_ManualMove(uint8_t src, uint8_t dest)
   1644          {
   \                     chess_ManualMove: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   1645            uint8_t cp;
   1646            
   1647            /* printf("chess_ManualMove %02x -> %02x\n", src, dest); */
   1648            
   1649            /* if all other things fail, this is the place where the game is to be decided: */
   1650            /* ... if the KING is captured */
   1651            cp = cp_GetFromBoard(dest);
   \   00000008   0x4630             MOV      R0,R6
   \   0000000A   0x.... 0x....      BL       cp_GetFromBoard
   \   0000000E   0x4607             MOV      R7,R0
   1652            if ( cp_GetPiece(cp) == PIECE_KING )
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable52
   \   00000014   0x.... 0x....      BL       cp_GetPiece
   \   00000018   0x2806             CMP      R0,#+6
   \   0000001A   0xD109             BNE.N    ??chess_ManualMove_0
   1653            {
   1654              lrc_obj.is_game_end = 1;
   \   0000001C   0xF104 0x0847      ADD      R8,R4,#+71
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF888 0x0000      STRB     R0,[R8, #+0]
   1655              lrc_obj.lost_side_color = cp_GetColor(cp);    
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0x.... 0x....      BL       cp_GetColor
   \   0000002C   0xF888 0x0001      STRB     R0,[R8, #+1]
   1656            }
   1657          
   1658            /* clear ply history here, to avoid memory overflow */
   1659            /* may be the last X moves can be kept here */
   1660            cu_ReduceHistoryByFullMove();
   \                     ??chess_ManualMove_0: (+1)
   \   00000030   0x.... 0x....      BL       cu_ReduceHistoryByFullMove
   1661            /* perform the move on the board */
   1662            cu_Move(src, dest);
   \   00000034   0x4631             MOV      R1,R6
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       cu_Move
   1663            
   1664            /* update en passant double move positions: en passant position is removed after two half moves  */
   1665            lrc_obj.pawn_dbl_move[lrc_obj.ply_count&1]  = ILLEGAL_POSITION;
   \   0000003C   0x7820             LDRB     R0,[R4, #+0]
   \   0000003E   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000042   0x4420             ADD      R0,R4,R0
   \   00000044   0x21FF             MOVS     R1,#+255
   \   00000046   0xF880 0x1042      STRB     R1,[R0, #+66]
   1666            
   1667            /* update the global half move counter */
   1668            lrc_obj.ply_count++;
   \   0000004A   0x7820             LDRB     R0,[R4, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x7020             STRB     R0,[R4, #+0]
   1669          
   1670          
   1671            /* make a small check about the end of the game */
   1672            /* use at least depth 1, because we must know if the king can still move */
   1673            /* this is: King moves at level 0 and will be captured at level 1 */
   1674            /* so we check if the king can move and will not be captured at search level 1 */
   1675            
   1676            stack_Init(1);
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x.... 0x....      BL       stack_Init
   1677            ce_LoopPieces(); 
   \   00000056   0x.... 0x....      BL       ce_LoopPieces
   1678          
   1679            /* printf("chess_ManualMove/analysis best_from_pos %02x -> best_to_pos %02x\n", stack_GetCurrElement()->best_from_pos, stack_GetCurrElement()->best_to_pos); */
   1680          
   1681            /* analyse the eval result */
   1682            
   1683            /* check if the other player has any moves left */
   1684            if ( stack_GetCurrElement()->best_from_pos == ILLEGAL_POSITION )
   \   0000005A   0x.... 0x....      BL       stack_GetCurrElement
   \   0000005E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000060   0x28FF             CMP      R0,#+255
   \   00000062   0xD115             BNE.N    ??chess_ManualMove_1
   1685            {
   1686              uint8_t color;
   1687              /* conditions: */
   1688              /* 1. no King, should never happen, opposite color has won */
   1689              /*		this is already checked above at the beginning if this procedure */
   1690              /* 2. King is under attack, opposite color has won */
   1691              /* 3. King is not under attack, game is a draw */
   1692          
   1693              uint8_t i = 0;
   \   00000064   0x2600             MOVS     R6,#+0
   1694              color = lrc_obj.ply_count;
   1695              color &= 1;
   \   00000066   0x7827             LDRB     R7,[R4, #+0]
   \   00000068   0xF007 0x0701      AND      R7,R7,#0x1
   1696              do
   1697              {
   1698                cp = cp_GetFromBoard(i);
   \                     ??chess_ManualMove_2: (+1)
   \   0000006C   0x4630             MOV      R0,R6
   \   0000006E   0x.... 0x....      BL       cp_GetFromBoard
   \   00000072   0x4605             MOV      R5,R0
   1699                /* look for the King */
   1700                if ( cp_GetPiece(cp) == PIECE_KING )
   \   00000074   0x.... 0x....      BL       cp_GetPiece
   \   00000078   0x2806             CMP      R0,#+6
   \   0000007A   0xD104             BNE.N    ??chess_ManualMove_3
   1701                {
   1702          	if ( cp_GetColor(cp) == color )
   \   0000007C   0x4628             MOV      R0,R5
   \   0000007E   0x.... 0x....      BL       cp_GetColor
   \   00000082   0x42B8             CMP      R0,R7
   \   00000084   0xD006             BEQ.N    ??chess_ManualMove_4
   1703          	{
   1704          	  /* check if  KING is attacked */
   1705          	  if ( ce_GetPositionAttackCount(i, color^1) != 0 )
   1706          	  {
   1707          	    /* KING is under attack (check) and can not move: Game is lost */
   1708          	    lrc_obj.is_game_end = 1;
   1709          	    lrc_obj.lost_side_color = color; 
   1710          	  }
   1711          	  else
   1712          	  {
   1713          	    /* KING is NOT under attack (check) but can not move: Game is a draw */
   1714          	    lrc_obj.is_game_end = 1;
   1715          	    lrc_obj.lost_side_color = 2; 
   1716          	  }
   1717          	  /* break out of the loop */
   1718          	  break;	  
   1719          	}
   1720                }
   1721                i = cu_NextPos(i);
   \                     ??chess_ManualMove_3: (+1)
   \   00000086   0x4630             MOV      R0,R6
   \   00000088   0x.... 0x....      BL       cu_NextPos
   \   0000008C   0x0006             MOVS     R6,R0
   1722              } while( i != 0 );
   \   0000008E   0xD1ED             BNE.N    ??chess_ManualMove_2
   1723            }
   1724          }
   \                     ??chess_ManualMove_1: (+1)
   \   00000090   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
   \                     ??chess_ManualMove_4: (+1)
   \   00000094   0x3447             ADDS     R4,R4,#+71
   \   00000096   0xF087 0x0101      EOR      R1,R7,#0x1
   \   0000009A   0x4630             MOV      R0,R6
   \   0000009C   0x.... 0x....      BL       ce_GetPositionAttackCount
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD003             BEQ.N    ??chess_ManualMove_5
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x7020             STRB     R0,[R4, #+0]
   \   000000A8   0x7067             STRB     R7,[R4, #+1]
   \   000000AA   0xE7F1             B.N      ??chess_ManualMove_1
   \                     ??chess_ManualMove_5: (+1)
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x7020             STRB     R0,[R4, #+0]
   \   000000B0   0x2002             MOVS     R0,#+2
   \   000000B2   0x7060             STRB     R0,[R4, #+1]
   \   000000B4   0xE7EC             B.N      ??chess_ManualMove_1
   1725          
   1726          /* let the computer do a move */

   \                                 In section .text, align 2, keep-with-next
   1727          void chess_ComputerMove(uint8_t depth)
   1728          {
   \                     chess_ComputerMove: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1729            stack_Init(depth);
   \   00000002   0x.... 0x....      BL       stack_Init
   1730            
   1731            //stack_GetCurrElement()->current_color = lrc_obj.ply_count;
   1732            //stack_GetCurrElement()->current_color &= 1;
   1733            
   1734            cu_ReduceHistoryByFullMove();
   \   00000006   0x.... 0x....      BL       cu_ReduceHistoryByFullMove
   1735            ce_LoopPieces();
   \   0000000A   0x.... 0x....      BL       ce_LoopPieces
   1736          
   1737            chess_ManualMove(stack_GetCurrElement()->best_from_pos, stack_GetCurrElement()->best_to_pos);
   \   0000000E   0x.... 0x....      BL       stack_GetCurrElement
   \   00000012   0x4604             MOV      R4,R0
   \   00000014   0x.... 0x....      BL       stack_GetCurrElement
   \   00000018   0x7921             LDRB     R1,[R4, #+4]
   \   0000001A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000001C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000020   0x....             B.N      chess_ManualMove
   1738          }
   1739          
   1740          
   1741          /*==============================================================*/
   1742          /* unix code */
   1743          /*==============================================================*/
   1744          
   1745          #ifdef UNIX_MAIN
   1746          
   1747          #include <stdio.h>
   1748          #include <string.h>
   1749          
   1750          char *piece_str[] = {
   1751            /* 0x00 */
   1752            "  ", 
   1753            "wP", 
   1754            "wN", 
   1755            "wB", 
   1756            
   1757            /* 0x04 */
   1758            "wR", 
   1759            "wQ", 
   1760            "wK", 
   1761            "w?", 
   1762          
   1763            /* 0x08 */
   1764            "w?", 
   1765            "w?", 
   1766            "w?", 
   1767            "w?", 
   1768            
   1769            /* 0x0c */
   1770            "w?", 
   1771            "w?", 
   1772            "w?", 
   1773            "w?", 
   1774          
   1775            /* 0x10 */
   1776            "b ",
   1777            "bP", 
   1778            "bN", 
   1779            "bB", 
   1780            "bR", 
   1781            "bQ", 
   1782            "bK", 
   1783            "b?", 
   1784          
   1785            "b?", 
   1786            "b?", 
   1787            "b?", 
   1788            "b?", 
   1789            "b?", 
   1790            "b?", 
   1791            "b?", 
   1792            "b?"
   1793          };
   1794          
   1795          void chess_Thinking(void)
   1796          {
   1797            uint8_t i;
   1798            uint8_t cp = cp_GetPiece(stack_GetCurrElement()->current_cp);
   1799            
   1800            printf("Thinking:  ", piece_str[cp], stack_GetCurrElement()->current_pos);
   1801            
   1802            for( i = 0; i <= lrc_obj.curr_depth; i++ )
   1803              printf("%s ", piece_str[(lrc_obj.stack_memory+i)->current_cp]);
   1804            
   1805            printf("    \r");
   1806          }
   1807          
   1808          void board_Show(void)
   1809          {
   1810            uint8_t i, j, cp;
   1811            char buf[10];
   1812            for ( i = 0; i < 8; i++ )
   1813            {
   1814              printf("%1d ", 7-i);
   1815              for ( j = 0; j < 8; j++ )
   1816              {
   1817                /* get piece from global board */
   1818                cp = lrc_obj.board[(7-i)*8+j];
   1819                strcpy(buf, piece_str[cp&COLOR_PIECE_MASK]);
   1820                
   1821                if ( (cp & CP_MARK_MASK) != 0 )
   1822                {
   1823          	buf[0] = '#';
   1824                }
   1825                
   1826                /* mask out any bits except color and piece index */
   1827                cp &= COLOR_PIECE_MASK;
   1828                printf("%s %02x ", buf, cp);
   1829                
   1830              }
   1831              printf("\n");
   1832            }
   1833          }
   1834          
   1835          int main(void)
   1836          {
   1837            uint8_t depth = 3;
   1838            chess_SetupBoard();
   1839            board_Show();
   1840            puts("");
   1841              
   1842           
   1843           /* 
   1844            chess_ClearMarks();
   1845            chess_MarkMovable(COLOR_WHITE);
   1846            board_Show();
   1847            */
   1848            
   1849            chess_ManualMove(0x006, 0x066);
   1850            
   1851            printf("lrc_obj.is_game_end: %d\n" , lrc_obj.is_game_end);
   1852            printf("lrc_obj.lost_side_color: %d\n" , lrc_obj.lost_side_color);
   1853          
   1854            chess_ComputerMove(2);
   1855          
   1856            printf("lrc_obj.is_game_end: %d\n" , lrc_obj.is_game_end);
   1857            printf("lrc_obj.lost_side_color: %d\n" , lrc_obj.lost_side_color);
   1858            
   1859            board_Show();
   1860          
   1861          }
   1862          
   1863          
   1864          
   1865          #else
   1866          
   1867          /*==============================================================*/
   1868          /* display menu */
   1869          /*==============================================================*/
   1870          
   1871          //#define MNU_FONT font_5x7
   1872          #define MNU_FONT u8g_font_5x8r
   1873          //#define MNU_FONT font_6x9
   1874          #define MNU_ENTRY_HEIGHT 9
   1875          
   1876          char *mnu_title = "Little Rook Chess";
   1877          char *mnu_list[] = { "New Game (White)", "New Game (Black)", "Undo Move", "Return" };
   1878          uint8_t mnu_pos = 0;
   1879          uint8_t mnu_max = 4;
   1880          

   \                                 In section .text, align 2, keep-with-next
   1881          void mnu_DrawHome(uint8_t is_highlight)
   1882          {
   \                     mnu_DrawHome: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1883            uint8_t x = lrc_u8g->width - 35;  
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable52_2
   \   00000008   0x68E8             LDR      R0,[R5, #+12]
   \   0000000A   0x7801             LDRB     R1,[R0, #+0]
   \   0000000C   0xF1A1 0x0623      SUB      R6,R1,#+35
   1884            uint8_t y = (lrc_u8g->height-1);
   \   00000010   0x7847             LDRB     R7,[R0, #+1]
   \   00000012   0x1E7F             SUBS     R7,R7,#+1
   1885            uint8_t t;
   1886            
   1887            u8g_SetFont(lrc_u8g, u8g_font_5x7r);
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable52_3
   \   00000018   0x.... 0x....      BL       u8g_SetFont
   1888            u8g_SetDefaultForegroundColor(lrc_u8g);
   \   0000001C   0x68E8             LDR      R0,[R5, #+12]
   \   0000001E   0x.... 0x....      BL       u8g_SetDefaultForegroundColor
   1889            t = u8g_DrawStrP(lrc_u8g, x, y -1, U8G_PSTR("Options"));
   \   00000022   0x.... 0x....      ADR.W    R3,?_5
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0x1E42             SUBS     R2,R0,#+1
   \   0000002A   0xB2D2             UXTB     R2,R2
   \   0000002C   0x4631             MOV      R1,R6
   \   0000002E   0xB2C9             UXTB     R1,R1
   \   00000030   0x68E8             LDR      R0,[R5, #+12]
   \   00000032   0x.... 0x....      BL       u8g_DrawStrP
   \   00000036   0x4603             MOV      R3,R0
   1890              
   1891            if ( is_highlight )
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD009             BEQ.N    ??mnu_DrawHome_0
   1892              u8g_DrawFrame(lrc_u8g, x-1, y - MNU_ENTRY_HEIGHT +1, t, MNU_ENTRY_HEIGHT);  
   \   0000003C   0x2009             MOVS     R0,#+9
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0xF1A7 0x0208      SUB      R2,R7,#+8
   \   00000044   0xB2D2             UXTB     R2,R2
   \   00000046   0x1E71             SUBS     R1,R6,#+1
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x68E8             LDR      R0,[R5, #+12]
   \   0000004C   0x.... 0x....      BL       u8g_DrawFrame
   1893          }
   \                     ??mnu_DrawHome_0: (+1)
   \   00000050   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1894          

   \                                 In section .text, align 2, keep-with-next
   1895          void mnu_DrawEntry(uint8_t y, char *str, uint8_t is_clr_background, uint8_t is_highlight)
   1896          {
   \                     mnu_DrawEntry: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x461C             MOV      R4,R3
   1897            uint8_t t, x;
   1898            u8g_SetFont(lrc_u8g, MNU_FONT);
   \   0000000C   0x.... 0x....      LDR.W    R7,??DataTable52_2
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable52_4
   \   00000014   0x68F8             LDR      R0,[R7, #+12]
   \   00000016   0x.... 0x....      BL       u8g_SetFont
   1899            t = u8g_GetStrWidth(lrc_u8g, str);
   \   0000001A   0x4631             MOV      R1,R6
   \   0000001C   0x68F8             LDR      R0,[R7, #+12]
   \   0000001E   0x.... 0x....      BL       u8g_GetStrWidth
   \   00000022   0x4680             MOV      R8,R0
   1900            x = u8g_GetWidth(lrc_u8g);
   1901            x -= t;
   1902            x >>= 1;
   \   00000024   0x68F8             LDR      R0,[R7, #+12]
   \   00000026   0xF890 0x9000      LDRB     R9,[R0, #+0]
   \   0000002A   0xEBA9 0x0908      SUB      R9,R9,R8
   \   0000002E   0xFA5F 0xF989      UXTB     R9,R9
   \   00000032   0xEA4F 0x0959      LSR      R9,R9,#+1
   1903            
   1904            if ( is_clr_background )
   \   00000036   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000003A   0xD012             BEQ.N    ??mnu_DrawEntry_0
   1905            {
   1906              u8g_SetDefaultBackgroundColor(lrc_u8g);
   \   0000003C   0x.... 0x....      BL       u8g_SetDefaultBackgroundColor
   1907              u8g_DrawBox(lrc_u8g, x-3, (lrc_u8g->height-1) - (y+MNU_ENTRY_HEIGHT-1+2), t+5, MNU_ENTRY_HEIGHT+4);
   \   00000040   0x68F8             LDR      R0,[R7, #+12]
   \   00000042   0x210D             MOVS     R1,#+13
   \   00000044   0x9100             STR      R1,[SP, #+0]
   \   00000046   0xF108 0x0305      ADD      R3,R8,#+5
   \   0000004A   0xB2DB             UXTB     R3,R3
   \   0000004C   0x7841             LDRB     R1,[R0, #+1]
   \   0000004E   0x1E49             SUBS     R1,R1,#+1
   \   00000050   0x1B49             SUBS     R1,R1,R5
   \   00000052   0xF1A1 0x020A      SUB      R2,R1,#+10
   \   00000056   0xB2D2             UXTB     R2,R2
   \   00000058   0xF1A9 0x0103      SUB      R1,R9,#+3
   \   0000005C   0xB2C9             UXTB     R1,R1
   \   0000005E   0x.... 0x....      BL       u8g_DrawBox
   1908            }
   1909            
   1910            u8g_SetDefaultForegroundColor(lrc_u8g);
   \                     ??mnu_DrawEntry_0: (+1)
   \   00000062   0x68F8             LDR      R0,[R7, #+12]
   \   00000064   0x.... 0x....      BL       u8g_SetDefaultForegroundColor
   1911            u8g_DrawStr(lrc_u8g, x, (lrc_u8g->height-1) - y, str);
   \   00000068   0x68F8             LDR      R0,[R7, #+12]
   \   0000006A   0x4633             MOV      R3,R6
   \   0000006C   0x7841             LDRB     R1,[R0, #+1]
   \   0000006E   0x1E4A             SUBS     R2,R1,#+1
   \   00000070   0x1B52             SUBS     R2,R2,R5
   \   00000072   0xB2D2             UXTB     R2,R2
   \   00000074   0x4649             MOV      R1,R9
   \   00000076   0x.... 0x....      BL       u8g_DrawStr
   1912            
   1913            if ( is_highlight )
   \   0000007A   0x2C00             CMP      R4,#+0
   \   0000007C   0xD00E             BEQ.N    ??mnu_DrawEntry_1
   1914            {
   1915              u8g_DrawFrame(lrc_u8g, x-1, (lrc_u8g->height-1) - y -MNU_ENTRY_HEIGHT +1, t, MNU_ENTRY_HEIGHT);
   \   0000007E   0x68F8             LDR      R0,[R7, #+12]
   \   00000080   0x2109             MOVS     R1,#+9
   \   00000082   0x9100             STR      R1,[SP, #+0]
   \   00000084   0x4643             MOV      R3,R8
   \   00000086   0x7841             LDRB     R1,[R0, #+1]
   \   00000088   0x1E49             SUBS     R1,R1,#+1
   \   0000008A   0x1B4D             SUBS     R5,R1,R5
   \   0000008C   0xF1A5 0x0208      SUB      R2,R5,#+8
   \   00000090   0xB2D2             UXTB     R2,R2
   \   00000092   0xF1A9 0x0101      SUB      R1,R9,#+1
   \   00000096   0xB2C9             UXTB     R1,R1
   \   00000098   0x.... 0x....      BL       u8g_DrawFrame
   1916            }
   1917          }
   \                     ??mnu_DrawEntry_1: (+1)
   \   0000009C   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
   1918          

   \                                 In section .text, align 2, keep-with-next
   1919          void mnu_Draw(void)
   1920          {
   \                     mnu_Draw: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1921            uint8_t i;
   1922            uint8_t t,y;
   1923            /* calculate hight of the complete menu */
   1924            y = mnu_max;
   1925            y++; 					/* consider also some space for the title */
   1926            y++; 					/* consider also some space for the title */
   1927            y *= MNU_ENTRY_HEIGHT;
   1928            
   1929            /* calculate how much space will be left */
   1930            t = u8g_GetHeight(lrc_u8g);			
   1931            t -= y;
   1932            
   1933            /* topmost pos start half of that empty space from the top */
   1934            t >>= 1;
   1935            y = u8g_GetHeight(lrc_u8g);
   1936            y -= t;
   1937            
   1938            y -= MNU_ENTRY_HEIGHT;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable52_2
   \   00000006   0x68E0             LDR      R0,[R4, #+12]
   \   00000008   0x7840             LDRB     R0,[R0, #+1]
   \   0000000A   0x7861             LDRB     R1,[R4, #+1]
   \   0000000C   0x1C89             ADDS     R1,R1,#+2
   \   0000000E   0xEB01 0x01C1      ADD      R1,R1,R1, LSL #+3
   \   00000012   0x1A41             SUBS     R1,R0,R1
   \   00000014   0xB2C9             UXTB     R1,R1
   \   00000016   0xEBA0 0x0051      SUB      R0,R0,R1, LSR #+1
   \   0000001A   0xF1A0 0x0509      SUB      R5,R0,#+9
   1939            mnu_DrawEntry(y, mnu_title, 0, 0);
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x461A             MOV      R2,R3
   \   00000022   0x6921             LDR      R1,[R4, #+16]
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x.... 0x....      BL       mnu_DrawEntry
   1940            
   1941            y -= MNU_ENTRY_HEIGHT;
   \   0000002C   0x3D09             SUBS     R5,R5,#+9
   1942            
   1943            
   1944            for( i = 0; i < mnu_max; i++ )
   \   0000002E   0x2600             MOVS     R6,#+0
   \                     ??mnu_Draw_0: (+1)
   \   00000030   0x7860             LDRB     R0,[R4, #+1]
   \   00000032   0x4286             CMP      R6,R0
   \   00000034   0xDA11             BGE.N    ??mnu_Draw_1
   1945            {
   1946              y -= MNU_ENTRY_HEIGHT;
   \   00000036   0x3D09             SUBS     R5,R5,#+9
   1947              mnu_DrawEntry(y, mnu_list[i], 0, i == mnu_pos);
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x4286             CMP      R6,R0
   \   0000003C   0xD001             BEQ.N    ??mnu_Draw_2
   \   0000003E   0x2300             MOVS     R3,#+0
   \   00000040   0xE000             B.N      ??mnu_Draw_3
   \                     ??mnu_Draw_2: (+1)
   \   00000042   0x2301             MOVS     R3,#+1
   \                     ??mnu_Draw_3: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0xEB04 0x0086      ADD      R0,R4,R6, LSL #+2
   \   0000004A   0x6941             LDR      R1,[R0, #+20]
   \   0000004C   0x4628             MOV      R0,R5
   \   0000004E   0xB2C0             UXTB     R0,R0
   \   00000050   0x.... 0x....      BL       mnu_DrawEntry
   1948            }
   \   00000054   0x1C76             ADDS     R6,R6,#+1
   \   00000056   0xB2F6             UXTB     R6,R6
   \   00000058   0xE7EA             B.N      ??mnu_Draw_0
   1949          }
   \                     ??mnu_Draw_1: (+1)
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
   1950          

   \                                 In section .text, align 2, keep-with-next
   1951          void mnu_Step(uint8_t key_cmd)
   1952          {
   1953              if ( key_cmd == CHESS_KEY_NEXT )
   \                     mnu_Step: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD10A             BNE.N    ??mnu_Step_0
   1954              {
   1955                if ( mnu_pos+1 < mnu_max )
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable52_2
   \   00000008   0x7801             LDRB     R1,[R0, #+0]
   \   0000000A   0x460A             MOV      R2,R1
   \   0000000C   0x1C52             ADDS     R2,R2,#+1
   \   0000000E   0x7843             LDRB     R3,[R0, #+1]
   \   00000010   0x429A             CMP      R2,R3
   \   00000012   0xDA0B             BGE.N    ??mnu_Step_1
   1956          	mnu_pos++;
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0x7001             STRB     R1,[R0, #+0]
   \   00000018   0x4770             BX       LR
   1957              }
   1958              else if ( key_cmd == CHESS_KEY_PREV )
   \                     ??mnu_Step_0: (+1)
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD106             BNE.N    ??mnu_Step_1
   1959              {
   1960                if ( mnu_pos > 0 )
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable52_2
   \   00000022   0x7808             LDRB     R0,[R1, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??mnu_Step_1
   1961          	mnu_pos--;
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
   1962              }
   1963          }
   \                     ??mnu_Step_1: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
   1964          
   1965          
   1966          
   1967          
   1968          uint8_t chess_key_code = 0;
   1969          uint8_t chess_key_cmd = 0;
   1970          #define CHESS_STATE_MENU 0
   1971          #define CHESS_STATE_SELECT_START 1
   1972          #define CHESS_STATE_SELECT_PIECE 2
   1973          #define CHESS_STATE_SELECT_TARGET_POS 3
   1974          #define CHESS_STATE_THINKING 4
   1975          #define CHESS_STATE_GAME_END 5
   1976          uint8_t chess_state = CHESS_STATE_MENU;
   1977          uint8_t chess_source_pos = 255;
   1978          uint8_t chess_target_pos = 255;
   1979          

   \                                 In section .text, align 4, keep-with-next
   1980          const uint8_t chess_pieces_body_bm[] PROGMEM = 
   \                     chess_pieces_body_bm:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 28, 44, 4, 4, 14, 0, 0, 0, 28, 28
   \              0x00 0x18    
   \              0x18 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x1C 0x2C    
   \              0x04 0x04    
   \              0x0E 0x00    
   \              0x00 0x00    
   \              0x1C 0x1C    
   \   00000014   0x1C 0x08          DC8 28, 8, 0, 0, 0, 0, 0, 28, 28, 28, 28, 0, 0, 0, 20, 28, 8, 28, 8, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x1C    
   \              0x1C 0x1C    
   \              0x1C 0x00    
   \              0x00 0x00    
   \              0x14 0x1C    
   \              0x08 0x1C    
   \              0x08 0x00    
   \   00000028   0x00 0x00          DC8 0, 0, 0, 8, 62, 28, 8, 0
   \              0x00 0x08    
   \              0x3E 0x1C    
   \              0x08 0x00    
   1981          {
   1982            /* PAWN */ 		0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, /* 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x00, */ 
   1983            /* KNIGHT */		0x00, 0x00, 0x1c, 0x2c, 0x04, 0x04, 0x0e, 0x00,
   1984            /* BISHOP */		0x00, 0x00, 0x1c, 0x1c, 0x1c, 0x08, 0x00, 0x00, /* 0x00, 0x00, 0x08, 0x1c, 0x1c, 0x08, 0x00, 0x00, */
   1985            /* ROOK */		0x00, 0x00, 0x00, 0x1c, 0x1c, 0x1c, 0x1c, 0x00,
   1986            /* QUEEN */		0x00, 0x00, 0x14, 0x1c, 0x08, 0x1c, 0x08, 0x00,
   1987            /* KING */		0x00, 0x00, 0x00, 0x08, 0x3e, 0x1c, 0x08, 0x00,
   1988          };
   1989          
   1990          #ifdef NOT_REQUIRED
   1991          /* white pieces are constructed by painting black pieces and cutting out the white area */
   1992          const uint8_t chess_white_pieces_bm[] PROGMEM = 
   1993          {
   1994            /* PAWN */ 		0x00, 0x00, 0x0c, 0x12, 0x12, 0x0c, 0x1e, 0x00, 
   1995            /* KNIGHT */		0x00, 0x1c, 0x22, 0x52, 0x6a, 0x0a, 0x11, 0x1f,
   1996            /* BISHOP */		0x00, 0x08, 0x14, 0x22, 0x22, 0x14, 0x08, 0x7f,
   1997            /* ROOK */		0x00, 0x55, 0x7f, 0x22, 0x22, 0x22, 0x22, 0x7f,
   1998            /* QUEEN */		0x00, 0x55, 0x2a, 0x22, 0x14, 0x22, 0x14, 0x7f,
   1999            /* KING */		0x08, 0x1c, 0x49, 0x77, 0x41, 0x22, 0x14, 0x7f,
   2000          };
   2001          #endif
   2002          

   \                                 In section .text, align 4, keep-with-next
   2003          const uint8_t chess_black_pieces_bm[] PROGMEM = 
   \                     chess_black_pieces_bm:
   \   00000000   0x00 0x00          DC8 0, 0, 24, 60, 60, 24, 60, 0, 0, 28, 62, 126, 110, 14, 31, 31, 0, 28
   \              0x18 0x3C    
   \              0x3C 0x18    
   \              0x3C 0x00    
   \              0x00 0x1C    
   \              0x3E 0x7E    
   \              0x6E 0x0E    
   \              0x1F 0x1F    
   \              0x00 0x1C    
   \   00000012   0x2E 0x3E          DC8 46, 62, 62, 28, 8, 127, 0, 85, 127, 62, 62, 62, 62, 127, 0, 85, 62
   \              0x3E 0x1C    
   \              0x08 0x7F    
   \              0x00 0x55    
   \              0x7F 0x3E    
   \              0x3E 0x3E    
   \              0x3E 0x7F    
   \              0x00 0x55    
   \              0x3E         
   \   00000023   0x3E 0x1C          DC8 62, 28, 62, 28, 127, 8, 28, 73, 127, 127, 62, 28, 127
   \              0x3E 0x1C    
   \              0x7F 0x08    
   \              0x1C 0x49    
   \              0x7F 0x7F    
   \              0x3E 0x1C    
   \              0x7F         

   \                                 In section .data, align 4
   \                     mnu_pos:
   \   00000000   0x00               DC8 0
   \                     mnu_max:
   \   00000001   0x04               DC8 4
   \                     chess_key_code:
   \   00000002   0x00               DC8 0
   \                     chess_key_cmd:
   \   00000003   0x00               DC8 0
   \                     chess_state:
   \   00000004   0x00               DC8 0
   \                     chess_source_pos:
   \   00000005   0xFF               DC8 255
   \                     chess_target_pos:
   \   00000006   0xFF               DC8 255
   2004          {
   2005            /* PAWN */ 		0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x3c, 0x00, /* 0x00, 0x00, 0x0c, 0x1e, 0x1e, 0x0c, 0x1e, 0x00, */ 
   2006            /* KNIGHT */		0x00, 0x1c, 0x3e, 0x7e, 0x6e, 0x0e, 0x1f, 0x1f,
   2007            /* BISHOP */		0x00, 0x1c, 0x2e, 0x3e, 0x3e, 0x1c, 0x08, 0x7f,  /*0x00, 0x08, 0x1c, 0x3e, 0x3e, 0x1c, 0x08, 0x7f,*/
   2008            /* ROOK */		0x00, 0x55, 0x7f, 0x3e, 0x3e, 0x3e, 0x3e, 0x7f,
   2009            /* QUEEN */		0x00, 0x55, 0x3e, 0x3e, 0x1c, 0x3e, 0x1c, 0x7f,
   2010            /* KING -*/		0x08, 0x1c, 0x49, 0x7f, 0x7f, 0x3e, 0x1c, 0x7f,
   2011          };
   2012          
   2013          
   2014          #if defined(DOGXL160_HW_GR)
   2015          #define BOXSIZE 13
   2016          #define BOXOFFSET 3
   2017          #else
   2018          #define BOXSIZE 8
   2019          #define BOXOFFSET 1
   2020          #endif
   2021          
   2022          u8g_uint_t chess_low_edge;
   \                     chess_low_edge:
   \   00000007   0x00               DC8 0
   2023          uint8_t chess_boxsize = 8;
   \                     chess_boxsize:
   \   00000008   0x08               DC8 8
   2024          uint8_t chess_boxoffset = 1;
   \                     chess_boxoffset:
   \   00000009   0x01               DC8 1
   \   0000000A   0x00 0x00          DC8 0, 0
   \                     lrc_u8g:
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     mnu_title:
   \   00000010   0x........         DC32 ?_0
   \                     mnu_list:
   \   00000014   0x........         DC32 ?_1, ?_2, ?_3, ?_4
   \              0x........   
   \              0x........   
   \              0x........   

   \                                 In section .data, align 4
   \                     ce_piece_weight:
   \   00000000   0x00 0x01          DC8 0, 1, 3, 3, 5, 9, 0, 0
   \              0x03 0x03    
   \              0x05 0x09    
   \              0x00 0x00    
   \                     ce_pos_weight:
   \   00000008   0x00 0x01          DC8 0, 1, 1, 2, 2, 1, 1, 0
   \              0x01 0x02    
   \              0x02 0x01    
   \              0x01 0x00    

   \                                 In section .data, align 4
   \                     `cu_GetHalfMoveStr::buf`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     chess_piece_to_char:
   \   00000008   0x4E 0x42          DC8 "NBRQK"
   \              0x52 0x51    
   \              0x4B 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0
   2025          
   2026          

   \                                 In section .text, align 2, keep-with-next
   2027          void chess_DrawFrame(uint8_t pos, uint8_t is_bold)
   2028          {
   \                     chess_DrawFrame: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   2029            u8g_uint_t x0, y0;
   2030          
   2031            x0 = pos;
   2032            x0 &= 15;
   \   00000006   0xF004 0x050F      AND      R5,R4,#0xF
   2033            if ( lrc_obj.orientation != COLOR_WHITE )
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable52
   \   0000000E   0xF890 0x0045      LDRB     R0,[R0, #+69]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??chess_DrawFrame_0
   2034              x0 ^= 7;
   \   00000016   0xF085 0x0507      EOR      R5,R5,#0x7
   2035          
   2036            y0 = pos;
   2037            y0>>= 4;
   \                     ??chess_DrawFrame_0: (+1)
   \   0000001A   0x0924             LSRS     R4,R4,#+4
   2038            if ( lrc_obj.orientation != COLOR_WHITE )
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??chess_DrawFrame_1
   2039              y0 ^= 7;
   \   00000020   0xF084 0x0407      EOR      R4,R4,#0x7
   2040            
   2041            x0 *= chess_boxsize;
   \                     ??chess_DrawFrame_1: (+1)
   \   00000024   0x.... 0x....      LDR.W    R7,??DataTable52_2
   \   00000028   0x7A38             LDRB     R0,[R7, #+8]
   \   0000002A   0x4345             MULS     R5,R0,R5
   2042            y0 *= chess_boxsize;
   \   0000002C   0x4344             MULS     R4,R0,R4
   2043            
   2044            u8g_SetDefaultForegroundColor(lrc_u8g);
   \   0000002E   0x68F8             LDR      R0,[R7, #+12]
   \   00000030   0x.... 0x....      BL       u8g_SetDefaultForegroundColor
   2045            u8g_DrawFrame(lrc_u8g, x0, chess_low_edge - y0 - chess_boxsize+1, chess_boxsize, chess_boxsize);
   \   00000034   0x7A3A             LDRB     R2,[R7, #+8]
   \   00000036   0x4610             MOV      R0,R2
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x4613             MOV      R3,R2
   \   0000003C   0x79F8             LDRB     R0,[R7, #+7]
   \   0000003E   0x1B00             SUBS     R0,R0,R4
   \   00000040   0x1A82             SUBS     R2,R0,R2
   \   00000042   0x1C52             ADDS     R2,R2,#+1
   \   00000044   0xB2D2             UXTB     R2,R2
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x68F8             LDR      R0,[R7, #+12]
   \   0000004C   0x.... 0x....      BL       u8g_DrawFrame
   2046            
   2047            
   2048            if ( is_bold )
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD010             BEQ.N    ??chess_DrawFrame_2
   2049            {
   2050                x0--;
   2051                y0++;
   2052            
   2053              u8g_DrawFrame(lrc_u8g, x0, chess_low_edge - y0 - chess_boxsize +1, chess_boxsize+2, chess_boxsize+2);
   \   00000054   0x7A3A             LDRB     R2,[R7, #+8]
   \   00000056   0x1C93             ADDS     R3,R2,#+2
   \   00000058   0x4618             MOV      R0,R3
   \   0000005A   0xB2C0             UXTB     R0,R0
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0xB2DB             UXTB     R3,R3
   \   00000060   0x79F8             LDRB     R0,[R7, #+7]
   \   00000062   0x1B04             SUBS     R4,R0,R4
   \   00000064   0x1E60             SUBS     R0,R4,#+1
   \   00000066   0x1A82             SUBS     R2,R0,R2
   \   00000068   0x1C52             ADDS     R2,R2,#+1
   \   0000006A   0xB2D2             UXTB     R2,R2
   \   0000006C   0x1E69             SUBS     R1,R5,#+1
   \   0000006E   0xB2C9             UXTB     R1,R1
   \   00000070   0x68F8             LDR      R0,[R7, #+12]
   \   00000072   0x.... 0x....      BL       u8g_DrawFrame
   2054            }
   2055          }
   \                     ??chess_DrawFrame_2: (+1)
   \   00000076   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2056          
   2057          

   \                                 In section .text, align 2, keep-with-next
   2058          void chess_DrawBoard(void)
   2059          {
   \                     chess_DrawBoard: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   2060            uint8_t i, j, cp;
   2061            const uint8_t *ptr;  /* pointer into PROGMEM */
   2062            
   2063            if ( U8G_MODE_GET_BITS_PER_PIXEL(u8g_GetMode(lrc_u8g)) > 1 )
   \   00000004   0x.... 0x....      LDR.W    R6,??DataTable52_2
   \   00000008   0x68F0             LDR      R0,[R6, #+12]
   \   0000000A   0x7CC1             LDRB     R1,[R0, #+19]
   \   0000000C   0xF001 0x011F      AND      R1,R1,#0x1F
   \   00000010   0x2902             CMP      R1,#+2
   \   00000012   0xDB2A             BLT.N    ??chess_DrawBoard_0
   2064            {
   2065              for( i = 0; i < 8; i++ )
   \   00000014   0x2700             MOVS     R7,#+0
   \   00000016   0xE000             B.N      ??chess_DrawBoard_1
   \                     ??chess_DrawBoard_2: (+1)
   \   00000018   0x1C7F             ADDS     R7,R7,#+1
   \                     ??chess_DrawBoard_1: (+1)
   \   0000001A   0x2F08             CMP      R7,#+8
   \   0000001C   0xF280 0x80A1      BGE.W    ??chess_DrawBoard_3
   2066                for( j = 0; j < 8; j++ )
   \   00000020   0xF04F 0x0800      MOV      R8,#+0
   \                     ??chess_DrawBoard_4: (+1)
   \   00000024   0xF1B8 0x0F08      CMP      R8,#+8
   \   00000028   0xDAF6             BGE.N    ??chess_DrawBoard_2
   2067                {
   2068                  uint8_t x,y;
   2069                  x = i;
   2070                  x*=chess_boxsize;
   \   0000002A   0x7A35             LDRB     R5,[R6, #+8]
   \   0000002C   0xFB05 0xF407      MUL      R4,R5,R7
   2071                  y = j;
   2072                  y*=chess_boxsize;
   \   00000030   0xFB05 0xF508      MUL      R5,R5,R8
   2073                  if ( ((i^j) & 1)  == 0 )
   \   00000034   0x68F0             LDR      R0,[R6, #+12]
   \   00000036   0xEA88 0x0107      EOR      R1,R8,R7
   \   0000003A   0x07C9             LSLS     R1,R1,#+31
   \   0000003C   0xD502             BPL.N    ??chess_DrawBoard_5
   2074                    u8g_SetDefaultMidColor(lrc_u8g);  
   2075                  else
   2076                    u8g_SetDefaultBackgroundColor(lrc_u8g);  
   \   0000003E   0x.... 0x....      BL       u8g_SetDefaultBackgroundColor
   \   00000042   0xE001             B.N      ??chess_DrawBoard_6
   \                     ??chess_DrawBoard_5: (+1)
   \   00000044   0x.... 0x....      BL       u8g_SetDefaultMidColor
   2077                  u8g_DrawBox(lrc_u8g, x,chess_low_edge-y-chess_boxsize+1,chess_boxsize,chess_boxsize);
   \                     ??chess_DrawBoard_6: (+1)
   \   00000048   0x7A33             LDRB     R3,[R6, #+8]
   \   0000004A   0x4618             MOV      R0,R3
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   \   0000004E   0x79F0             LDRB     R0,[R6, #+7]
   \   00000050   0x1B45             SUBS     R5,R0,R5
   \   00000052   0x1AED             SUBS     R5,R5,R3
   \   00000054   0x1C6D             ADDS     R5,R5,#+1
   \   00000056   0x462A             MOV      R2,R5
   \   00000058   0xB2D2             UXTB     R2,R2
   \   0000005A   0x4621             MOV      R1,R4
   \   0000005C   0xB2C9             UXTB     R1,R1
   \   0000005E   0x68F0             LDR      R0,[R6, #+12]
   \   00000060   0x.... 0x....      BL       u8g_DrawBox
   2078                }
   \   00000064   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000068   0xE7DC             B.N      ??chess_DrawBoard_4
   2079              //u8g_SetDefaultForegroundColor(lrc_u8g);  
   2080            }
   2081            else
   2082            {
   2083              uint8_t x_offset = 1;
   2084              u8g_SetDefaultForegroundColor(lrc_u8g);  
   \                     ??chess_DrawBoard_0: (+1)
   \   0000006A   0x.... 0x....      BL       u8g_SetDefaultForegroundColor
   2085              for( i = 0; i < 8*8; i+=8 )
   \   0000006E   0x2400             MOVS     R4,#+0
   \   00000070   0xE073             B.N      ??chess_DrawBoard_7
   2086              {
   2087                for( j = 0; j < 8*8; j+=8 )
   2088                {
   2089                  if ( ((i^j) & 8)  == 0 )
   \                     ??chess_DrawBoard_8: (+1)
   \   00000072   0xEA85 0x0004      EOR      R0,R5,R4
   \   00000076   0x0700             LSLS     R0,R0,#+28
   \   00000078   0xD46B             BMI.N    ??chess_DrawBoard_9
   2090                  {
   2091                    u8g_DrawPixel(lrc_u8g, j+0+x_offset, chess_low_edge - i-0);
   \   0000007A   0x1C6F             ADDS     R7,R5,#+1
   \   0000007C   0x79F2             LDRB     R2,[R6, #+7]
   \   0000007E   0x1B12             SUBS     R2,R2,R4
   \   00000080   0xB2D2             UXTB     R2,R2
   \   00000082   0x4639             MOV      R1,R7
   \   00000084   0xB2C9             UXTB     R1,R1
   \   00000086   0x68F0             LDR      R0,[R6, #+12]
   \   00000088   0x.... 0x....      BL       u8g_DrawPixel
   2092                    u8g_DrawPixel(lrc_u8g, j+0+x_offset, chess_low_edge - i-2);
   \   0000008C   0x79F0             LDRB     R0,[R6, #+7]
   \   0000008E   0x1B00             SUBS     R0,R0,R4
   \   00000090   0x1E82             SUBS     R2,R0,#+2
   \   00000092   0xB2D2             UXTB     R2,R2
   \   00000094   0x4639             MOV      R1,R7
   \   00000096   0xB2C9             UXTB     R1,R1
   \   00000098   0x68F0             LDR      R0,[R6, #+12]
   \   0000009A   0x.... 0x....      BL       u8g_DrawPixel
   2093                    u8g_DrawPixel(lrc_u8g, j+0+x_offset, chess_low_edge - i-4);
   \   0000009E   0x79F0             LDRB     R0,[R6, #+7]
   \   000000A0   0x1B00             SUBS     R0,R0,R4
   \   000000A2   0x1F02             SUBS     R2,R0,#+4
   \   000000A4   0xB2D2             UXTB     R2,R2
   \   000000A6   0x4639             MOV      R1,R7
   \   000000A8   0xB2C9             UXTB     R1,R1
   \   000000AA   0x68F0             LDR      R0,[R6, #+12]
   \   000000AC   0x.... 0x....      BL       u8g_DrawPixel
   2094                    u8g_DrawPixel(lrc_u8g, j+0+x_offset, chess_low_edge - i-6);
   \   000000B0   0x79F0             LDRB     R0,[R6, #+7]
   \   000000B2   0x1B00             SUBS     R0,R0,R4
   \   000000B4   0x1F82             SUBS     R2,R0,#+6
   \   000000B6   0xB2D2             UXTB     R2,R2
   \   000000B8   0x4639             MOV      R1,R7
   \   000000BA   0xB2C9             UXTB     R1,R1
   \   000000BC   0x68F0             LDR      R0,[R6, #+12]
   \   000000BE   0x.... 0x....      BL       u8g_DrawPixel
   2095                    u8g_DrawPixel(lrc_u8g, j+2+x_offset, chess_low_edge - i-0);
   \   000000C2   0x1CEF             ADDS     R7,R5,#+3
   \   000000C4   0x79F2             LDRB     R2,[R6, #+7]
   \   000000C6   0x1B12             SUBS     R2,R2,R4
   \   000000C8   0xB2D2             UXTB     R2,R2
   \   000000CA   0x4639             MOV      R1,R7
   \   000000CC   0xB2C9             UXTB     R1,R1
   \   000000CE   0x68F0             LDR      R0,[R6, #+12]
   \   000000D0   0x.... 0x....      BL       u8g_DrawPixel
   2096                    u8g_DrawPixel(lrc_u8g, j+2+x_offset, chess_low_edge - i-6);
   \   000000D4   0x79F0             LDRB     R0,[R6, #+7]
   \   000000D6   0x1B00             SUBS     R0,R0,R4
   \   000000D8   0x1F82             SUBS     R2,R0,#+6
   \   000000DA   0xB2D2             UXTB     R2,R2
   \   000000DC   0x4639             MOV      R1,R7
   \   000000DE   0xB2C9             UXTB     R1,R1
   \   000000E0   0x68F0             LDR      R0,[R6, #+12]
   \   000000E2   0x.... 0x....      BL       u8g_DrawPixel
   2097                    u8g_DrawPixel(lrc_u8g, j+4+x_offset, chess_low_edge - i-0);
   \   000000E6   0x1D6F             ADDS     R7,R5,#+5
   \   000000E8   0x79F2             LDRB     R2,[R6, #+7]
   \   000000EA   0x1B12             SUBS     R2,R2,R4
   \   000000EC   0xB2D2             UXTB     R2,R2
   \   000000EE   0x4639             MOV      R1,R7
   \   000000F0   0xB2C9             UXTB     R1,R1
   \   000000F2   0x68F0             LDR      R0,[R6, #+12]
   \   000000F4   0x.... 0x....      BL       u8g_DrawPixel
   2098                    u8g_DrawPixel(lrc_u8g, j+4+x_offset, chess_low_edge - i-6);
   \   000000F8   0x79F0             LDRB     R0,[R6, #+7]
   \   000000FA   0x1B00             SUBS     R0,R0,R4
   \   000000FC   0x1F82             SUBS     R2,R0,#+6
   \   000000FE   0xB2D2             UXTB     R2,R2
   \   00000100   0x4639             MOV      R1,R7
   \   00000102   0xB2C9             UXTB     R1,R1
   \   00000104   0x68F0             LDR      R0,[R6, #+12]
   \   00000106   0x.... 0x....      BL       u8g_DrawPixel
   2099                    u8g_DrawPixel(lrc_u8g, j+6+x_offset, chess_low_edge - i-0);
   \   0000010A   0x1DEF             ADDS     R7,R5,#+7
   \   0000010C   0x79F2             LDRB     R2,[R6, #+7]
   \   0000010E   0x1B12             SUBS     R2,R2,R4
   \   00000110   0xB2D2             UXTB     R2,R2
   \   00000112   0x4639             MOV      R1,R7
   \   00000114   0xB2C9             UXTB     R1,R1
   \   00000116   0x68F0             LDR      R0,[R6, #+12]
   \   00000118   0x.... 0x....      BL       u8g_DrawPixel
   2100                    u8g_DrawPixel(lrc_u8g, j+6+x_offset, chess_low_edge - i-2);
   \   0000011C   0x79F0             LDRB     R0,[R6, #+7]
   \   0000011E   0x1B00             SUBS     R0,R0,R4
   \   00000120   0x1E82             SUBS     R2,R0,#+2
   \   00000122   0xB2D2             UXTB     R2,R2
   \   00000124   0x4639             MOV      R1,R7
   \   00000126   0xB2C9             UXTB     R1,R1
   \   00000128   0x68F0             LDR      R0,[R6, #+12]
   \   0000012A   0x.... 0x....      BL       u8g_DrawPixel
   2101                    u8g_DrawPixel(lrc_u8g, j+6+x_offset, chess_low_edge - i-4);
   \   0000012E   0x79F0             LDRB     R0,[R6, #+7]
   \   00000130   0x1B00             SUBS     R0,R0,R4
   \   00000132   0x1F02             SUBS     R2,R0,#+4
   \   00000134   0xB2D2             UXTB     R2,R2
   \   00000136   0x4639             MOV      R1,R7
   \   00000138   0xB2C9             UXTB     R1,R1
   \   0000013A   0x68F0             LDR      R0,[R6, #+12]
   \   0000013C   0x.... 0x....      BL       u8g_DrawPixel
   2102                    u8g_DrawPixel(lrc_u8g, j+6+x_offset, chess_low_edge - i-6);
   \   00000140   0x79F0             LDRB     R0,[R6, #+7]
   \   00000142   0x1B00             SUBS     R0,R0,R4
   \   00000144   0x1F82             SUBS     R2,R0,#+6
   \   00000146   0xB2D2             UXTB     R2,R2
   \   00000148   0x4639             MOV      R1,R7
   \   0000014A   0xB2C9             UXTB     R1,R1
   \   0000014C   0x68F0             LDR      R0,[R6, #+12]
   \   0000014E   0x.... 0x....      BL       u8g_DrawPixel
   2103                  }
   2104                }
   \                     ??chess_DrawBoard_9: (+1)
   \   00000152   0x3508             ADDS     R5,R5,#+8
   \                     ??chess_DrawBoard_10: (+1)
   \   00000154   0x2D3F             CMP      R5,#+63
   \   00000156   0xDD8C             BLE.N    ??chess_DrawBoard_8
   \   00000158   0x3408             ADDS     R4,R4,#+8
   \                     ??chess_DrawBoard_7: (+1)
   \   0000015A   0x2C3F             CMP      R4,#+63
   \   0000015C   0xDC01             BGT.N    ??chess_DrawBoard_3
   \   0000015E   0x2500             MOVS     R5,#+0
   \   00000160   0xE7F8             B.N      ??chess_DrawBoard_10
   2105              }
   2106            }
   2107            
   2108            for ( i = 0; i < 8; i++ )
   \                     ??chess_DrawBoard_3: (+1)
   \   00000162   0x2700             MOVS     R7,#+0
   \   00000164   0xE063             B.N      ??chess_DrawBoard_11
   2109            {
   2110              for ( j = 0; j < 8; j++ )
   2111              {
   2112                /* get piece from global board */
   2113                if ( lrc_obj.orientation == COLOR_WHITE )
   2114                {
   2115          	cp =  lrc_obj.board[i*8+j];
   \                     ??chess_DrawBoard_12: (+1)
   \   00000166   0x1C88             ADDS     R0,R1,#+2
   \   00000168   0xEB08 0x01C7      ADD      R1,R8,R7, LSL #+3
   \   0000016C   0x5C45             LDRB     R5,[R0, R1]
   2116                }
   2117                else
   2118                {
   2119          	cp =  lrc_obj.board[(7-i)*8+7-j];
   2120                }
   2121                if ( cp_GetPiece(cp) != PIECE_NONE )
   \                     ??chess_DrawBoard_13: (+1)
   \   0000016E   0x4628             MOV      R0,R5
   \   00000170   0x.... 0x....      BL       cp_GetPiece
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xD044             BEQ.N    ??chess_DrawBoard_14
   2122                {
   2123          	ptr = chess_black_pieces_bm;
   2124          	ptr += (cp_GetPiece(cp)-1)*8;
   \   00000178   0x4628             MOV      R0,R5
   \   0000017A   0x.... 0x....      BL       cp_GetPiece
   \   0000017E   0x.... 0x....      ADR.W    R1,chess_black_pieces_bm
   \   00000182   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   00000186   0xF1A0 0x0908      SUB      R9,R0,#+8
   2125                  u8g_SetDefaultForegroundColor(lrc_u8g);
   \   0000018A   0x68F0             LDR      R0,[R6, #+12]
   \   0000018C   0x.... 0x....      BL       u8g_SetDefaultForegroundColor
   2126                  u8g_DrawBitmapP(lrc_u8g, j*chess_boxsize+chess_boxoffset-1, chess_low_edge - (i*chess_boxsize+chess_boxsize-chess_boxoffset), 1, 8, ptr);
   \   00000190   0x7A70             LDRB     R0,[R6, #+9]
   \   00000192   0x7A31             LDRB     R1,[R6, #+8]
   \   00000194   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   00000198   0x2208             MOVS     R2,#+8
   \   0000019A   0x9200             STR      R2,[SP, #+0]
   \   0000019C   0x2301             MOVS     R3,#+1
   \   0000019E   0x79F2             LDRB     R2,[R6, #+7]
   \   000001A0   0xFB01 0x2217      MLS      R2,R1,R7,R2
   \   000001A4   0x1A52             SUBS     R2,R2,R1
   \   000001A6   0x1882             ADDS     R2,R0,R2
   \   000001A8   0xB2D2             UXTB     R2,R2
   \   000001AA   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   000001AE   0x1E41             SUBS     R1,R0,#+1
   \   000001B0   0xB2C9             UXTB     R1,R1
   \   000001B2   0x68F0             LDR      R0,[R6, #+12]
   \   000001B4   0x.... 0x....      BL       u8g_DrawBitmapP
   2127                  
   2128          	if ( cp_GetColor(cp) == lrc_obj.strike_out_color ) 
   \   000001B8   0x4628             MOV      R0,R5
   \   000001BA   0x.... 0x....      BL       cp_GetColor
   \   000001BE   0x7861             LDRB     R1,[R4, #+1]
   \   000001C0   0x4288             CMP      R0,R1
   \   000001C2   0xD11E             BNE.N    ??chess_DrawBoard_14
   2129          	{
   2130          	  ptr = chess_pieces_body_bm;
   2131          	  ptr += (cp_GetPiece(cp)-1)*8;
   \   000001C4   0x4628             MOV      R0,R5
   \   000001C6   0x.... 0x....      BL       cp_GetPiece
   \   000001CA   0x.... 0x....      ADR.W    R1,chess_pieces_body_bm
   \   000001CE   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \   000001D2   0xF1A0 0x0408      SUB      R4,R0,#+8
   2132                    u8g_SetDefaultBackgroundColor(lrc_u8g);
   \   000001D6   0x68F0             LDR      R0,[R6, #+12]
   \   000001D8   0x.... 0x....      BL       u8g_SetDefaultBackgroundColor
   2133                    u8g_DrawBitmapP(lrc_u8g, j*chess_boxsize+chess_boxoffset-1, chess_low_edge - (i*chess_boxsize+chess_boxsize-chess_boxoffset), 1, 8, ptr);
   \   000001DC   0x7A70             LDRB     R0,[R6, #+9]
   \   000001DE   0x7A31             LDRB     R1,[R6, #+8]
   \   000001E0   0x9401             STR      R4,[SP, #+4]
   \   000001E2   0x2208             MOVS     R2,#+8
   \   000001E4   0x9200             STR      R2,[SP, #+0]
   \   000001E6   0x2301             MOVS     R3,#+1
   \   000001E8   0x79F2             LDRB     R2,[R6, #+7]
   \   000001EA   0xFB01 0x2217      MLS      R2,R1,R7,R2
   \   000001EE   0x1A52             SUBS     R2,R2,R1
   \   000001F0   0x1882             ADDS     R2,R0,R2
   \   000001F2   0xB2D2             UXTB     R2,R2
   \   000001F4   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   000001F8   0x1E41             SUBS     R1,R0,#+1
   \   000001FA   0xB2C9             UXTB     R1,R1
   \   000001FC   0x68F0             LDR      R0,[R6, #+12]
   \   000001FE   0x.... 0x....      BL       u8g_DrawBitmapP
   2134          	}
   2135                }
   \                     ??chess_DrawBoard_14: (+1)
   \   00000202   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000206   0xE016             B.N      ??chess_DrawBoard_15
   2136              }
   2137            }
   2138            
   2139            if ( (chess_source_pos & 0x88) == 0 )
   \                     ??chess_DrawBoard_16: (+1)
   \   00000208   0x7970             LDRB     R0,[R6, #+5]
   \   0000020A   0xF010 0x0F88      TST      R0,#0x88
   \   0000020E   0xD102             BNE.N    ??chess_DrawBoard_17
   2140            {
   2141              chess_DrawFrame(chess_source_pos, 1);
   \   00000210   0x2101             MOVS     R1,#+1
   \   00000212   0x.... 0x....      BL       chess_DrawFrame
   2142            }
   2143          
   2144            if ( (chess_target_pos & 0x88) == 0 )
   \                     ??chess_DrawBoard_17: (+1)
   \   00000216   0x79B0             LDRB     R0,[R6, #+6]
   \   00000218   0xF010 0x0F88      TST      R0,#0x88
   \   0000021C   0xD104             BNE.N    ??chess_DrawBoard_18
   2145            {
   2146              chess_DrawFrame(chess_target_pos, 0);
   \   0000021E   0x2100             MOVS     R1,#+0
   \   00000220   0xB003             ADD      SP,SP,#+12
   \   00000222   0xE8BD 0x43F0      POP      {R4-R9,LR}
   \   00000226   0x....             B.N      chess_DrawFrame
   2147            }
   2148            
   2149          }
   \                     ??chess_DrawBoard_18: (+1)
   \   00000228   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
   \                     ??chess_DrawBoard_19: (+1)
   \   0000022C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??chess_DrawBoard_11: (+1)
   \   0000022E   0x2F08             CMP      R7,#+8
   \   00000230   0xDAEA             BGE.N    ??chess_DrawBoard_16
   \   00000232   0xF04F 0x0800      MOV      R8,#+0
   \                     ??chess_DrawBoard_15: (+1)
   \   00000236   0xF1B8 0x0F08      CMP      R8,#+8
   \   0000023A   0xDAF7             BGE.N    ??chess_DrawBoard_19
   \   0000023C   0x....             LDR.N    R1,??DataTable52
   \   0000023E   0xF101 0x0445      ADD      R4,R1,#+69
   \   00000242   0x7820             LDRB     R0,[R4, #+0]
   \   00000244   0x2800             CMP      R0,#+0
   \   00000246   0xD08E             BEQ.N    ??chess_DrawBoard_12
   \   00000248   0x1C88             ADDS     R0,R1,#+2
   \   0000024A   0x4279             RSBS     R1,R7,#+0
   \   0000024C   0x00C9             LSLS     R1,R1,#+3
   \   0000024E   0x313F             ADDS     R1,R1,#+63
   \   00000250   0xEBA1 0x0108      SUB      R1,R1,R8
   \   00000254   0x5C45             LDRB     R5,[R0, R1]
   \   00000256   0xE78A             B.N      ??chess_DrawBoard_13
   2150          
   2151          

   \                                 In section .text, align 2, keep-with-next
   2152          void chess_Thinking(void)
   2153          {
   2154          }
   \                     chess_Thinking: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2155          

   \                                 In section .text, align 2, keep-with-next
   2156          void chess_Init(u8g_t *u8g, uint8_t body_color)
   2157          {
   \                     chess_Init: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   2158            lrc_u8g = u8g;
   \   00000002   0x....             LDR.N    R2,??DataTable52_2
   \   00000004   0x60D0             STR      R0,[R2, #+12]
   2159          
   2160            chess_low_edge = u8g_GetHeight(lrc_u8g);
   2161            chess_low_edge--;
   \   00000006   0x7843             LDRB     R3,[R0, #+1]
   \   00000008   0x1E5B             SUBS     R3,R3,#+1
   \   0000000A   0x71D3             STRB     R3,[R2, #+7]
   2162            
   2163          
   2164            if ( U8G_MODE_GET_BITS_PER_PIXEL(u8g_GetMode(lrc_u8g)) == 1 )
   \   0000000C   0x7CC4             LDRB     R4,[R0, #+19]
   \   0000000E   0xF004 0x041F      AND      R4,R4,#0x1F
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD104             BNE.N    ??chess_Init_0
   2165            {
   2166            
   2167              chess_boxsize = 8;
   \   00000016   0x2008             MOVS     R0,#+8
   \   00000018   0x7210             STRB     R0,[R2, #+8]
   2168              chess_boxoffset = 1;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x7250             STRB     R0,[R2, #+9]
   \   0000001E   0xE016             B.N      ??chess_Init_1
   2169            }
   2170            else
   2171            {
   2172          
   2173              /*    
   2174              if ( u8g_GetHeight(lrc_u8g) >= 12*8 )
   2175              {
   2176                chess_boxsize = 12;
   2177                chess_boxoffset = 3;
   2178              }
   2179              else */ if ( u8g_GetHeight(lrc_u8g) >= 11*8 )
   \                     ??chess_Init_0: (+1)
   \   00000020   0x7844             LDRB     R4,[R0, #+1]
   \   00000022   0x2C58             CMP      R4,#+88
   \   00000024   0xDB04             BLT.N    ??chess_Init_2
   2180              {
   2181                chess_boxsize = 10;
   \   00000026   0x240A             MOVS     R4,#+10
   \   00000028   0x7214             STRB     R4,[R2, #+8]
   2182                chess_boxoffset = 2;
   \   0000002A   0x2402             MOVS     R4,#+2
   \   0000002C   0x7254             STRB     R4,[R2, #+9]
   \   0000002E   0xE003             B.N      ??chess_Init_3
   2183              }
   2184              else
   2185              {
   2186                chess_boxsize = 8;
   \                     ??chess_Init_2: (+1)
   \   00000030   0x2408             MOVS     R4,#+8
   \   00000032   0x7214             STRB     R4,[R2, #+8]
   2187                chess_boxoffset = 1;      
   \   00000034   0x2401             MOVS     R4,#+1
   \   00000036   0x7254             STRB     R4,[R2, #+9]
   2188              }
   2189              
   2190              if ( u8g_GetHeight(lrc_u8g) > 64 )
   \                     ??chess_Init_3: (+1)
   \   00000038   0x7840             LDRB     R0,[R0, #+1]
   \   0000003A   0x2841             CMP      R0,#+65
   \   0000003C   0xDB07             BLT.N    ??chess_Init_1
   2191                chess_low_edge -= (u8g_GetHeight(lrc_u8g)-chess_boxsize*8) / 2;
   \   0000003E   0x7A14             LDRB     R4,[R2, #+8]
   \   00000040   0xEBA0 0x00C4      SUB      R0,R0,R4, LSL #+3
   \   00000044   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000048   0xEBB3 0x0360      SUBS     R3,R3,R0, ASR #+1
   \   0000004C   0x71D3             STRB     R3,[R2, #+7]
   2192              
   2193            }
   2194              
   2195            lrc_obj.strike_out_color = body_color;
   \                     ??chess_Init_1: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable52
   \   00000050   0xF880 0x1046      STRB     R1,[R0, #+70]
   2196            chess_SetupBoard();
   \   00000054   0xBC11             POP      {R0,R4}
   \   00000056   0x.... 0x....      B.W      chess_SetupBoard
   2197          }
   2198          
   2199          
   2200          

   \                                 In section .text, align 4, keep-with-next
   2201          void chess_Draw(void)
   2202          {
   \                     chess_Draw: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   2203            if ( chess_state == CHESS_STATE_MENU )
   \   00000002   0x....             LDR.N    R5,??DataTable52
   \   00000004   0x....             LDR.N    R4,??DataTable52_2
   \   00000006   0x7920             LDRB     R0,[R4, #+4]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD10A             BNE.N    ??chess_Draw_0
   2204            {
   2205              if ( lrc_obj.ply_count == 0)
   \   0000000C   0x7828             LDRB     R0,[R5, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD102             BNE.N    ??chess_Draw_1
   2206                mnu_max = 2;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x7060             STRB     R0,[R4, #+1]
   \   00000016   0xE001             B.N      ??chess_Draw_2
   2207              else
   2208                mnu_max = 4;
   \                     ??chess_Draw_1: (+1)
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x7060             STRB     R0,[R4, #+1]
   2209              mnu_Draw();
   \                     ??chess_Draw_2: (+1)
   \   0000001C   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000020   0x....             B.N      mnu_Draw
   2210            }
   2211            else
   2212            {
   2213              chess_DrawBoard();
   \                     ??chess_Draw_0: (+1)
   \   00000022   0x.... 0x....      BL       chess_DrawBoard
   2214              
   2215              {
   2216                uint8_t i;
   2217                uint8_t entries = lrc_obj.chm_pos;
   \   00000026   0x786E             LDRB     R6,[R5, #+1]
   2218                if ( entries > 4 )
   \   00000028   0x2E04             CMP      R6,#+4
   \   0000002A   0xDD00             BLE.N    ??chess_Draw_3
   2219          	entries = 4;
   \   0000002C   0x2604             MOVS     R6,#+4
   2220                
   2221                u8g_SetFont(lrc_u8g, u8g_font_5x7);
   \                     ??chess_Draw_3: (+1)
   \   0000002E   0x....             LDR.N    R1,??DataTable52_5
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x.... 0x....      BL       u8g_SetFont
   2222                u8g_SetDefaultForegroundColor(lrc_u8g);
   \   00000036   0x68E0             LDR      R0,[R4, #+12]
   \   00000038   0x.... 0x....      BL       u8g_SetDefaultForegroundColor
   2223                for( i = 0; i < entries; i++ )
   \   0000003C   0x2700             MOVS     R7,#+0
   \   0000003E   0xE010             B.N      ??chess_Draw_4
   2224                {
   2225                  
   2226          #if defined(DOGXL160_HW_GR) || defined(DOGXL160_HW_BW)
   2227          	dog_DrawStr(u8g_GetWidth(lrc_u8g)-35, u8g_GetHeight(lrc_u8g)-8*(i+1), font_5x7, cu_GetHalfMoveStr(lrc_obj.chm_pos-entries+i));
   2228          #else
   2229                  u8g_DrawStr(lrc_u8g, u8g_GetWidth(lrc_u8g)-35, 8*(i+1), cu_GetHalfMoveStr(lrc_obj.chm_pos-entries+i));
   \                     ??chess_Draw_5: (+1)
   \   00000040   0x7868             LDRB     R0,[R5, #+1]
   \   00000042   0x1B80             SUBS     R0,R0,R6
   \   00000044   0x1838             ADDS     R0,R7,R0
   \   00000046   0xB2C0             UXTB     R0,R0
   \   00000048   0x.... 0x....      BL       cu_GetHalfMoveStr
   \   0000004C   0x4603             MOV      R3,R0
   \   0000004E   0x68E0             LDR      R0,[R4, #+12]
   \   00000050   0x1C7F             ADDS     R7,R7,#+1
   \   00000052   0x00FA             LSLS     R2,R7,#+3
   \   00000054   0xB2D2             UXTB     R2,R2
   \   00000056   0x7801             LDRB     R1,[R0, #+0]
   \   00000058   0x3923             SUBS     R1,R1,#+35
   \   0000005A   0xB2C9             UXTB     R1,R1
   \   0000005C   0x.... 0x....      BL       u8g_DrawStr
   2230          #endif
   2231          
   2232                }
   \   00000060   0xB2FF             UXTB     R7,R7
   \                     ??chess_Draw_4: (+1)
   \   00000062   0x42B7             CMP      R7,R6
   \   00000064   0xDBEC             BLT.N    ??chess_Draw_5
   2233                
   2234              }
   2235              
   2236              if ( chess_state == CHESS_STATE_SELECT_PIECE )
   \   00000066   0x7920             LDRB     R0,[R4, #+4]
   \   00000068   0x2802             CMP      R0,#+2
   \   0000006A   0xD108             BNE.N    ??chess_Draw_6
   2237                mnu_DrawHome(chess_source_pos == 255);
   \   0000006C   0x7960             LDRB     R0,[R4, #+5]
   \   0000006E   0x28FF             CMP      R0,#+255
   \   00000070   0xD101             BNE.N    ??chess_Draw_7
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xE000             B.N      ??chess_Draw_8
   \                     ??chess_Draw_7: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??chess_Draw_8: (+1)
   \   00000078   0x.... 0x....      BL       mnu_DrawHome
   \   0000007C   0xE00D             B.N      ??chess_Draw_9
   2238              else if ( chess_state == CHESS_STATE_SELECT_TARGET_POS )
   \                     ??chess_Draw_6: (+1)
   \   0000007E   0x2803             CMP      R0,#+3
   \   00000080   0xD108             BNE.N    ??chess_Draw_10
   2239                mnu_DrawHome(chess_target_pos == 255);
   \   00000082   0x79A0             LDRB     R0,[R4, #+6]
   \   00000084   0x28FF             CMP      R0,#+255
   \   00000086   0xD101             BNE.N    ??chess_Draw_11
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xE000             B.N      ??chess_Draw_12
   \                     ??chess_Draw_11: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \                     ??chess_Draw_12: (+1)
   \   0000008E   0x.... 0x....      BL       mnu_DrawHome
   \   00000092   0xE002             B.N      ??chess_Draw_9
   2240              else
   2241                mnu_DrawHome(0);
   \                     ??chess_Draw_10: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x.... 0x....      BL       mnu_DrawHome
   2242                
   2243              if ( chess_state == CHESS_STATE_GAME_END )
   \                     ??chess_Draw_9: (+1)
   \   0000009A   0x7920             LDRB     R0,[R4, #+4]
   \   0000009C   0x2805             CMP      R0,#+5
   \   0000009E   0xD12B             BNE.N    ??chess_Draw_13
   2244              {
   2245                switch( lrc_obj.lost_side_color )
   \   000000A0   0xF895 0x0048      LDRB     R0,[R5, #+72]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD002             BEQ.N    ??chess_Draw_14
   \   000000A8   0x2801             CMP      R0,#+1
   \   000000AA   0xD00D             BEQ.N    ??chess_Draw_15
   \   000000AC   0xE018             B.N      ??chess_Draw_16
   2246                {
   2247          	case COLOR_WHITE:
   2248          	  mnu_DrawEntry(u8g_GetHeight(lrc_u8g) / 2-2, "Black wins", 1, 1);
   \                     ??chess_Draw_14: (+1)
   \   000000AE   0x2301             MOVS     R3,#+1
   \   000000B0   0xEA4F 0x0203      MOV.W    R2,R3
   \   000000B4   0x....             ADR.N    R1,?_6
   \   000000B6   0x68E0             LDR      R0,[R4, #+12]
   \   000000B8   0x7840             LDRB     R0,[R0, #+1]
   \   000000BA   0x0840             LSRS     R0,R0,#+1
   \   000000BC   0x1E80             SUBS     R0,R0,#+2
   \   000000BE   0xB2C0             UXTB     R0,R0
   \   000000C0   0xB001             ADD      SP,SP,#+4
   \   000000C2   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   000000C6   0x....             B.N      mnu_DrawEntry
   2249          	  break;
   2250          	case COLOR_BLACK:
   2251          	  mnu_DrawEntry(u8g_GetHeight(lrc_u8g) / 2-2, "White wins", 1, 1);
   \                     ??chess_Draw_15: (+1)
   \   000000C8   0x2301             MOVS     R3,#+1
   \   000000CA   0x461A             MOV      R2,R3
   \   000000CC   0x....             ADR.N    R1,?_7
   \   000000CE   0x68E0             LDR      R0,[R4, #+12]
   \   000000D0   0x7840             LDRB     R0,[R0, #+1]
   \   000000D2   0x0840             LSRS     R0,R0,#+1
   \   000000D4   0x1E80             SUBS     R0,R0,#+2
   \   000000D6   0xB2C0             UXTB     R0,R0
   \   000000D8   0xB001             ADD      SP,SP,#+4
   \   000000DA   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   000000DE   0x....             B.N      mnu_DrawEntry
   2252          	  break;
   2253          	default:
   2254          	  mnu_DrawEntry(u8g_GetHeight(lrc_u8g) / 2-2, "Stalemate", 1, 1);
   \                     ??chess_Draw_16: (+1)
   \   000000E0   0x2301             MOVS     R3,#+1
   \   000000E2   0x461A             MOV      R2,R3
   \   000000E4   0x....             ADR.N    R1,?_8
   \   000000E6   0x68E0             LDR      R0,[R4, #+12]
   \   000000E8   0x7840             LDRB     R0,[R0, #+1]
   \   000000EA   0x0840             LSRS     R0,R0,#+1
   \   000000EC   0x1E80             SUBS     R0,R0,#+2
   \   000000EE   0xB2C0             UXTB     R0,R0
   \   000000F0   0xB001             ADD      SP,SP,#+4
   \   000000F2   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   000000F6   0x....             B.N      mnu_DrawEntry
   2255          	  break;
   2256                }  
   2257              }
   2258            }
   2259          }
   \                     ??chess_Draw_13: (+1)
   \   000000F8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2260          
   2261          

   \                                 In section .text, align 4, keep-with-next
   2262          void chess_Step(uint8_t keycode)
   2263          {
   \                     chess_Step: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   2264            if ( keycode == CHESS_KEY_NONE )
   \   00000002   0x....             LDR.N    R4,??DataTable52_2
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xD104             BNE.N    ??chess_Step_1
   2265            {
   2266              chess_key_cmd = chess_key_code;
   \   00000008   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000A   0x70E0             STRB     R0,[R4, #+3]
   2267              chess_key_code = CHESS_KEY_NONE;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x70A0             STRB     R0,[R4, #+2]
   \   00000010   0xE002             B.N      ??chess_Step_2
   2268            }
   2269            else
   2270            {
   2271              chess_key_cmd = CHESS_KEY_NONE;
   \                     ??chess_Step_1: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x70E1             STRB     R1,[R4, #+3]
   2272              chess_key_code = keycode;
   \   00000016   0x70A0             STRB     R0,[R4, #+2]
   2273            }
   2274            //chess_ComputerMove(2);
   2275            switch(chess_state)
   \                     ??chess_Step_2: (+1)
   \   00000018   0x7920             LDRB     R0,[R4, #+4]
   \   0000001A   0x2805             CMP      R0,#+5
   \   0000001C   0xF200 0x80BB      BHI.W    ??chess_Step_3
   \   00000020   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??chess_Step_0:
   \   00000024   0x03 0x3C          DC8      0x3,0x3C,0x4A,0x71
   \              0x4A 0x71    
   \   00000028   0xA3 0xB0          DC8      0xA3,0xB0
   2276            {
   2277              case CHESS_STATE_MENU:
   2278                mnu_Step(chess_key_cmd);
   \                     ??chess_Step_4: (+1)
   \   0000002A   0x78E5             LDRB     R5,[R4, #+3]
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x.... 0x....      BL       mnu_Step
   2279                if ( chess_key_cmd == CHESS_KEY_SELECT )
   \   00000032   0x2D03             CMP      R5,#+3
   \   00000034   0xF040 0x80AF      BNE.W    ??chess_Step_3
   2280                {
   2281          	if ( mnu_pos == 0 )
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD108             BNE.N    ??chess_Step_5
   2282          	{
   2283                    chess_SetupBoard();
   \   0000003E   0x.... 0x....      BL       chess_SetupBoard
   2284          	  lrc_obj.orientation = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable52
   \   00000046   0xF881 0x0045      STRB     R0,[R1, #+69]
   2285          	  chess_state = CHESS_STATE_SELECT_START;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x7120             STRB     R0,[R4, #+4]
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}
   2286          	}
   2287          	else if ( mnu_pos == 1 )
   \                     ??chess_Step_5: (+1)
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD108             BNE.N    ??chess_Step_6
   2288          	{
   2289                    chess_SetupBoard();
   \   00000054   0x.... 0x....      BL       chess_SetupBoard
   2290          	  lrc_obj.orientation = 1;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x....             LDR.N    R1,??DataTable52
   \   0000005C   0xF881 0x0045      STRB     R0,[R1, #+69]
   2291          	  chess_state = CHESS_STATE_THINKING;
   \   00000060   0x2004             MOVS     R0,#+4
   \   00000062   0x7120             STRB     R0,[R4, #+4]
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}
   2292          	}
   2293          	else if ( mnu_pos == 2 )
   \                     ??chess_Step_6: (+1)
   \   00000066   0x2802             CMP      R0,#+2
   \   00000068   0xD112             BNE.N    ??chess_Step_7
   2294          	{
   2295          	  if ( lrc_obj.ply_count >= 2 )
   \   0000006A   0x....             LDR.N    R5,??DataTable52
   \   0000006C   0x7828             LDRB     R0,[R5, #+0]
   \   0000006E   0x2802             CMP      R0,#+2
   \   00000070   0xDB0B             BLT.N    ??chess_Step_8
   2296          	  {
   2297          	    cu_UndoHalfMove();
   \   00000072   0x.... 0x....      BL       cu_UndoHalfMove
   2298          	    cu_UndoHalfMove();
   \   00000076   0x.... 0x....      BL       cu_UndoHalfMove
   2299          	    lrc_obj.ply_count-=2;
   \   0000007A   0x7828             LDRB     R0,[R5, #+0]
   \   0000007C   0x1E80             SUBS     R0,R0,#+2
   \   0000007E   0x7028             STRB     R0,[R5, #+0]
   2300          	    if ( lrc_obj.ply_count == 0 )
   \   00000080   0xB2C0             UXTB     R0,R0
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD101             BNE.N    ??chess_Step_8
   2301          	      mnu_pos = 0;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x7020             STRB     R0,[R4, #+0]
   2302          	  }
   2303          	  chess_state = CHESS_STATE_SELECT_START;
   \                     ??chess_Step_8: (+1)
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x7120             STRB     R0,[R4, #+4]
   \   0000008E   0xBD31             POP      {R0,R4,R5,PC}
   2304          	}
   2305          	else if ( mnu_pos == 3 )
   \                     ??chess_Step_7: (+1)
   \   00000090   0x2803             CMP      R0,#+3
   \   00000092   0xF040 0x8080      BNE.W    ??chess_Step_3
   2306          	{
   2307          	  chess_state = CHESS_STATE_SELECT_START;
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x7120             STRB     R0,[R4, #+4]
   \   0000009A   0xBD31             POP      {R0,R4,R5,PC}
   2308          	}
   2309                }
   2310                break;
   2311              case CHESS_STATE_SELECT_START:
   2312                chess_ClearMarks();
   \                     ??chess_Step_9: (+1)
   \   0000009C   0x.... 0x....      BL       chess_ClearMarks
   2313                chess_MarkMovable();
   \   000000A0   0x.... 0x....      BL       chess_MarkMovable
   2314                chess_source_pos = chess_GetNextMarked(255, 0);
   \   000000A4   0x2100             MOVS     R1,#+0
   \   000000A6   0x20FF             MOVS     R0,#+255
   \   000000A8   0x.... 0x....      BL       chess_GetNextMarked
   \   000000AC   0x7160             STRB     R0,[R4, #+5]
   2315                chess_target_pos = ILLEGAL_POSITION;
   \   000000AE   0x20FF             MOVS     R0,#+255
   \   000000B0   0x71A0             STRB     R0,[R4, #+6]
   2316                chess_state = CHESS_STATE_SELECT_PIECE;
   \   000000B2   0x2002             MOVS     R0,#+2
   \   000000B4   0x7120             STRB     R0,[R4, #+4]
   2317                break;
   \   000000B6   0xBD31             POP      {R0,R4,R5,PC}
   2318                
   2319              case CHESS_STATE_SELECT_PIECE:
   2320                if ( chess_key_cmd == CHESS_KEY_NEXT )
   \                     ??chess_Step_10: (+1)
   \   000000B8   0x78E0             LDRB     R0,[R4, #+3]
   \   000000BA   0x2801             CMP      R0,#+1
   \   000000BC   0xD105             BNE.N    ??chess_Step_11
   2321                {
   2322          	chess_source_pos = chess_GetNextMarked(chess_source_pos, 0);
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x7960             LDRB     R0,[R4, #+5]
   \   000000C2   0x.... 0x....      BL       chess_GetNextMarked
   \   000000C6   0x7160             STRB     R0,[R4, #+5]
   \   000000C8   0xBD31             POP      {R0,R4,R5,PC}
   2323                }
   2324                else if ( chess_key_cmd == CHESS_KEY_PREV )
   \                     ??chess_Step_11: (+1)
   \   000000CA   0x2802             CMP      R0,#+2
   \   000000CC   0xD105             BNE.N    ??chess_Step_12
   2325                {
   2326          	chess_source_pos = chess_GetNextMarked(chess_source_pos, 1);
   \   000000CE   0x2101             MOVS     R1,#+1
   \   000000D0   0x7960             LDRB     R0,[R4, #+5]
   \   000000D2   0x.... 0x....      BL       chess_GetNextMarked
   \   000000D6   0x7160             STRB     R0,[R4, #+5]
   \   000000D8   0xBD31             POP      {R0,R4,R5,PC}
   2327                }
   2328                else if ( chess_key_cmd == CHESS_KEY_SELECT )
   \                     ??chess_Step_12: (+1)
   \   000000DA   0x2803             CMP      R0,#+3
   \   000000DC   0xD15B             BNE.N    ??chess_Step_3
   2329                {
   2330          	if ( chess_source_pos == 255 )
   \   000000DE   0x7965             LDRB     R5,[R4, #+5]
   \   000000E0   0x4628             MOV      R0,R5
   \   000000E2   0x28FF             CMP      R0,#+255
   \   000000E4   0xD102             BNE.N    ??chess_Step_13
   2331          	{
   2332          	  chess_state = CHESS_STATE_MENU;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x7120             STRB     R0,[R4, #+4]
   \   000000EA   0xBD31             POP      {R0,R4,R5,PC}
   2333          	}
   2334          	else
   2335          	{
   2336          	  chess_ClearMarks();
   \                     ??chess_Step_13: (+1)
   \   000000EC   0x.... 0x....      BL       chess_ClearMarks
   2337          	  chess_MarkTargetMoves(chess_source_pos);
   \   000000F0   0x4628             MOV      R0,R5
   \   000000F2   0x.... 0x....      BL       chess_MarkTargetMoves
   2338          	  chess_target_pos = chess_GetNextMarked(255, 0);
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0x20FF             MOVS     R0,#+255
   \   000000FA   0x.... 0x....      BL       chess_GetNextMarked
   \   000000FE   0x71A0             STRB     R0,[R4, #+6]
   2339          	  chess_state = CHESS_STATE_SELECT_TARGET_POS;      
   \   00000100   0x2003             MOVS     R0,#+3
   \   00000102   0x7120             STRB     R0,[R4, #+4]
   \   00000104   0xBD31             POP      {R0,R4,R5,PC}
   2340          	}
   2341                }
   2342                break;
   2343              case CHESS_STATE_SELECT_TARGET_POS:
   2344                if ( chess_key_cmd == CHESS_KEY_NEXT )
   \                     ??chess_Step_14: (+1)
   \   00000106   0x78E0             LDRB     R0,[R4, #+3]
   \   00000108   0x2801             CMP      R0,#+1
   \   0000010A   0xD105             BNE.N    ??chess_Step_15
   2345                {
   2346          	chess_target_pos = chess_GetNextMarked(chess_target_pos, 0);
   \   0000010C   0x2100             MOVS     R1,#+0
   \   0000010E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000110   0x.... 0x....      BL       chess_GetNextMarked
   \   00000114   0x71A0             STRB     R0,[R4, #+6]
   \   00000116   0xBD31             POP      {R0,R4,R5,PC}
   2347                }
   2348                else if ( chess_key_cmd == CHESS_KEY_PREV )
   \                     ??chess_Step_15: (+1)
   \   00000118   0x2802             CMP      R0,#+2
   \   0000011A   0xD105             BNE.N    ??chess_Step_16
   2349                {
   2350          	chess_target_pos = chess_GetNextMarked(chess_target_pos, 1);
   \   0000011C   0x2101             MOVS     R1,#+1
   \   0000011E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000120   0x.... 0x....      BL       chess_GetNextMarked
   \   00000124   0x71A0             STRB     R0,[R4, #+6]
   \   00000126   0xBD31             POP      {R0,R4,R5,PC}
   2351                }
   2352                else if ( chess_key_cmd == CHESS_KEY_BACK )
   \                     ??chess_Step_16: (+1)
   \   00000128   0x2804             CMP      R0,#+4
   \   0000012A   0xD108             BNE.N    ??chess_Step_17
   2353                {
   2354          	chess_ClearMarks();
   \   0000012C   0x.... 0x....      BL       chess_ClearMarks
   2355          	chess_MarkMovable();
   \   00000130   0x.... 0x....      BL       chess_MarkMovable
   2356          	chess_target_pos = ILLEGAL_POSITION;
   \   00000134   0x20FF             MOVS     R0,#+255
   \   00000136   0x71A0             STRB     R0,[R4, #+6]
   2357          	chess_state = CHESS_STATE_SELECT_PIECE;
   \   00000138   0x2002             MOVS     R0,#+2
   \   0000013A   0x7120             STRB     R0,[R4, #+4]
   \   0000013C   0xBD31             POP      {R0,R4,R5,PC}
   2358                }
   2359                else if ( chess_key_cmd == CHESS_KEY_SELECT )
   \                     ??chess_Step_17: (+1)
   \   0000013E   0x2803             CMP      R0,#+3
   \   00000140   0xD129             BNE.N    ??chess_Step_3
   2360                {
   2361          	chess_ManualMove(chess_source_pos, chess_target_pos);
   \   00000142   0x79A1             LDRB     R1,[R4, #+6]
   \   00000144   0x7960             LDRB     R0,[R4, #+5]
   \   00000146   0x.... 0x....      BL       chess_ManualMove
   2362          	if ( lrc_obj.is_game_end != 0 )
   \   0000014A   0x....             LDR.N    R0,??DataTable52_6
   \   0000014C   0x7880             LDRB     R0,[R0, #+2]
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD002             BEQ.N    ??chess_Step_18
   2363          	  chess_state = CHESS_STATE_GAME_END;
   \   00000152   0x2005             MOVS     R0,#+5
   \   00000154   0x7120             STRB     R0,[R4, #+4]
   \   00000156   0xE001             B.N      ??chess_Step_19
   2364          	else
   2365          	  chess_state = CHESS_STATE_THINKING;
   \                     ??chess_Step_18: (+1)
   \   00000158   0x2004             MOVS     R0,#+4
   \   0000015A   0x7120             STRB     R0,[R4, #+4]
   2366          	/* clear marks as some kind of feedback to the user... it simply looks better */
   2367          	chess_source_pos = ILLEGAL_POSITION;
   \                     ??chess_Step_19: (+1)
   \   0000015C   0x20FF             MOVS     R0,#+255
   \   0000015E   0x7160             STRB     R0,[R4, #+5]
   2368          	chess_target_pos = ILLEGAL_POSITION;
   \   00000160   0x71A0             STRB     R0,[R4, #+6]
   2369          	chess_ClearMarks();
   \   00000162   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000166   0x.... 0x....      B.W      chess_ClearMarks
   2370                }
   2371                break;
   2372              case CHESS_STATE_THINKING:
   2373                chess_ComputerMove(2);
   \                     ??chess_Step_20: (+1)
   \   0000016A   0x2002             MOVS     R0,#+2
   \   0000016C   0x.... 0x....      BL       chess_ComputerMove
   2374                if ( lrc_obj.is_game_end != 0 )
   \   00000170   0x....             LDR.N    R0,??DataTable52_6
   \   00000172   0x7880             LDRB     R0,[R0, #+2]
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xD002             BEQ.N    ??chess_Step_21
   2375          	chess_state = CHESS_STATE_GAME_END;
   \   00000178   0x2005             MOVS     R0,#+5
   \   0000017A   0x7120             STRB     R0,[R4, #+4]
   \   0000017C   0xBD31             POP      {R0,R4,R5,PC}
   2376                else
   2377          	chess_state = CHESS_STATE_SELECT_START;
   \                     ??chess_Step_21: (+1)
   \   0000017E   0x2001             MOVS     R0,#+1
   \   00000180   0x7120             STRB     R0,[R4, #+4]
   \   00000182   0xBD31             POP      {R0,R4,R5,PC}
   2378                break;
   2379              case CHESS_STATE_GAME_END:
   2380                if ( chess_key_cmd != CHESS_KEY_NONE )
   \                     ??chess_Step_22: (+1)
   \   00000184   0x78E0             LDRB     R0,[R4, #+3]
   \   00000186   0x2800             CMP      R0,#+0
   \   00000188   0xD005             BEQ.N    ??chess_Step_3
   2381                {
   2382          	chess_state = CHESS_STATE_MENU;  
   \   0000018A   0x2000             MOVS     R0,#+0
   \   0000018C   0x7120             STRB     R0,[R4, #+4]
   2383          	chess_SetupBoard();
   \   0000018E   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000192   0x.... 0x....      B.W      chess_SetupBoard
   2384                }	
   2385                break;
   2386            }
   2387            
   2388          }
   \                     ??chess_Step_3: (+1)
   \   00000196   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   0x........         DC32     lrc_obj

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   0xFFFF8001         DC32     0xffff8001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48:
   \   00000000   0x........         DC32     ce_piece_weight

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_1:
   \   00000000   0x........         DC32     `cu_GetHalfMoveStr::buf`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \   00000000   0x........         DC32     lrc_obj+0x42

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51:
   \   00000000   0x........         DC32     lrc_obj+0x49

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52:
   \   00000000   0x........         DC32     lrc_obj

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_1:
   \   00000000   0x........         DC32     lrc_obj+0x4B

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_2:
   \   00000000   0x........         DC32     mnu_pos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_3:
   \   00000000   0x........         DC32     u8g_font_5x7r

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_4:
   \   00000000   0x........         DC32     u8g_font_5x8r

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_5:
   \   00000000   0x........         DC32     u8g_font_5x7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_6:
   \   00000000   0x........         DC32     lrc_obj+0x45

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x4C 0x69          DC8 "Little Rook Chess"
   \              0x74 0x74    
   \              0x6C 0x65    
   \              0x20 0x52    
   \              0x6F 0x6F    
   \              0x6B 0x20    
   \              0x43 0x68    
   \              0x65 0x73    
   \              0x73 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x4E 0x65          DC8 "New Game (White)"
   \              0x77 0x20    
   \              0x47 0x61    
   \              0x6D 0x65    
   \              0x20 0x28    
   \              0x57 0x68    
   \              0x69 0x74    
   \              0x65 0x29    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x4E 0x65          DC8 "New Game (Black)"
   \              0x77 0x20    
   \              0x47 0x61    
   \              0x6D 0x65    
   \              0x20 0x28    
   \              0x42 0x6C    
   \              0x61 0x63    
   \              0x6B 0x29    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x4F 0x70          DC8 "Options"
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x42 0x6C          DC8 "Black wins"
   \              0x61 0x63    
   \              0x6B 0x20    
   \              0x77 0x69    
   \              0x6E 0x73    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x55 0x6E          DC8 "Undo Move"
   \              0x64 0x6F    
   \              0x20 0x4D    
   \              0x6F 0x76    
   \              0x65 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x52 0x65          DC8 "Return"
   \              0x74 0x75    
   \              0x72 0x6E    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x57 0x68          DC8 "White wins"
   \              0x69 0x74    
   \              0x65 0x20    
   \              0x77 0x69    
   \              0x6E 0x73    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x53 0x74          DC8 "Stalemate"
   \              0x61 0x6C    
   \              0x65 0x6D    
   \              0x61 0x74    
   \              0x65 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0
   2389          
   2390          #endif
   2391          
   2392          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ce_CalculatePositionWeight
         0   -> ce_FindPawnPiece
        16   -> ce_FindPawnPiece
        16   -> ce_FindPieceByStep
      40   ce_Eval
        40   -> cp_GetColor
        40   -> cp_GetFromBoard
        40   -> cp_GetPiece
        40   -> cu_NextPos
        40   -> stack_GetCurrElement
      16   ce_FindPawnPiece
        16   -> cp_GetColor
        16   -> cp_GetFromBoard
        16   -> cp_GetPiece
      32   ce_FindPieceByStep
        32   -> cp_GetColor
        32   -> cp_GetFromBoard
        32   -> cp_GetPiece
       8   ce_GetPositionAttackCount
         8   -> ce_CalculatePositionWeight
       8   ce_GetPositionAttackWeight
         8   -> ce_CalculatePositionWeight
       0   ce_LoopBishop
         0   -> ce_LoopDirsSingleMultiStep
      16   ce_LoopDirsSingleMultiStep
        16   -> ce_LoopRecur
        16   -> cp_GetFromBoard
        16   -> cp_GetPiece
        16   -> stack_GetCurrElement
       8   ce_LoopKing
         0   -> ce_LoopDirsSingleMultiStep
         8   -> ce_LoopRecur
         8   -> cu_IsKingCastling
         8   -> stack_GetCurrElement
       0   ce_LoopKnight
         0   -> ce_LoopDirsSingleMultiStep
      24   ce_LoopPawn
         0   -> ce_LoopPawnSideCapture
        24   -> ce_LoopPawnSideCapture
        24   -> ce_LoopRecur
        24   -> cp_GetFromBoard
        24   -> cp_GetPiece
        24   -> stack_GetCurrElement
       8   ce_LoopPawnSideCapture
         0   -> ce_LoopRecur
         8   -> cp_GetFromBoard
         8   -> cp_GetPiece
         8   -> stack_GetCurrElement
       8   ce_LoopPieces
         8   -> ce_LoopBishop
         8   -> ce_LoopKing
         8   -> ce_LoopKnight
         8   -> ce_LoopPawn
         8   -> ce_LoopQueen
         8   -> ce_LoopRook
         8   -> chess_Thinking
         8   -> cp_GetColor
         8   -> cp_GetFromBoard
         8   -> cp_GetPiece
         8   -> cu_NextPos
         8   -> stack_GetCurrElement
       0   ce_LoopQueen
         0   -> ce_LoopDirsSingleMultiStep
      16   ce_LoopRecur
        16   -> ce_Eval
        16   -> ce_LoopPieces
        16   -> cp_GetFromBoard
        16   -> cp_SetOnBoard
        16   -> cu_IsIllegalPosition
        16   -> cu_Move
        16   -> cu_UndoHalfMove
        16   -> stack_GetCurrElement
        16   -> stack_InitCurrElement
        16   -> stack_Pop
        16   -> stack_Push
        16   -> stack_SetMove
       0   ce_LoopRook
         0   -> ce_LoopDirsSingleMultiStep
       0   chess_ClearMarks
       8   chess_ComputerMove
         8   -> ce_LoopPieces
         0   -> chess_ManualMove
         8   -> cu_ReduceHistoryByFullMove
         8   -> stack_GetCurrElement
         8   -> stack_Init
      24   chess_Draw
        24   -> chess_DrawBoard
        24   -> cu_GetHalfMoveStr
         0   -> mnu_Draw
         0   -> mnu_DrawEntry
        24   -> mnu_DrawHome
        24   -> u8g_DrawStr
        24   -> u8g_SetDefaultForegroundColor
        24   -> u8g_SetFont
      40   chess_DrawBoard
         0   -> chess_DrawFrame
        40   -> chess_DrawFrame
        40   -> cp_GetColor
        40   -> cp_GetPiece
        40   -> u8g_DrawBitmapP
        40   -> u8g_DrawBox
        40   -> u8g_DrawPixel
        40   -> u8g_SetDefaultBackgroundColor
        40   -> u8g_SetDefaultForegroundColor
        40   -> u8g_SetDefaultMidColor
      24   chess_DrawFrame
        24   -> u8g_DrawFrame
        24   -> u8g_SetDefaultForegroundColor
      24   chess_GetNextMarked
        24   -> cp_GetFromBoard
        24   -> cu_NextPos
        24   -> cu_PrevPos
       8   chess_Init
         0   -> chess_SetupBoard
      32   chess_ManualMove
        32   -> ce_GetPositionAttackCount
        32   -> ce_LoopPieces
        32   -> cp_GetColor
        32   -> cp_GetFromBoard
        32   -> cp_GetPiece
        32   -> cu_Move
        32   -> cu_NextPos
        32   -> cu_ReduceHistoryByFullMove
        32   -> stack_GetCurrElement
        32   -> stack_Init
       8   chess_MarkMovable
         0   -> ce_LoopPieces
         8   -> stack_Init
      16   chess_MarkTargetMoves
         0   -> ce_LoopPieces
        16   -> cp_GetColor
        16   -> cp_GetFromBoard
        16   -> stack_GetCurrElement
        16   -> stack_Init
      16   chess_SetupBoard
        16   -> cp_Construct
        16   -> cu_ClearBoard
      16   chess_SetupBoardTest01
        16   -> cp_Construct
        16   -> cu_ClearBoard
      16   chess_Step
         0   -> chess_ClearMarks
        16   -> chess_ClearMarks
        16   -> chess_ComputerMove
        16   -> chess_GetNextMarked
        16   -> chess_ManualMove
        16   -> chess_MarkMovable
        16   -> chess_MarkTargetMoves
         0   -> chess_SetupBoard
        16   -> chess_SetupBoard
        16   -> cu_UndoHalfMove
        16   -> mnu_Step
       0   chess_Thinking
       0   cp_Construct
       0   cp_GetColor
       8   cp_GetFromBoard
         8   -> cu_gpos2bpos
       0   cp_GetPiece
       8   cp_SetOnBoard
         8   -> cu_gpos2bpos
       0   cu_ClearBoard
         0   -> cu_ClearMoveHistory
       0   cu_ClearMoveHistory
      16   cu_GetHalfMoveStr
        16   -> cp_GetPiece
        16   -> cu_add_pos
       8   cu_IsIllegalPosition
         8   -> cp_GetColor
         8   -> cp_GetFromBoard
      24   cu_IsKingCastling
        24   -> ce_GetPositionAttackWeight
        24   -> cp_GetFromBoard
        24   -> cp_GetPiece
        24   -> stack_GetCurrElement
      40   cu_Move
        40   -> cp_GetColor
        40   -> cp_GetFromBoard
        40   -> cp_GetPiece
         0   -> cp_SetOnBoard
        40   -> cp_SetOnBoard
        40   -> cu_PushHalfMove
       0   cu_NextPos
       0   cu_PrevPos
       0   cu_PushHalfMove
      16   cu_ReduceHistoryByFullMove
        16   -> __aeabi_memcpy
       8   cu_UndoHalfMove
         0   -> cp_SetOnBoard
         8   -> cp_SetOnBoard
       0   cu_add_pos
       0   cu_gpos2bpos
      16   mnu_Draw
        16   -> mnu_DrawEntry
      40   mnu_DrawEntry
        40   -> u8g_DrawBox
        40   -> u8g_DrawFrame
        40   -> u8g_DrawStr
        40   -> u8g_GetStrWidth
        40   -> u8g_SetDefaultBackgroundColor
        40   -> u8g_SetDefaultForegroundColor
        40   -> u8g_SetFont
      24   mnu_DrawHome
        24   -> u8g_DrawFrame
        24   -> u8g_DrawStrP
        24   -> u8g_SetDefaultForegroundColor
        24   -> u8g_SetFont
       0   mnu_Step
       0   stack_GetCurrElement
       8   stack_Init
         8   -> stack_GetCurrElement
         8   -> stack_InitCurrElement
       8   stack_InitCurrElement
         8   -> stack_GetCurrElement
       0   stack_Pop
       8   stack_Push
         8   -> stack_GetCurrElement
      16   stack_SetMove
        16   -> stack_GetCurrElement


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable42
       4  ??DataTable43
       4  ??DataTable48
       4  ??DataTable48_1
       4  ??DataTable50
       4  ??DataTable51
       4  ??DataTable52
       4  ??DataTable52_1
       4  ??DataTable52_2
       4  ??DataTable52_3
       4  ??DataTable52_4
       4  ??DataTable52_5
       4  ??DataTable52_6
      20  ?_0
      20  ?_1
      20  ?_2
      12  ?_3
       8  ?_4
       8  ?_5
      12  ?_6
      12  ?_7
      12  ?_8
      16  buf
          chess_piece_to_char
     142  ce_CalculatePositionWeight
     266  ce_Eval
      58  ce_FindPawnPiece
     130  ce_FindPieceByStep
      20  ce_GetPositionAttackCount
      20  ce_GetPositionAttackWeight
       8  ce_LoopBishop
      60  ce_LoopDirsSingleMultiStep
     142  ce_LoopKing
       8  ce_LoopKnight
     152  ce_LoopPawn
      80  ce_LoopPawnSideCapture
     108  ce_LoopPieces
       8  ce_LoopQueen
     160  ce_LoopRecur
       8  ce_LoopRook
       8  ce_dir_offset_bishop
      12  ce_dir_offset_knight
      12  ce_dir_offset_queen
       8  ce_dir_offset_rook
      16  ce_piece_weight
          ce_pos_weight
      26  chess_ClearMarks
      34  chess_ComputerMove
     250  chess_Draw
     600  chess_DrawBoard
     120  chess_DrawFrame
      70  chess_GetNextMarked
      90  chess_Init
     182  chess_ManualMove
      24  chess_MarkMovable
      44  chess_MarkTargetMoves
     212  chess_SetupBoard
      66  chess_SetupBoardTest01
     408  chess_Step
       2  chess_Thinking
      48  chess_black_pieces_bm
      48  chess_pieces_body_bm
      10  cp_Construct
       6  cp_GetColor
      16  cp_GetFromBoard
       6  cp_GetPiece
      18  cp_SetOnBoard
      54  cu_ClearBoard
      10  cu_ClearMoveHistory
     106  cu_GetHalfMoveStr
      34  cu_IsIllegalPosition
     100  cu_IsKingCastling
     454  cu_Move
      22  cu_NextPos
      26  cu_PrevPos
      40  cu_PushHalfMove
      56  cu_ReduceHistoryByFullMove
      94  cu_UndoHalfMove
      30  cu_add_pos
      16  cu_gpos2bpos
     248  lrc_obj
      92  mnu_Draw
     160  mnu_DrawEntry
      82  mnu_DrawHome
      46  mnu_Step
      36  mnu_pos
          mnu_max
          chess_key_code
          chess_key_cmd
          chess_state
          chess_source_pos
          chess_target_pos
          chess_low_edge
          chess_boxsize
          chess_boxoffset
          lrc_u8g
          mnu_title
          mnu_list
       8  stack_GetCurrElement
      52  stack_Init
      20  stack_InitCurrElement
      26  stack_Pop
      52  stack_Push
      30  stack_SetMove

 
   248 bytes in section .bss
    68 bytes in section .data
    80 bytes in section .rodata
 5 396 bytes in section .text
 
 5 396 bytes of CODE  memory
    80 bytes of CONST memory
   316 bytes of DATA  memory

Errors: none
Warnings: 11
