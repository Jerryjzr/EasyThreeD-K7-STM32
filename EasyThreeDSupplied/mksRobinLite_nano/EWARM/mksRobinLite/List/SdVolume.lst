###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         07/Apr/2021  11:05:10
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\SdVolume.cpp
#    Command line =  
#        -f C:\Users\PLT\AppData\Local\Temp\EW9957.tmp
#        (C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\SdVolume.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lC
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lA
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Src\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/l6474\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/MotorControl\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino/avr\
#        -I C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc/Logo\ -Om --c++
#        --no_exceptions --no_rtti -I "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I "D:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List\SdVolume.lst
#    Object file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj\SdVolume.o
#
###############################################################################

C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\SdVolume.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * Arduino SdFat Library
     25           * Copyright (C) 2009 by William Greiman
     26           *
     27           * This file is part of the Arduino Sd2Card Library
     28           */
     29          #include "Marlin.h"

    #define SDSS   18
            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\pins_MKS_ROBIN_LITE.h",161  Warning[Pa181]: 
          incompatible redefinition of macro "SDSS" (declared at line 62)

  #define UNUSED(x) ((void)(x))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pa181]: 
          incompatible redefinition of macro "UNUSED" (declared at line 88 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\macros.h")

  #define PRINT_LED_PIN         PDout(2)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\BSP\STM32MKS-3dPrinter\mks_fastio.h",14  Warning[Pa181]: 
          incompatible redefinition of macro "PRINT_LED_PIN" (declared at line
          146 of "C:\Users\PLT\Desktop\mksRobinLite_nano\Inc\main.h")
     30          #if ENABLED(SDSUPPORT)
     31          
     32          #include "SdVolume.h"

   \                                 In section .text, align 2
   \   __interwork __softfp bool SdVolume::fatPutEOC(uint32_t)
   \                     _ZN8SdVolume9fatPutEOCEj: (+1)
   \        0x0   0xF06F 0x4270      MVN      R2,#-268435456
   \        0x4   0x.... 0x....      B.W      _ZN8SdVolume6fatPutEjj

   \                                 In section .text, align 4
   \   __interwork __softfp bool SdVolume::isEOC(uint32_t) const
   \                     _ZNK8SdVolume5isEOCEj: (+1)
   \        0x0   0xF890 0x0020      LDRB     R0,[R0, #+32]
   \        0x4   0x2810             CMP      R0,#+16
   \        0x6   0xD106             BNE.N    ??isEOC_1
   \        0x8   0xF64F 0x70F8      MOVW     R0,#+65528
   \        0xC   0x4281             CMP      R1,R0
   \        0xE   0x4180             SBCS     R0,R0,R0
   \       0x10   0x43C0             MVNS     R0,R0
   \       0x12   0x0FC0             LSRS     R0,R0,#+31
   \       0x14   0x4770             BX       LR
   \                     ??isEOC_1: (+1)
   \       0x16   0x4803             LDR.N    R0,??isEOC_0     ;; 0xffffff8
   \       0x18   0x4281             CMP      R1,R0
   \       0x1A   0x4180             SBCS     R0,R0,R0
   \       0x1C   0x43C0             MVNS     R0,R0
   \       0x1E   0x0FC0             LSRS     R0,R0,#+31
   \       0x20   0x4770             BX       LR               ;; return
   \       0x22   0xBF00             Nop      
   \                     ??isEOC_0:
   \       0x24   0x0FFF'FFF8        DC32     0xffffff8
     33          //------------------------------------------------------------------------------
     34          #if !USE_MULTIPLE_CARDS
     35            // raw block cache

   \                                 In section .bss, align 4
     36            uint32_t SdVolume::cacheBlockNumber_;  // current block number
     37            cache_t  SdVolume::cacheBuffer_;       // 512 byte cache for Sd2Card
     38            Sd2Card* SdVolume::sdCard_;            // pointer to SD card object
     39            bool     SdVolume::cacheDirty_;        // cacheFlush() will write block if true
   \                     _ZN8SdVolume11cacheDirty_E:
   \        0x0                      DS8 1
   \        0x1                      DS8 3
   \                     _ZN8SdVolume17cacheBlockNumber_E:
   \        0x4                      DS8 4
   \                     _ZN8SdVolume7sdCard_E:
   \        0x8                      DS8 4
     40            uint32_t SdVolume::cacheMirrorBlock_;  // mirror  block for second FAT
   \                     _ZN8SdVolume17cacheMirrorBlock_E:
   \        0xC                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN8SdVolume12cacheBuffer_E:
   \        0x0                      DS8 512
     41          #endif  // USE_MULTIPLE_CARDS
     42          //------------------------------------------------------------------------------
     43          // find a contiguous group of clusters

   \                                 In section .text, align 2, keep-with-next
     44          bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
   \                     _ZN8SdVolume15allocContiguousEjPj: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x4614             MOV      R4,R2
     45            // start of group
     46            uint32_t bgnCluster;
     47            // end of group
     48            uint32_t endCluster;
     49            // last cluster of FAT
     50            uint32_t fatEnd = clusterCount_ + 1;
   \        0xA   0xF8D9 0xB00C      LDR      R11,[R9, #+12]
   \        0xE   0xF10B 0x0B01      ADD      R11,R11,#+1
     51          
     52            // flag to save place to start next search
     53            bool setStart;
     54          
     55            // set search start cluster
     56            if (*curCluster) {
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??allocContiguous_0
     57              // try to make file contiguous
     58              bgnCluster = *curCluster + 1;
   \       0x18   0x1C40             ADDS     R0,R0,#+1
     59          
     60              // don't save new start location
     61              setStart = false;
   \       0x1A   0x2500             MOVS     R5,#+0
   \       0x1C   0xE007             B.N      ??allocContiguous_1
     62            }
     63            else {
     64              // start at likely place for free cluster
     65              bgnCluster = allocSearchStart_;
   \                     ??allocContiguous_0: (+1)
   \       0x1E   0xF8D9 0x0000      LDR      R0,[R9, #+0]
     66          
     67              // save next search start if one cluster
     68              setStart = count == 1;
   \       0x22   0xF1BA 0x0F01      CMP      R10,#+1
   \       0x26   0xD101             BNE.N    ??allocContiguous_2
   \       0x28   0x2501             MOVS     R5,#+1
   \       0x2A   0xE000             B.N      ??allocContiguous_1
   \                     ??allocContiguous_2: (+1)
   \       0x2C   0x2500             MOVS     R5,#+0
     69            }
     70            // end of group
     71            endCluster = bgnCluster;
   \                     ??allocContiguous_1: (+1)
   \       0x2E   0x4607             MOV      R7,R0
     72          
     73            // search the FAT for free clusters
     74            for (uint32_t n = 0;; n++, endCluster++) {
   \       0x30   0x2600             MOVS     R6,#+0
   \       0x32   0x4680             MOV      R8,R0
   \       0x34   0xE003             B.N      ??allocContiguous_3
     75              // can't find space checked all clusters
     76              if (n >= clusterCount_) goto fail;
     77          
     78              // past end - start from beginning of FAT
     79              if (endCluster > fatEnd) {
     80                bgnCluster = endCluster = 2;
     81              }
     82              uint32_t f;
     83              if (!fatGet(endCluster, &f)) goto fail;
     84          
     85              if (f != 0) {
     86                // cluster in use try next cluster as bgnCluster
     87                bgnCluster = endCluster + 1;
   \                     ??allocContiguous_4: (+1)
   \       0x36   0xF107 0x0801      ADD      R8,R7,#+1
     88              }
   \                     ??allocContiguous_5: (+1)
   \       0x3A   0x1C76             ADDS     R6,R6,#+1
   \       0x3C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??allocContiguous_3: (+1)
   \       0x3E   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0x42   0x4286             CMP      R6,R0
   \       0x44   0xD218             BCS.N    ??allocContiguous_6
   \       0x46   0x45BB             CMP      R11,R7
   \       0x48   0xD201             BCS.N    ??allocContiguous_7
   \       0x4A   0x2702             MOVS     R7,#+2
   \       0x4C   0x46B8             MOV      R8,R7
   \                     ??allocContiguous_7: (+1)
   \       0x4E   0x466A             MOV      R2,SP
   \       0x50   0x4639             MOV      R1,R7
   \       0x52   0x4648             MOV      R0,R9
   \       0x54   0x.... 0x....      BL       _ZN8SdVolume6fatGetEjPj
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD00D             BEQ.N    ??allocContiguous_6
   \       0x5C   0x9800             LDR      R0,[SP, #+0]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD1E9             BNE.N    ??allocContiguous_4
     89              else if ((endCluster - bgnCluster + 1) == count) {
   \       0x62   0xEBA7 0x0008      SUB      R0,R7,R8
   \       0x66   0x1C40             ADDS     R0,R0,#+1
   \       0x68   0x4550             CMP      R0,R10
   \       0x6A   0xD1E6             BNE.N    ??allocContiguous_5
     90                // done - found space
     91                break;
     92              }
     93            }
     94            // mark end of chain
     95            if (!fatPutEOC(endCluster)) goto fail;
   \       0x6C   0x4639             MOV      R1,R7
   \       0x6E   0x4648             MOV      R0,R9
   \       0x70   0x.... 0x....      BL       _ZN8SdVolume9fatPutEOCEj
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD10B             BNE.N    ??allocContiguous_8
     96          
     97            // link clusters
     98            while (endCluster > bgnCluster) {
     99              if (!fatPut(endCluster - 1, endCluster)) goto fail;
    100              endCluster--;
    101            }
    102            if (*curCluster != 0) {
    103              // connect chains
    104              if (!fatPut(*curCluster, bgnCluster)) goto fail;
    105            }
    106            // return first cluster number to caller
    107            *curCluster = bgnCluster;
    108          
    109            // remember possible next free cluster
    110            if (setStart) allocSearchStart_ = bgnCluster + 1;
    111          
    112            return true;
    113          fail:
    114            return false;
   \                     ??allocContiguous_6: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??allocContiguous_9: (+1)
   \       0x7A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??allocContiguous_10: (+1)
   \       0x7E   0x1E7E             SUBS     R6,R7,#+1
   \       0x80   0x463A             MOV      R2,R7
   \       0x82   0x4631             MOV      R1,R6
   \       0x84   0x4648             MOV      R0,R9
   \       0x86   0x.... 0x....      BL       _ZN8SdVolume6fatPutEjj
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD0F4             BEQ.N    ??allocContiguous_6
   \       0x8E   0x4637             MOV      R7,R6
   \                     ??allocContiguous_8: (+1)
   \       0x90   0x45B8             CMP      R8,R7
   \       0x92   0xD3F4             BCC.N    ??allocContiguous_10
   \       0x94   0x6821             LDR      R1,[R4, #+0]
   \       0x96   0x2900             CMP      R1,#+0
   \       0x98   0xD005             BEQ.N    ??allocContiguous_11
   \       0x9A   0x4642             MOV      R2,R8
   \       0x9C   0x4648             MOV      R0,R9
   \       0x9E   0x.... 0x....      BL       _ZN8SdVolume6fatPutEjj
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD0E8             BEQ.N    ??allocContiguous_6
   \                     ??allocContiguous_11: (+1)
   \       0xA6   0xF8C4 0x8000      STR      R8,[R4, #+0]
   \       0xAA   0x2D00             CMP      R5,#+0
   \       0xAC   0xD003             BEQ.N    ??allocContiguous_12
   \       0xAE   0xF108 0x0801      ADD      R8,R8,#+1
   \       0xB2   0xF8C9 0x8000      STR      R8,[R9, #+0]
   \                     ??allocContiguous_12: (+1)
   \       0xB6   0x2001             MOVS     R0,#+1
   \       0xB8   0xE7DF             B.N      ??allocContiguous_9
    115          }
    116          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    117          bool SdVolume::cacheFlush() {
   \                     _ZN8SdVolume10cacheFlushEv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    118            if (cacheDirty_) {
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable6
   \        0x6   0x7820             LDRB     R0,[R4, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD015             BEQ.N    ??cacheFlush_0
    119              if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
   \        0xC   0x.... 0x....      LDR.W    R5,??DataTable6_1
   \       0x10   0x462A             MOV      R2,R5
   \       0x12   0x6861             LDR      R1,[R4, #+4]
   \       0x14   0x68A0             LDR      R0,[R4, #+8]
   \       0x16   0x.... 0x....      BL       _ZN7Sd2Card10writeBlockEjPKh
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD00E             BEQ.N    ??cacheFlush_1
    120                goto fail;
    121              }
    122              // mirror FAT tables
    123              if (cacheMirrorBlock_) {
   \       0x1E   0x68E1             LDR      R1,[R4, #+12]
   \       0x20   0x2900             CMP      R1,#+0
   \       0x22   0xD007             BEQ.N    ??cacheFlush_2
    124                if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
   \       0x24   0x462A             MOV      R2,R5
   \       0x26   0x68A0             LDR      R0,[R4, #+8]
   \       0x28   0x.... 0x....      BL       _ZN7Sd2Card10writeBlockEjPKh
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD005             BEQ.N    ??cacheFlush_1
    125                  goto fail;
    126                }
    127                cacheMirrorBlock_ = 0;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x60E0             STR      R0,[R4, #+12]
    128              }
    129              cacheDirty_ = 0;
   \                     ??cacheFlush_2: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x7020             STRB     R0,[R4, #+0]
    130            }
    131            return true;
   \                     ??cacheFlush_0: (+1)
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
    132          fail:
    133            return false;
   \                     ??cacheFlush_1: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    134          }
    135          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    136          bool SdVolume::cacheRawBlock(uint32_t blockNumber, bool dirty) {
   \                     _ZN8SdVolume13cacheRawBlockEjb: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    137            if (cacheBlockNumber_ != blockNumber) {
   \        0x6   0x.... 0x....      LDR.W    R6,??DataTable6
   \        0xA   0x6870             LDR      R0,[R6, #+4]
   \        0xC   0x42A0             CMP      R0,R4
   \        0xE   0xD00C             BEQ.N    ??cacheRawBlock_0
    138              if (!cacheFlush()) goto fail;
   \       0x10   0x.... 0x....      BL       _ZN8SdVolume10cacheFlushEv
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD00E             BEQ.N    ??cacheRawBlock_1
    139              if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) goto fail;
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable6_1
   \       0x1C   0x4621             MOV      R1,R4
   \       0x1E   0x68B0             LDR      R0,[R6, #+8]
   \       0x20   0x.... 0x....      BL       _ZN7Sd2Card9readBlockEjPh
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD006             BEQ.N    ??cacheRawBlock_1
    140              cacheBlockNumber_ = blockNumber;
   \       0x28   0x6074             STR      R4,[R6, #+4]
    141            }
    142            if (dirty) cacheDirty_ = true;
   \                     ??cacheRawBlock_0: (+1)
   \       0x2A   0x2D00             CMP      R5,#+0
   \       0x2C   0xD001             BEQ.N    ??cacheRawBlock_2
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x7030             STRB     R0,[R6, #+0]
    143            return true;
   \                     ??cacheRawBlock_2: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xBD70             POP      {R4-R6,PC}
    144          fail:
    145            return false;
   \                     ??cacheRawBlock_1: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD70             POP      {R4-R6,PC}       ;; return
    146          }
    147          //------------------------------------------------------------------------------
    148          // return the size in bytes of a cluster chain

   \                                 In section .text, align 2, keep-with-next
    149          bool SdVolume::chainSize(uint32_t cluster, uint32_t* size) {
   \                     _ZN8SdVolume9chainSizeEjPj: (+1)
   \        0x0   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4615             MOV      R5,R2
    150            uint32_t s = 0;
   \        0x6   0x2600             MOVS     R6,#+0
    151            do {
    152              if (!fatGet(cluster, &cluster)) goto fail;
   \                     ??chainSize_0: (+1)
   \        0x8   0xAA01             ADD      R2,SP,#+4
   \        0xA   0x9901             LDR      R1,[SP, #+4]
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _ZN8SdVolume6fatGetEjPj
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD00D             BEQ.N    ??chainSize_1
    153              s += 512UL << clusterSizeShift_;
   \       0x16   0xF44F 0x7000      MOV      R0,#+512
   \       0x1A   0x7C21             LDRB     R1,[R4, #+16]
   \       0x1C   0x4088             LSLS     R0,R0,R1
   \       0x1E   0x1986             ADDS     R6,R0,R6
    154            } while (!isEOC(cluster));
   \       0x20   0x9901             LDR      R1,[SP, #+4]
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x.... 0x....      BL       _ZNK8SdVolume5isEOCEj
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD0ED             BEQ.N    ??chainSize_0
    155            *size = s;
   \       0x2C   0x602E             STR      R6,[R5, #+0]
    156            return true;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    157          fail:
    158            return false;
   \                     ??chainSize_1: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD76             POP      {R1,R2,R4-R6,PC}
    159          }
    160          //------------------------------------------------------------------------------
    161          // Fetch a FAT entry

   \                                 In section .text, align 2, keep-with-next
    162          bool SdVolume::fatGet(uint32_t cluster, uint32_t* value) {
   \                     _ZN8SdVolume6fatGetEjPj: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    163            uint32_t lba;
    164            if (cluster > (clusterCount_ + 1)) goto fail;
   \        0x8   0x68E0             LDR      R0,[R4, #+12]
   \        0xA   0x1C40             ADDS     R0,R0,#+1
   \        0xC   0x42A8             CMP      R0,R5
   \        0xE   0xD329             BCC.N    ??fatGet_0
    165            if (FAT12_SUPPORT && fatType_ == 12) {
    166              uint16_t index = cluster;
    167              index += index >> 1;
    168              lba = fatStartBlock_ + (index >> 9);
    169              if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto fail;
    170              index &= 0X1FF;
    171              uint16_t tmp = cacheBuffer_.data[index];
    172              index++;
    173              if (index == 512) {
    174                if (!cacheRawBlock(lba + 1, CACHE_FOR_READ)) goto fail;
    175                index = 0;
    176              }
    177              tmp |= cacheBuffer_.data[index] << 8;
    178              *value = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
    179              return true;
    180            }
    181            if (fatType_ == 16) {
   \       0x10   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \       0x14   0x2810             CMP      R0,#+16
   \       0x16   0xD103             BNE.N    ??fatGet_1
    182              lba = fatStartBlock_ + (cluster >> 8);
   \       0x18   0x69E0             LDR      R0,[R4, #+28]
   \       0x1A   0xEB00 0x2015      ADD      R0,R0,R5, LSR #+8
   \       0x1E   0xE004             B.N      ??fatGet_2
    183            }
    184            else if (fatType_ == 32) {
   \                     ??fatGet_1: (+1)
   \       0x20   0x2820             CMP      R0,#+32
   \       0x22   0xD11F             BNE.N    ??fatGet_0
    185              lba = fatStartBlock_ + (cluster >> 7);
   \       0x24   0x69E0             LDR      R0,[R4, #+28]
   \       0x26   0xEB00 0x10D5      ADD      R0,R0,R5, LSR #+7
    186            }
    187            else {
    188              goto fail;
    189            }
    190            if (lba != cacheBlockNumber_) {
   \                     ??fatGet_2: (+1)
   \       0x2A   0x....             LDR.N    R1,??DataTable6
   \       0x2C   0x6849             LDR      R1,[R1, #+4]
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD004             BEQ.N    ??fatGet_3
    191              if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto fail;
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD013             BEQ.N    ??fatGet_0
    192            }
    193            if (fatType_ == 16) {
   \                     ??fatGet_3: (+1)
   \       0x3C   0x....             LDR.N    R0,??DataTable6_1
   \       0x3E   0xF894 0x1020      LDRB     R1,[R4, #+32]
   \       0x42   0x2910             CMP      R1,#+16
   \       0x44   0xD105             BNE.N    ??fatGet_4
    194              *value = cacheBuffer_.fat16[cluster & 0XFF];
   \       0x46   0xF005 0x05FF      AND      R5,R5,#0xFF
   \       0x4A   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \       0x4E   0x6030             STR      R0,[R6, #+0]
   \       0x50   0xE006             B.N      ??fatGet_5
    195            }
    196            else {
    197              *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
   \                     ??fatGet_4: (+1)
   \       0x52   0xF005 0x057F      AND      R5,R5,#0x7F
   \       0x56   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \       0x5A   0xF020 0x4070      BIC      R0,R0,#0xF0000000
   \       0x5E   0x6030             STR      R0,[R6, #+0]
    198            }
    199            return true;
   \                     ??fatGet_5: (+1)
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0xBD70             POP      {R4-R6,PC}
    200          fail:
    201            return false;
   \                     ??fatGet_0: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xBD70             POP      {R4-R6,PC}       ;; return
    202          }
    203          //------------------------------------------------------------------------------
    204          // Store a FAT entry

   \                                 In section .text, align 2, keep-with-next
    205          bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {
   \                     _ZN8SdVolume6fatPutEjj: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4617             MOV      R7,R2
    206            uint32_t lba;
    207            // error if reserved cluster
    208            if (cluster < 2) goto fail;
   \        0x8   0x2E01             CMP      R6,#+1
   \        0xA   0xD92D             BLS.N    ??fatPut_0
    209          
    210            // error if not in FAT
    211            if (cluster > (clusterCount_ + 1)) goto fail;
   \        0xC   0x68E0             LDR      R0,[R4, #+12]
   \        0xE   0x1C40             ADDS     R0,R0,#+1
   \       0x10   0x42B0             CMP      R0,R6
   \       0x12   0xD329             BCC.N    ??fatPut_0
    212          
    213            if (FAT12_SUPPORT && fatType_ == 12) {
    214              uint16_t index = cluster;
    215              index += index >> 1;
    216              lba = fatStartBlock_ + (index >> 9);
    217              if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;
    218              // mirror second FAT
    219              if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
    220              index &= 0X1FF;
    221              uint8_t tmp = value;
    222              if (cluster & 1) {
    223                tmp = (cacheBuffer_.data[index] & 0XF) | tmp << 4;
    224              }
    225              cacheBuffer_.data[index] = tmp;
    226              index++;
    227              if (index == 512) {
    228                lba++;
    229                index = 0;
    230                if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;
    231                // mirror second FAT
    232                if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
    233              }
    234              tmp = value >> 4;
    235              if (!(cluster & 1)) {
    236                tmp = ((cacheBuffer_.data[index] & 0XF0)) | tmp >> 4;
    237              }
    238              cacheBuffer_.data[index] = tmp;
    239              return true;
    240            }
    241            if (fatType_ == 16) {
   \       0x14   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \       0x18   0x2810             CMP      R0,#+16
   \       0x1A   0xD103             BNE.N    ??fatPut_1
    242              lba = fatStartBlock_ + (cluster >> 8);
   \       0x1C   0x69E5             LDR      R5,[R4, #+28]
   \       0x1E   0xEB05 0x2516      ADD      R5,R5,R6, LSR #+8
   \       0x22   0xE004             B.N      ??fatPut_2
    243            }
    244            else if (fatType_ == 32) {
   \                     ??fatPut_1: (+1)
   \       0x24   0x2820             CMP      R0,#+32
   \       0x26   0xD11F             BNE.N    ??fatPut_0
    245              lba = fatStartBlock_ + (cluster >> 7);
   \       0x28   0x69E5             LDR      R5,[R4, #+28]
   \       0x2A   0xEB05 0x15D6      ADD      R5,R5,R6, LSR #+7
    246            }
    247            else {
    248              goto fail;
    249            }
    250            if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;
   \                     ??fatPut_2: (+1)
   \       0x2E   0x2101             MOVS     R1,#+1
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD016             BEQ.N    ??fatPut_0
    251            // store entry
    252            if (fatType_ == 16) {
   \       0x3A   0x....             LDR.N    R0,??DataTable6_1
   \       0x3C   0xF894 0x1020      LDRB     R1,[R4, #+32]
   \       0x40   0x2910             CMP      R1,#+16
   \       0x42   0xD104             BNE.N    ??fatPut_3
    253              cacheBuffer_.fat16[cluster & 0XFF] = value;
   \       0x44   0xF006 0x06FF      AND      R6,R6,#0xFF
   \       0x48   0xF820 0x7016      STRH     R7,[R0, R6, LSL #+1]
   \       0x4C   0xE003             B.N      ??fatPut_4
    254            }
    255            else {
    256              cacheBuffer_.fat32[cluster & 0X7F] = value;
   \                     ??fatPut_3: (+1)
   \       0x4E   0xF006 0x067F      AND      R6,R6,#0x7F
   \       0x52   0xF840 0x7026      STR      R7,[R0, R6, LSL #+2]
    257            }
    258            // mirror second FAT
    259            if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
   \                     ??fatPut_4: (+1)
   \       0x56   0x7E20             LDRB     R0,[R4, #+24]
   \       0x58   0x2802             CMP      R0,#+2
   \       0x5A   0xDB03             BLT.N    ??fatPut_5
   \       0x5C   0x68A0             LDR      R0,[R4, #+8]
   \       0x5E   0x1945             ADDS     R5,R0,R5
   \       0x60   0x....             LDR.N    R0,??DataTable6
   \       0x62   0x60C5             STR      R5,[R0, #+12]
    260            return true;
   \                     ??fatPut_5: (+1)
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xBDF2             POP      {R1,R4-R7,PC}
    261          fail:
    262            return false;
   \                     ??fatPut_0: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    263          }
    264          //------------------------------------------------------------------------------
    265          // free a cluster chain

   \                                 In section .text, align 2, keep-with-next
    266          bool SdVolume::freeChain(uint32_t cluster) {
   \                     _ZN8SdVolume9freeChainEj: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    267            uint32_t next;
    268          
    269            // clear free cluster location
    270            allocSearchStart_ = 2;
   \        0x6   0x2002             MOVS     R0,#+2
   \        0x8   0x6020             STR      R0,[R4, #+0]
    271          
    272            do {
    273              if (!fatGet(cluster, &next)) goto fail;
   \                     ??freeChain_0: (+1)
   \        0xA   0x466A             MOV      R2,SP
   \        0xC   0x4629             MOV      R1,R5
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       _ZN8SdVolume6fatGetEjPj
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD00F             BEQ.N    ??freeChain_1
    274          
    275              // free cluster
    276              if (!fatPut(cluster, 0)) goto fail;
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x4629             MOV      R1,R5
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       _ZN8SdVolume6fatPutEjj
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD008             BEQ.N    ??freeChain_1
    277          
    278              cluster = next;
   \       0x26   0x9D00             LDR      R5,[SP, #+0]
    279            } while (!isEOC(cluster));
   \       0x28   0x4629             MOV      R1,R5
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       _ZNK8SdVolume5isEOCEj
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD0EA             BEQ.N    ??freeChain_0
    280          
    281            return true;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
    282          fail:
    283            return false;
   \                     ??freeChain_1: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    284          }
    285          //------------------------------------------------------------------------------
    286          /** Volume free space in clusters.
    287           *
    288           * \return Count of free clusters for success or -1 if an error occurs.
    289           */

   \                                 In section .text, align 2, keep-with-next
    290          int32_t SdVolume::freeClusterCount() {
   \                     _ZN8SdVolume16freeClusterCountEv: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
    291            uint32_t free = 0;
   \        0x6   0x2600             MOVS     R6,#+0
    292            uint16_t n;
    293            uint32_t todo = clusterCount_ + 2;
   \        0x8   0x68EC             LDR      R4,[R5, #+12]
   \        0xA   0x1CA4             ADDS     R4,R4,#+2
    294          
    295            if (fatType_ == 16) {
   \        0xC   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0x10   0x2810             CMP      R0,#+16
   \       0x12   0xD102             BNE.N    ??freeClusterCount_0
    296              n = 256;
   \       0x14   0xF44F 0x7780      MOV      R7,#+256
   \       0x18   0xE002             B.N      ??freeClusterCount_1
    297            }
    298            else if (fatType_ == 32) {
   \                     ??freeClusterCount_0: (+1)
   \       0x1A   0x2820             CMP      R0,#+32
   \       0x1C   0xD12D             BNE.N    ??freeClusterCount_2
    299              n = 128;
   \       0x1E   0x2780             MOVS     R7,#+128
    300            }
    301            else {
    302              // put FAT12 here
    303              return -1;
    304            }
    305          
    306            for (uint32_t lba = fatStartBlock_; todo; todo -= n, lba++) {
   \                     ??freeClusterCount_1: (+1)
   \       0x20   0xF8D5 0x801C      LDR      R8,[R5, #+28]
   \       0x24   0xE00C             B.N      ??freeClusterCount_3
    307              if (!cacheRawBlock(lba, CACHE_FOR_READ)) return -1;
    308              NOMORE(n, todo);
    309              if (fatType_ == 16) {
    310                for (uint16_t i = 0; i < n; i++) {
    311                  if (cacheBuffer_.fat16[i] == 0) free++;
    312                }
    313              }
    314              else {
    315                for (uint16_t i = 0; i < n; i++) {
    316                  if (cacheBuffer_.fat32[i] == 0) free++;
   \                     ??freeClusterCount_4: (+1)
   \       0x26   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD100             BNE.N    ??freeClusterCount_5
   \       0x2E   0x1C76             ADDS     R6,R6,#+1
    317                }
   \                     ??freeClusterCount_5: (+1)
   \       0x30   0x1C49             ADDS     R1,R1,#+1
   \                     ??freeClusterCount_6: (+1)
   \       0x32   0x4608             MOV      R0,R1
   \       0x34   0xB280             UXTH     R0,R0
   \       0x36   0x42B8             CMP      R0,R7
   \       0x38   0xDBF5             BLT.N    ??freeClusterCount_4
   \                     ??freeClusterCount_7: (+1)
   \       0x3A   0x1BE4             SUBS     R4,R4,R7
   \       0x3C   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??freeClusterCount_3: (+1)
   \       0x40   0x2C00             CMP      R4,#+0
   \       0x42   0xD020             BEQ.N    ??freeClusterCount_8
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x4640             MOV      R0,R8
   \       0x48   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD014             BEQ.N    ??freeClusterCount_2
   \       0x50   0x42BC             CMP      R4,R7
   \       0x52   0xD201             BCS.N    ??freeClusterCount_9
   \       0x54   0x4627             MOV      R7,R4
   \       0x56   0xB2BF             UXTH     R7,R7
   \                     ??freeClusterCount_9: (+1)
   \       0x58   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0x5C   0x2810             CMP      R0,#+16
   \       0x5E   0xD10F             BNE.N    ??freeClusterCount_10
   \       0x60   0x2100             MOVS     R1,#+0
   \       0x62   0x....             LDR.N    R2,??DataTable6_1
   \                     ??freeClusterCount_11: (+1)
   \       0x64   0x4608             MOV      R0,R1
   \       0x66   0xB280             UXTH     R0,R0
   \       0x68   0x42B8             CMP      R0,R7
   \       0x6A   0xDAE6             BGE.N    ??freeClusterCount_7
   \       0x6C   0xF832 0x0010      LDRH     R0,[R2, R0, LSL #+1]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD100             BNE.N    ??freeClusterCount_12
   \       0x74   0x1C76             ADDS     R6,R6,#+1
   \                     ??freeClusterCount_12: (+1)
   \       0x76   0x1C49             ADDS     R1,R1,#+1
   \       0x78   0xE7F4             B.N      ??freeClusterCount_11
   \                     ??freeClusterCount_2: (+1)
   \       0x7A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x7E   0xE003             B.N      ??freeClusterCount_13
   \                     ??freeClusterCount_10: (+1)
   \       0x80   0x2100             MOVS     R1,#+0
   \       0x82   0x....             LDR.N    R2,??DataTable6_1
   \       0x84   0xE7D5             B.N      ??freeClusterCount_6
    318              }
    319            }
    320            return free;
   \                     ??freeClusterCount_8: (+1)
   \       0x86   0x4630             MOV      R0,R6
   \                     ??freeClusterCount_13: (+1)
   \       0x88   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    321          }
    322          //------------------------------------------------------------------------------
    323          /** Initialize a FAT volume.
    324           *
    325           * \param[in] dev The SD card where the volume is located.
    326           *
    327           * \param[in] part The partition to be used.  Legal values for \a part are
    328           * 1-4 to use the corresponding partition on a device formatted with
    329           * a MBR, Master Boot Record, or zero if the device is formatted as
    330           * a super floppy with the FAT boot sector in block zero.
    331           *
    332           * \return The value one, true, is returned for success and
    333           * the value zero, false, is returned for failure.  Reasons for
    334           * failure include not finding a valid partition, not finding a valid
    335           * FAT file system in the specified partition or an I/O error.
    336           */

   \                                 In section .text, align 2, keep-with-next
    337          bool SdVolume::init(Sd2Card* dev, uint8_t part) {
   \                     _ZN8SdVolume4initEP7Sd2Cardh: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x4616             MOV      R6,R2
    338            uint32_t totalBlocks;
    339            uint32_t volumeStartBlock = 0;
   \        0x6   0x2400             MOVS     R4,#+0
    340            fat32_boot_t* fbs;
    341          
    342            sdCard_ = dev;
   \        0x8   0x....             LDR.N    R0,??DataTable6
   \        0xA   0x6081             STR      R1,[R0, #+8]
    343            fatType_ = 0;
   \        0xC   0x4621             MOV      R1,R4
   \        0xE   0xF885 0x1020      STRB     R1,[R5, #+32]
    344            allocSearchStart_ = 2;
   \       0x12   0x2102             MOVS     R1,#+2
   \       0x14   0x6029             STR      R1,[R5, #+0]
    345            cacheDirty_ = 0;  // cacheFlush() will write block if true
   \       0x16   0x4621             MOV      R1,R4
   \       0x18   0x7001             STRB     R1,[R0, #+0]
    346            cacheMirrorBlock_ = 0;
   \       0x1A   0x60C1             STR      R1,[R0, #+12]
    347            cacheBlockNumber_ = 0XFFFFFFFF;
   \       0x1C   0xF04F 0x31FF      MOV      R1,#-1
   \       0x20   0x6041             STR      R1,[R0, #+4]
    348          
    349            // if part == 0 assume super floppy with FAT boot sector in block zero
    350            // if part > 0 assume mbr volume with partition table
    351            if (part) {
   \       0x22   0x0030             MOVS     R0,R6
   \       0x24   0xD016             BEQ.N    ??init_0
    352              if (part > 4)goto fail;
   \       0x26   0x2E04             CMP      R6,#+4
   \       0x28   0xDC38             BGT.N    ??init_1
    353              if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto fail;
   \       0x2A   0x4621             MOV      R1,R4
   \       0x2C   0x4608             MOV      R0,R1
   \       0x2E   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD032             BEQ.N    ??init_1
    354              part_t* p = &cacheBuffer_.mbr.part[part - 1];
   \       0x36   0x....             LDR.N    R0,??DataTable6_1
   \       0x38   0xEB00 0x1006      ADD      R0,R0,R6, LSL #+4
   \       0x3C   0xF500 0x70D7      ADD      R0,R0,#+430
    355              if ((p->boot & 0X7F) != 0  ||
    356                  p->totalSectors < 100 ||
    357                  p->firstSector == 0) {
   \       0x40   0x7801             LDRB     R1,[R0, #+0]
   \       0x42   0xF011 0x0F7F      TST      R1,#0x7F
   \       0x46   0xD129             BNE.N    ??init_1
   \       0x48   0x68C1             LDR      R1,[R0, #+12]
   \       0x4A   0x2964             CMP      R1,#+100
   \       0x4C   0xD326             BCC.N    ??init_1
   \       0x4E   0x6884             LDR      R4,[R0, #+8]
   \       0x50   0x2C00             CMP      R4,#+0
   \       0x52   0xD023             BEQ.N    ??init_1
    358                // not a valid partition
    359                goto fail;
    360              }
    361              volumeStartBlock = p->firstSector;
    362            }
    363            if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto fail;
   \                     ??init_0: (+1)
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x4620             MOV      R0,R4
   \       0x58   0x.... 0x....      BL       _ZN8SdVolume13cacheRawBlockEjb
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD01D             BEQ.N    ??init_1
    364            fbs = &cacheBuffer_.fbs32;
    365            if (fbs->bytesPerSector != 512 ||
    366                fbs->fatCount == 0 ||
    367                fbs->reservedSectorCount == 0 ||
    368                fbs->sectorsPerCluster == 0) {
   \       0x60   0x....             LDR.N    R2,??DataTable6_1
   \       0x62   0xF8B2 0x000B      LDRH     R0,[R2, #+11]
   \       0x66   0xF5B0 0x7F00      CMP      R0,#+512
   \       0x6A   0xD117             BNE.N    ??init_1
   \       0x6C   0x7C11             LDRB     R1,[R2, #+16]
   \       0x6E   0x2900             CMP      R1,#+0
   \       0x70   0xD014             BEQ.N    ??init_1
   \       0x72   0x89D0             LDRH     R0,[R2, #+14]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD011             BEQ.N    ??init_1
   \       0x78   0x7B50             LDRB     R0,[R2, #+13]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD00E             BEQ.N    ??init_1
    369              // not valid FAT volume
    370              goto fail;
    371            }
    372            fatCount_ = fbs->fatCount;
   \       0x7E   0x7629             STRB     R1,[R5, #+24]
    373            blocksPerCluster_ = fbs->sectorsPerCluster;
   \       0x80   0x7B50             LDRB     R0,[R2, #+13]
   \       0x82   0x7128             STRB     R0,[R5, #+4]
    374            // determine shift that is same as multiply by blocksPerCluster_
    375            clusterSizeShift_ = 0;
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0x7428             STRB     R0,[R5, #+16]
    376            while (blocksPerCluster_ != _BV(clusterSizeShift_)) {
   \                     ??init_2: (+1)
   \       0x88   0x7C28             LDRB     R0,[R5, #+16]
   \       0x8A   0x7929             LDRB     R1,[R5, #+4]
   \       0x8C   0x2301             MOVS     R3,#+1
   \       0x8E   0x4083             LSLS     R3,R3,R0
   \       0x90   0x4299             CMP      R1,R3
   \       0x92   0xD041             BEQ.N    ??init_3
    377              // error if not power of 2
    378              if (clusterSizeShift_++ > 7) goto fail;
   \       0x94   0x1C41             ADDS     R1,R0,#+1
   \       0x96   0x7429             STRB     R1,[R5, #+16]
   \       0x98   0x2808             CMP      R0,#+8
   \       0x9A   0xDBF5             BLT.N    ??init_2
    379            }
    380            blocksPerFat_ = fbs->sectorsPerFat16 ?
    381                            fbs->sectorsPerFat16 : fbs->sectorsPerFat32;
    382          
    383            fatStartBlock_ = volumeStartBlock + fbs->reservedSectorCount;
    384          
    385            // count for FAT16 zero for FAT32
    386            rootDirEntryCount_ = fbs->rootDirEntryCount;
    387          
    388            // directory start for FAT16 dataStart for FAT32
    389            rootDirStart_ = fatStartBlock_ + fbs->fatCount * blocksPerFat_;
    390          
    391            // data start for FAT16 and FAT32
    392            dataStartBlock_ = rootDirStart_ + ((32 * fbs->rootDirEntryCount + 511) / 512);
    393          
    394            // total blocks for FAT16 or FAT32
    395            totalBlocks = fbs->totalSectors16 ?
    396                          fbs->totalSectors16 : fbs->totalSectors32;
    397          
    398            // total data blocks
    399            clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);
    400          
    401            // divide by cluster size to get cluster count
    402            clusterCount_ >>= clusterSizeShift_;
    403          
    404            // FAT type is determined by cluster count
    405            if (clusterCount_ < 4085) {
    406              fatType_ = 12;
    407              if (!FAT12_SUPPORT) goto fail;
    408            }
    409            else if (clusterCount_ < 65525) {
    410              fatType_ = 16;
    411            }
    412            else {
    413              rootDirStart_ = fbs->fat32RootCluster;
    414              fatType_ = 32;
    415            }
    416            return true;
    417          fail:
    418            return false;
   \                     ??init_1: (+1)
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??init_4: (+1)
   \       0xA0   0x6A50             LDR      R0,[R2, #+36]
   \                     ??init_5: (+1)
   \       0xA2   0x60A8             STR      R0,[R5, #+8]
   \       0xA4   0x89D0             LDRH     R0,[R2, #+14]
   \       0xA6   0x1900             ADDS     R0,R0,R4
   \       0xA8   0x61E8             STR      R0,[R5, #+28]
   \       0xAA   0xF8B2 0x0011      LDRH     R0,[R2, #+17]
   \       0xAE   0x8468             STRH     R0,[R5, #+34]
   \       0xB0   0x69EB             LDR      R3,[R5, #+28]
   \       0xB2   0x7C11             LDRB     R1,[R2, #+16]
   \       0xB4   0x68A8             LDR      R0,[R5, #+8]
   \       0xB6   0xFB00 0x3101      MLA      R1,R0,R1,R3
   \       0xBA   0x6269             STR      R1,[R5, #+36]
   \       0xBC   0xF8B2 0x0011      LDRH     R0,[R2, #+17]
   \       0xC0   0x0140             LSLS     R0,R0,#+5
   \       0xC2   0xF200 0x10FF      ADDW     R0,R0,#+511
   \       0xC6   0x4603             MOV      R3,R0
   \       0xC8   0x121B             ASRS     R3,R3,#+8
   \       0xCA   0xEB00 0x50D3      ADD      R0,R0,R3, LSR #+23
   \       0xCE   0xEB01 0x2160      ADD      R1,R1,R0, ASR #+9
   \       0xD2   0x6169             STR      R1,[R5, #+20]
   \       0xD4   0xF8B2 0x0013      LDRH     R0,[R2, #+19]
   \       0xD8   0x2800             CMP      R0,#+0
   \       0xDA   0xD100             BNE.N    ??init_6
   \       0xDC   0x6A10             LDR      R0,[R2, #+32]
   \                     ??init_6: (+1)
   \       0xDE   0x1A40             SUBS     R0,R0,R1
   \       0xE0   0x1824             ADDS     R4,R4,R0
   \       0xE2   0x60EC             STR      R4,[R5, #+12]
   \       0xE4   0x7C28             LDRB     R0,[R5, #+16]
   \       0xE6   0x40C4             LSRS     R4,R4,R0
   \       0xE8   0x60EC             STR      R4,[R5, #+12]
   \       0xEA   0xF640 0x70F5      MOVW     R0,#+4085
   \       0xEE   0x4284             CMP      R4,R0
   \       0xF0   0xD203             BCS.N    ??init_7
   \       0xF2   0x200C             MOVS     R0,#+12
   \       0xF4   0xF885 0x0020      STRB     R0,[R5, #+32]
   \       0xF8   0xE7D0             B.N      ??init_1
   \                     ??init_7: (+1)
   \       0xFA   0xF64F 0x70F5      MOVW     R0,#+65525
   \       0xFE   0x4284             CMP      R4,R0
   \      0x100   0xD203             BCS.N    ??init_8
   \      0x102   0x2010             MOVS     R0,#+16
   \      0x104   0xF885 0x0020      STRB     R0,[R5, #+32]
   \      0x108   0xE004             B.N      ??init_9
   \                     ??init_8: (+1)
   \      0x10A   0x6AD0             LDR      R0,[R2, #+44]
   \      0x10C   0x6268             STR      R0,[R5, #+36]
   \      0x10E   0x2020             MOVS     R0,#+32
   \      0x110   0xF885 0x0020      STRB     R0,[R5, #+32]
   \                     ??init_9: (+1)
   \      0x114   0x2001             MOVS     R0,#+1
   \      0x116   0xBD70             POP      {R4-R6,PC}
   \                     ??init_3: (+1)
   \      0x118   0x8AD0             LDRH     R0,[R2, #+22]
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD0C0             BEQ.N    ??init_4
   \      0x11E   0xE7C0             B.N      ??init_5
    419          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     _ZN8SdVolume11cacheDirty_E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     _ZN8SdVolume12cacheBuffer_E
    420          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   SdVolume::allocContiguous(uint32_t, uint32_t *)
        40   -> SdVolume::fatGet(uint32_t, uint32_t *)
        40   -> SdVolume::fatPut(uint32_t, uint32_t)
        40   -> SdVolume::fatPutEOC(uint32_t)
      16   SdVolume::cacheFlush()
        16   -> Sd2Card::writeBlock(uint32_t, uint8_t const *)
      16   SdVolume::cacheRawBlock(uint32_t, bool)
        16   -> Sd2Card::readBlock(uint32_t, uint8_t *)
        16   -> SdVolume::cacheFlush()
      24   SdVolume::chainSize(uint32_t, uint32_t *)
        24   -> SdVolume::fatGet(uint32_t, uint32_t *)
        24   -> SdVolume::isEOC(uint32_t) const
      16   SdVolume::fatGet(uint32_t, uint32_t *)
        16   -> SdVolume::cacheRawBlock(uint32_t, bool)
      24   SdVolume::fatPut(uint32_t, uint32_t)
        24   -> SdVolume::cacheRawBlock(uint32_t, bool)
       0   SdVolume::fatPutEOC(uint32_t)
         0   -> SdVolume::fatPut(uint32_t, uint32_t)
      16   SdVolume::freeChain(uint32_t)
        16   -> SdVolume::fatGet(uint32_t, uint32_t *)
        16   -> SdVolume::fatPut(uint32_t, uint32_t)
        16   -> SdVolume::isEOC(uint32_t) const
      24   SdVolume::freeClusterCount()
        24   -> SdVolume::cacheRawBlock(uint32_t, bool)
      16   SdVolume::init(Sd2Card *, uint8_t)
        16   -> SdVolume::cacheRawBlock(uint32_t, bool)
       0   SdVolume::isEOC(uint32_t) const


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
     186  SdVolume::allocContiguous(uint32_t, uint32_t *)
     512  SdVolume::cacheBuffer_
      16  SdVolume::cacheDirty_
          SdVolume::cacheBlockNumber_
          SdVolume::sdCard_
          SdVolume::cacheMirrorBlock_
      64  SdVolume::cacheFlush()
      58  SdVolume::cacheRawBlock(uint32_t, bool)
      54  SdVolume::chainSize(uint32_t, uint32_t *)
     104  SdVolume::fatGet(uint32_t, uint32_t *)
     108  SdVolume::fatPut(uint32_t, uint32_t)
       8  SdVolume::fatPutEOC(uint32_t)
      60  SdVolume::freeChain(uint32_t)
     140  SdVolume::freeClusterCount()
     288  SdVolume::init(Sd2Card *, uint8_t)
      40  SdVolume::isEOC(uint32_t) const

 
   528 bytes in section .bss
 1 118 bytes in section .text
 
 1 070 bytes of CODE memory (+ 48 bytes shared)
   528 bytes of DATA memory

Errors: none
Warnings: 3
