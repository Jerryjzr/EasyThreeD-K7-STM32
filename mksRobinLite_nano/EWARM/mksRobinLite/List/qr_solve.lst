###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         07/Apr/2021  11:05:07
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\qr_solve.cpp
#    Command line =  
#        -f C:\Users\PLT\AppData\Local\Temp\EW8F7E.tmp
#        (C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\qr_solve.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lC
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lA
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Src\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/l6474\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/MotorControl\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino/avr\
#        -I C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc/Logo\ -Om --c++
#        --no_exceptions --no_rtti -I "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I "D:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List\qr_solve.lst
#    Object file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj\qr_solve.o
#
###############################################################################

C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\qr_solve.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          #include "qr_solve.h"

    #define SDSS   18
            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\pins_MKS_ROBIN_LITE.h",161  Warning[Pa181]: 
          incompatible redefinition of macro "SDSS" (declared at line 62)

  #define UNUSED(x) ((void)(x))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pa181]: 
          incompatible redefinition of macro "UNUSED" (declared at line 88 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\macros.h")
     24          
     25          //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
     26          #if 1
     27          #include <stdlib.h>
     28          #include <math.h>
     29          
     30          //# include "r8lib.h"
     31          

   \                                 In section .text, align 2, keep-with-next
     32          int i4_min(int i1, int i2)
     33          
     34          /******************************************************************************/
     35          /**
     36            Purpose:
     37          
     38              I4_MIN returns the smaller of two I4's.
     39          
     40            Licensing:
     41          
     42              This code is distributed under the GNU LGPL license.
     43          
     44            Modified:
     45          
     46              29 August 2006
     47          
     48            Author:
     49          
     50              John Burkardt
     51          
     52            Parameters:
     53          
     54              Input, int I1, I2, two integers to be compared.
     55          
     56              Output, int I4_MIN, the smaller of I1 and I2.
     57          */
     58          {
     59            return (i1 < i2) ? i1 : i2;
   \                     _Z6i4_minii: (+1)
   \        0x0   0x4288             CMP      R0,R1
   \        0x2   0xDD00             BLE.N    ??i4_min_0
   \        0x4   0x4608             MOV      R0,R1
   \                     ??i4_min_0: (+1)
   \        0x6   0x4770             BX       LR               ;; return
     60          }
     61          

   \                                 In section .text, align 2, keep-with-next
     62          float r8_epsilon(void)
     63          
     64          /******************************************************************************/
     65          /**
     66            Purpose:
     67          
     68              R8_EPSILON returns the R8 round off unit.
     69          
     70            Discussion:
     71          
     72              R8_EPSILON is a number R which is a power of 2 with the property that,
     73              to the precision of the computer's arithmetic,
     74                1 < 1 + R
     75              but
     76                1 = ( 1 + R / 2 )
     77          
     78            Licensing:
     79          
     80              This code is distributed under the GNU LGPL license.
     81          
     82            Modified:
     83          
     84              01 September 2012
     85          
     86            Author:
     87          
     88              John Burkardt
     89          
     90            Parameters:
     91          
     92              Output, float R8_EPSILON, the R8 round-off unit.
     93          */
     94          {
     95            const float value = 2.220446049250313E-016;
     96            return value;
   \                     _Z10r8_epsilonv: (+1)
   \        0x0   0xF04F 0x5016      MOV      R0,#+629145600
   \        0x4   0x4770             BX       LR               ;; return
     97          }
     98          

   \                                 In section .text, align 2, keep-with-next
     99          float r8_max(float x, float y)
    100          
    101          /******************************************************************************/
    102          /**
    103            Purpose:
    104          
    105              R8_MAX returns the maximum of two R8's.
    106          
    107            Licensing:
    108          
    109              This code is distributed under the GNU LGPL license.
    110          
    111            Modified:
    112          
    113              07 May 2006
    114          
    115            Author:
    116          
    117              John Burkardt
    118          
    119            Parameters:
    120          
    121              Input, float X, Y, the quantities to compare.
    122          
    123              Output, float R8_MAX, the maximum of X and Y.
    124          */
    125          {
   \                     _Z6r8_maxff: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4602             MOV      R2,R0
   \        0x4   0x4608             MOV      R0,R1
    126            return (y < x) ? x : y;
   \        0x6   0x4611             MOV      R1,R2
   \        0x8   0x.... 0x....      BL       __aeabi_cfcmple
   \        0xC   0xD300             BCC.N    ??r8_max_0
   \        0xE   0x4602             MOV      R2,R0
   \                     ??r8_max_0: (+1)
   \       0x10   0x4610             MOV      R0,R2
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
    127          }
    128          

   \                                 In section .text, align 2, keep-with-next
    129          float r8_abs(float x)
    130          
    131          /******************************************************************************/
    132          /**
    133            Purpose:
    134          
    135              R8_ABS returns the absolute value of an R8.
    136          
    137            Licensing:
    138          
    139              This code is distributed under the GNU LGPL license.
    140          
    141            Modified:
    142          
    143              07 May 2006
    144          
    145            Author:
    146          
    147              John Burkardt
    148          
    149            Parameters:
    150          
    151              Input, float X, the quantity whose absolute value is desired.
    152          
    153              Output, float R8_ABS, the absolute value of X.
    154          */
    155          {
   \                     _Z6r8_absf: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    156            return (x < 0.0) ? -x : x;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x.... 0x....      BL       __aeabi_cfcmple
   \        0x8   0xD201             BCS.N    ??r8_abs_0
   \        0xA   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \                     ??r8_abs_0: (+1)
   \        0xE   0xBD02             POP      {R1,PC}          ;; return
    157          }
    158          

   \                                 In section .text, align 2, keep-with-next
    159          float r8_sign(float x)
    160          
    161          /******************************************************************************/
    162          /**
    163            Purpose:
    164          
    165              R8_SIGN returns the sign of an R8.
    166          
    167            Licensing:
    168          
    169              This code is distributed under the GNU LGPL license.
    170          
    171            Modified:
    172          
    173              08 May 2006
    174          
    175            Author:
    176          
    177              John Burkardt
    178          
    179            Parameters:
    180          
    181              Input, float X, the number whose sign is desired.
    182          
    183              Output, float R8_SIGN, the sign of X.
    184          */
    185          {
   \                     _Z7r8_signf: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    186            return (x < 0.0) ? -1.0 : 1.0;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x.... 0x....      BL       __aeabi_cfcmple
   \        0x8   0xD202             BCS.N    ??r8_sign_0
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0xbf800000
   \        0xE   0xBD02             POP      {R1,PC}
   \                     ??r8_sign_0: (+1)
   \       0x10   0xF04F 0x507E      MOV      R0,#+1065353216
   \       0x14   0xBD02             POP      {R1,PC}          ;; return
    187          }
    188          

   \                                 In section .text, align 2, keep-with-next
    189          float r8mat_amax(int m, int n, float a[])
    190          
    191          /******************************************************************************/
    192          /**
    193            Purpose:
    194          
    195              R8MAT_AMAX returns the maximum absolute value entry of an R8MAT.
    196          
    197            Discussion:
    198          
    199              An R8MAT is a doubly dimensioned array of R8 values, stored as a vector
    200              in column-major order.
    201          
    202            Licensing:
    203          
    204              This code is distributed under the GNU LGPL license.
    205          
    206            Modified:
    207          
    208              07 September 2012
    209          
    210            Author:
    211          
    212              John Burkardt
    213          
    214            Parameters:
    215          
    216              Input, int M, the number of rows in A.
    217          
    218              Input, int N, the number of columns in A.
    219          
    220              Input, float A[M*N], the M by N matrix.
    221          
    222              Output, float R8MAT_AMAX, the maximum absolute value entry of A.
    223          */
    224          {
   \                     _Z10r8mat_amaxiiPf: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    225            float value = r8_abs(a[0 + 0 * m]);
   \        0xA   0x6830             LDR      R0,[R6, #+0]
   \        0xC   0x.... 0x....      BL       _Z6r8_absf
   \       0x10   0x4607             MOV      R7,R0
    226            for (int j = 0; j < n; j++) {
   \       0x12   0xF04F 0x0800      MOV      R8,#+0
   \       0x16   0xE015             B.N      ??r8mat_amax_0
    227              for (int i = 0; i < m; i++) {
    228                NOLESS(value, r8_abs(a[i + j * m]));
   \                     ??r8mat_amax_1: (+1)
   \       0x18   0xFB04 0xA908      MLA      R9,R4,R8,R10
   \       0x1C   0xF856 0x0029      LDR      R0,[R6, R9, LSL #+2]
   \       0x20   0x.... 0x....      BL       _Z6r8_absf
   \       0x24   0x4601             MOV      R1,R0
   \       0x26   0x4638             MOV      R0,R7
   \       0x28   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x2C   0xD204             BCS.N    ??r8mat_amax_2
   \       0x2E   0xF856 0x0029      LDR      R0,[R6, R9, LSL #+2]
   \       0x32   0x.... 0x....      BL       _Z6r8_absf
   \       0x36   0x4607             MOV      R7,R0
    229              }
   \                     ??r8mat_amax_2: (+1)
   \       0x38   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??r8mat_amax_3: (+1)
   \       0x3C   0x45A2             CMP      R10,R4
   \       0x3E   0xDBEB             BLT.N    ??r8mat_amax_1
   \       0x40   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??r8mat_amax_0: (+1)
   \       0x44   0x45A8             CMP      R8,R5
   \       0x46   0xDA02             BGE.N    ??r8mat_amax_4
   \       0x48   0xF04F 0x0A00      MOV      R10,#+0
   \       0x4C   0xE7F6             B.N      ??r8mat_amax_3
    230            }
    231            return value;
   \                     ??r8mat_amax_4: (+1)
   \       0x4E   0x4638             MOV      R0,R7
   \       0x50   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    232          }
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void r8mat_copy(float a2[], int m, int n, float a1[])
    235          
    236          /******************************************************************************/
    237          /**
    238            Purpose:
    239          
    240              R8MAT_COPY_NEW copies one R8MAT to a "new" R8MAT.
    241          
    242            Discussion:
    243          
    244              An R8MAT is a doubly dimensioned array of R8 values, stored as a vector
    245              in column-major order.
    246          
    247            Licensing:
    248          
    249              This code is distributed under the GNU LGPL license.
    250          
    251            Modified:
    252          
    253              26 July 2008
    254          
    255            Author:
    256          
    257              John Burkardt
    258          
    259            Parameters:
    260          
    261              Input, int M, N, the number of rows and columns.
    262          
    263              Input, float A1[M*N], the matrix to be copied.
    264          
    265              Output, float R8MAT_COPY_NEW[M*N], the copy of A1.
    266          */
    267          {
   \                     _Z10r8mat_copyPfiiS_: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    268            for (int j = 0; j < n; j++) {
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0xE009             B.N      ??r8mat_copy_0
    269              for (int i = 0; i < m; i++)
    270                a2[i + j * m] = a1[i + j * m];
   \                     ??r8mat_copy_1: (+1)
   \        0x6   0xFB01 0x5604      MLA      R6,R1,R4,R5
   \        0xA   0xF853 0x7026      LDR      R7,[R3, R6, LSL #+2]
   \        0xE   0xF840 0x7026      STR      R7,[R0, R6, LSL #+2]
   \       0x12   0x1C6D             ADDS     R5,R5,#+1
   \                     ??r8mat_copy_2: (+1)
   \       0x14   0x428D             CMP      R5,R1
   \       0x16   0xDBF6             BLT.N    ??r8mat_copy_1
   \       0x18   0x1C64             ADDS     R4,R4,#+1
   \                     ??r8mat_copy_0: (+1)
   \       0x1A   0x4294             CMP      R4,R2
   \       0x1C   0xDA01             BGE.N    ??r8mat_copy_3
   \       0x1E   0x2500             MOVS     R5,#+0
   \       0x20   0xE7F8             B.N      ??r8mat_copy_2
    271            }
    272          }
   \                     ??r8mat_copy_3: (+1)
   \       0x22   0xBCF0             POP      {R4-R7}
   \       0x24   0x4770             BX       LR               ;; return
    273          
    274          /******************************************************************************/
    275          

   \                                 In section .text, align 2, keep-with-next
    276          void daxpy(int n, float da, float dx[], int incx, float dy[], int incy)
    277          
    278          /******************************************************************************/
    279          /**
    280            Purpose:
    281          
    282              DAXPY computes constant times a vector plus a vector.
    283          
    284            Discussion:
    285          
    286              This routine uses unrolled loops for increments equal to one.
    287          
    288            Licensing:
    289          
    290              This code is distributed under the GNU LGPL license.
    291          
    292            Modified:
    293          
    294              30 March 2007
    295          
    296            Author:
    297          
    298              C version by John Burkardt
    299          
    300            Reference:
    301          
    302              Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
    303              LINPACK User's Guide,
    304              SIAM, 1979.
    305          
    306              Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,
    307              Basic Linear Algebra Subprograms for Fortran Usage,
    308              Algorithm 539,
    309              ACM Transactions on Mathematical Software,
    310              Volume 5, Number 3, September 1979, pages 308-323.
    311          
    312            Parameters:
    313          
    314              Input, int N, the number of elements in DX and DY.
    315          
    316              Input, float DA, the multiplier of DX.
    317          
    318              Input, float DX[*], the first vector.
    319          
    320              Input, int INCX, the increment between successive entries of DX.
    321          
    322              Input/output, float DY[*], the second vector.
    323              On output, DY[*] has been replaced by DY[*] + DA * DX[*].
    324          
    325              Input, int INCY, the increment between successive entries of DY.
    326          */
    327          {
   \                     _Z5daxpyifPfiS_i: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460C             MOV      R4,R1
    328            if (n <= 0 || da == 0.0) return;
   \        0x8   0xF1B8 0x0F00      CMP      R8,#+0
   \        0xC   0xF340 0x808D      BLE.W    ??daxpy_0
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x18   0xF000 0x8087      BEQ.W    ??daxpy_0
   \       0x1C   0x469A             MOV      R10,R3
   \       0x1E   0x4615             MOV      R5,R2
   \       0x20   0x9E0A             LDR      R6,[SP, #+40]
   \       0x22   0x990B             LDR      R1,[SP, #+44]
    329          
    330            int i, ix, iy, m;
    331            /**
    332              Code for unequal increments or equal increments
    333              not equal to 1.
    334            */
    335            if (incx != 1 || incy != 1) {
   \       0x24   0xF1BA 0x0F01      CMP      R10,#+1
   \       0x28   0xD101             BNE.N    ??daxpy_1
   \       0x2A   0x2901             CMP      R1,#+1
   \       0x2C   0xD02A             BEQ.N    ??daxpy_2
    336              if (0 <= incx)
   \                     ??daxpy_1: (+1)
   \       0x2E   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x32   0xD401             BMI.N    ??daxpy_3
    337                ix = 0;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xE003             B.N      ??daxpy_4
    338              else
    339                ix = (- n + 1) * incx;
   \                     ??daxpy_3: (+1)
   \       0x38   0xF1C8 0x0001      RSB      R0,R8,#+1
   \       0x3C   0xFB0A 0xF000      MUL      R0,R10,R0
    340              if (0 <= incy)
   \                     ??daxpy_4: (+1)
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD401             BMI.N    ??daxpy_5
    341                iy = 0;
   \       0x44   0x2700             MOVS     R7,#+0
   \       0x46   0xE002             B.N      ??daxpy_6
    342              else
    343                iy = (- n + 1) * incy;
   \                     ??daxpy_5: (+1)
   \       0x48   0xF1C8 0x0701      RSB      R7,R8,#+1
   \       0x4C   0x434F             MULS     R7,R1,R7
    344              for (i = 0; i < n; i++) {
   \                     ??daxpy_6: (+1)
   \       0x4E   0xF04F 0x0B00      MOV      R11,#+0
   \       0x52   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x56   0x46A9             MOV      R9,R5
   \       0x58   0x46B0             MOV      R8,R6
   \       0x5A   0x460D             MOV      R5,R1
   \       0x5C   0x4606             MOV      R6,R0
   \                     ??daxpy_7: (+1)
   \       0x5E   0x9800             LDR      R0,[SP, #+0]
   \       0x60   0x4583             CMP      R11,R0
   \       0x62   0xDA62             BGE.N    ??daxpy_0
    345                dy[iy] = dy[iy] + da * dx[ix];
   \       0x64   0xF859 0x0026      LDR      R0,[R9, R6, LSL #+2]
   \       0x68   0x4621             MOV      R1,R4
   \       0x6A   0x.... 0x....      BL       __aeabi_fmul
   \       0x6E   0xF858 0x1027      LDR      R1,[R8, R7, LSL #+2]
   \       0x72   0x.... 0x....      BL       __aeabi_fadd
   \       0x76   0xF848 0x0027      STR      R0,[R8, R7, LSL #+2]
    346                ix = ix + incx;
   \       0x7A   0x4456             ADD      R6,R10,R6
    347                iy = iy + incy;
   \       0x7C   0x19EF             ADDS     R7,R5,R7
    348              }
   \       0x7E   0xF10B 0x0B01      ADD      R11,R11,#+1
   \       0x82   0xE7EC             B.N      ??daxpy_7
    349            }
    350            /**
    351              Code for both increments equal to 1.
    352            */
    353            else {
    354              m = n % 4;
   \                     ??daxpy_2: (+1)
   \       0x84   0x4640             MOV      R0,R8
   \       0x86   0x1040             ASRS     R0,R0,#+1
   \       0x88   0xEB08 0x7090      ADD      R0,R8,R0, LSR #+30
   \       0x8C   0x1080             ASRS     R0,R0,#+2
   \       0x8E   0xEBA8 0x0780      SUB      R7,R8,R0, LSL #+2
    355              for (i = 0; i < m; i++)
   \       0x92   0xF04F 0x0900      MOV      R9,#+0
   \       0x96   0xE00C             B.N      ??daxpy_8
    356                dy[i] = dy[i] + da * dx[i];
   \                     ??daxpy_9: (+1)
   \       0x98   0xF855 0x0029      LDR      R0,[R5, R9, LSL #+2]
   \       0x9C   0x4621             MOV      R1,R4
   \       0x9E   0x.... 0x....      BL       __aeabi_fmul
   \       0xA2   0xF856 0x1029      LDR      R1,[R6, R9, LSL #+2]
   \       0xA6   0x.... 0x....      BL       __aeabi_fadd
   \       0xAA   0xF846 0x0029      STR      R0,[R6, R9, LSL #+2]
   \       0xAE   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??daxpy_8: (+1)
   \       0xB2   0x45B9             CMP      R9,R7
   \       0xB4   0xDBF0             BLT.N    ??daxpy_9
    357              for (i = m; i < n; i = i + 4) {
   \       0xB6   0x46B9             MOV      R9,R7
   \       0xB8   0x4647             MOV      R7,R8
   \                     ??daxpy_10: (+1)
   \       0xBA   0x45B9             CMP      R9,R7
   \       0xBC   0xDA35             BGE.N    ??daxpy_0
    358                dy[i  ] = dy[i  ] + da * dx[i  ];
   \       0xBE   0xEB06 0x0889      ADD      R8,R6,R9, LSL #+2
   \       0xC2   0xF855 0x0029      LDR      R0,[R5, R9, LSL #+2]
   \       0xC6   0x4621             MOV      R1,R4
   \       0xC8   0x.... 0x....      BL       __aeabi_fmul
   \       0xCC   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xD0   0x.... 0x....      BL       __aeabi_fadd
   \       0xD4   0xF8C8 0x0000      STR      R0,[R8, #+0]
    359                dy[i + 1] = dy[i + 1] + da * dx[i + 1];
   \       0xD8   0x1D28             ADDS     R0,R5,#+4
   \       0xDA   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \       0xDE   0x4621             MOV      R1,R4
   \       0xE0   0x.... 0x....      BL       __aeabi_fmul
   \       0xE4   0xF8D8 0x1004      LDR      R1,[R8, #+4]
   \       0xE8   0x.... 0x....      BL       __aeabi_fadd
   \       0xEC   0xF8C8 0x0004      STR      R0,[R8, #+4]
    360                dy[i + 2] = dy[i + 2] + da * dx[i + 2];
   \       0xF0   0xF105 0x0008      ADD      R0,R5,#+8
   \       0xF4   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \       0xF8   0x4621             MOV      R1,R4
   \       0xFA   0x.... 0x....      BL       __aeabi_fmul
   \       0xFE   0xF8D8 0x1008      LDR      R1,[R8, #+8]
   \      0x102   0x.... 0x....      BL       __aeabi_fadd
   \      0x106   0xF8C8 0x0008      STR      R0,[R8, #+8]
    361                dy[i + 3] = dy[i + 3] + da * dx[i + 3];
   \      0x10A   0xF105 0x000C      ADD      R0,R5,#+12
   \      0x10E   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \      0x112   0x4621             MOV      R1,R4
   \      0x114   0x.... 0x....      BL       __aeabi_fmul
   \      0x118   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \      0x11C   0x.... 0x....      BL       __aeabi_fadd
   \      0x120   0xF8C8 0x000C      STR      R0,[R8, #+12]
    362              }
   \      0x124   0xF109 0x0904      ADD      R9,R9,#+4
   \      0x128   0xE7C7             B.N      ??daxpy_10
    363            }
    364          }
   \                     ??daxpy_0: (+1)
   \      0x12A   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    365          /******************************************************************************/
    366          

   \                                 In section .text, align 2, keep-with-next
    367          float ddot(int n, float dx[], int incx, float dy[], int incy)
    368          
    369          /******************************************************************************/
    370          /**
    371            Purpose:
    372          
    373              DDOT forms the dot product of two vectors.
    374          
    375            Discussion:
    376          
    377              This routine uses unrolled loops for increments equal to one.
    378          
    379            Licensing:
    380          
    381              This code is distributed under the GNU LGPL license.
    382          
    383            Modified:
    384          
    385              30 March 2007
    386          
    387            Author:
    388          
    389              C version by John Burkardt
    390          
    391            Reference:
    392          
    393              Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
    394              LINPACK User's Guide,
    395              SIAM, 1979.
    396          
    397              Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,
    398              Basic Linear Algebra Subprograms for Fortran Usage,
    399              Algorithm 539,
    400              ACM Transactions on Mathematical Software,
    401              Volume 5, Number 3, September 1979, pages 308-323.
    402          
    403            Parameters:
    404          
    405              Input, int N, the number of entries in the vectors.
    406          
    407              Input, float DX[*], the first vector.
    408          
    409              Input, int INCX, the increment between successive entries in DX.
    410          
    411              Input, float DY[*], the second vector.
    412          
    413              Input, int INCY, the increment between successive entries in DY.
    414          
    415              Output, float DDOT, the sum of the product of the corresponding
    416              entries of DX and DY.
    417          */
    418          {
   \                     _Z4ddotiPfiS_i: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4607             MOV      R7,R0
    419          
    420            if (n <= 0) return 0.0;
   \        0x6   0x2F00             CMP      R7,#+0
   \        0x8   0xDC01             BGT.N    ??ddot_0
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE084             B.N      ??ddot_1
    421          
    422            int i, m;
    423            float dtemp = 0.0;
   \                     ??ddot_0: (+1)
   \        0xE   0x2400             MOVS     R4,#+0
   \       0x10   0xF8DD 0x8028      LDR      R8,[SP, #+40]
    424          
    425            /**
    426              Code for unequal increments or equal increments
    427              not equal to 1.
    428            */
    429            if (incx != 1 || incy != 1) {
   \       0x14   0x2A01             CMP      R2,#+1
   \       0x16   0xD102             BNE.N    ??ddot_2
   \       0x18   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x1C   0xD027             BEQ.N    ??ddot_3
    430              int ix = (incx >= 0) ? 0 : (-n + 1) * incx,
   \                     ??ddot_2: (+1)
   \       0x1E   0x2A00             CMP      R2,#+0
   \       0x20   0xD401             BMI.N    ??ddot_4
   \       0x22   0x46A1             MOV      R9,R4
   \       0x24   0xE003             B.N      ??ddot_5
   \                     ??ddot_4: (+1)
   \       0x26   0xF1C7 0x0901      RSB      R9,R7,#+1
   \       0x2A   0xFB02 0xF909      MUL      R9,R2,R9
    431                  iy = (incy >= 0) ? 0 : (-n + 1) * incy;
   \                     ??ddot_5: (+1)
   \       0x2E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x32   0xD401             BMI.N    ??ddot_6
   \       0x34   0x46A2             MOV      R10,R4
   \       0x36   0xE003             B.N      ??ddot_7
   \                     ??ddot_6: (+1)
   \       0x38   0xF1C7 0x0A01      RSB      R10,R7,#+1
   \       0x3C   0xFB08 0xFA0A      MUL      R10,R8,R10
    432              for (i = 0; i < n; i++) {
   \                     ??ddot_7: (+1)
   \       0x40   0x46A3             MOV      R11,R4
   \       0x42   0x9700             STR      R7,[SP, #+0]
   \       0x44   0x460D             MOV      R5,R1
   \       0x46   0x4617             MOV      R7,R2
   \       0x48   0x461E             MOV      R6,R3
   \                     ??ddot_8: (+1)
   \       0x4A   0x9800             LDR      R0,[SP, #+0]
   \       0x4C   0x4583             CMP      R11,R0
   \       0x4E   0xDA62             BGE.N    ??ddot_9
    433                dtemp += dx[ix] * dy[iy];
   \       0x50   0xF855 0x1029      LDR      R1,[R5, R9, LSL #+2]
   \       0x54   0xF856 0x002A      LDR      R0,[R6, R10, LSL #+2]
   \       0x58   0x.... 0x....      BL       __aeabi_fmul
   \       0x5C   0x4621             MOV      R1,R4
   \       0x5E   0x.... 0x....      BL       __aeabi_fadd
   \       0x62   0x4604             MOV      R4,R0
    434                ix = ix + incx;
   \       0x64   0x44B9             ADD      R9,R7,R9
    435                iy = iy + incy;
   \       0x66   0x44C2             ADD      R10,R8,R10
    436              }
   \       0x68   0xF10B 0x0B01      ADD      R11,R11,#+1
   \       0x6C   0xE7ED             B.N      ??ddot_8
    437            }
    438            /**
    439              Code for both increments equal to 1.
    440            */
    441            else {
    442              m = n % 5;
   \                     ??ddot_3: (+1)
   \       0x6E   0x2005             MOVS     R0,#+5
   \       0x70   0xFB97 0xF9F0      SDIV     R9,R7,R0
   \       0x74   0xEB09 0x0989      ADD      R9,R9,R9, LSL #+2
   \       0x78   0xEBA7 0x0909      SUB      R9,R7,R9
    443              for (i = 0; i < m; i++)
   \       0x7C   0x46A0             MOV      R8,R4
   \       0x7E   0x460D             MOV      R5,R1
   \       0x80   0x461E             MOV      R6,R3
   \       0x82   0xE00B             B.N      ??ddot_10
    444                dtemp += dx[i] * dy[i];
   \                     ??ddot_11: (+1)
   \       0x84   0xF855 0x1028      LDR      R1,[R5, R8, LSL #+2]
   \       0x88   0xF856 0x0028      LDR      R0,[R6, R8, LSL #+2]
   \       0x8C   0x.... 0x....      BL       __aeabi_fmul
   \       0x90   0x4621             MOV      R1,R4
   \       0x92   0x.... 0x....      BL       __aeabi_fadd
   \       0x96   0x4604             MOV      R4,R0
   \       0x98   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??ddot_10: (+1)
   \       0x9C   0x45C8             CMP      R8,R9
   \       0x9E   0xDBF1             BLT.N    ??ddot_11
    445              for (i = m; i < n; i = i + 5) {
   \                     ??ddot_12: (+1)
   \       0xA0   0x45B9             CMP      R9,R7
   \       0xA2   0xDA38             BGE.N    ??ddot_9
    446                dtemp += dx[i] * dy[i]
    447                        + dx[i + 1] * dy[i + 1]
    448                        + dx[i + 2] * dy[i + 2]
    449                        + dx[i + 3] * dy[i + 3]
    450                        + dx[i + 4] * dy[i + 4];
   \       0xA4   0xEB06 0x0889      ADD      R8,R6,R9, LSL #+2
   \       0xA8   0xEB05 0x0A89      ADD      R10,R5,R9, LSL #+2
   \       0xAC   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \       0xB0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xB4   0x.... 0x....      BL       __aeabi_fmul
   \       0xB8   0x4683             MOV      R11,R0
   \       0xBA   0xF8DA 0x1004      LDR      R1,[R10, #+4]
   \       0xBE   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0xC2   0x.... 0x....      BL       __aeabi_fmul
   \       0xC6   0x4659             MOV      R1,R11
   \       0xC8   0x.... 0x....      BL       __aeabi_fadd
   \       0xCC   0x4683             MOV      R11,R0
   \       0xCE   0xF8DA 0x1008      LDR      R1,[R10, #+8]
   \       0xD2   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0xD6   0x.... 0x....      BL       __aeabi_fmul
   \       0xDA   0x4659             MOV      R1,R11
   \       0xDC   0x.... 0x....      BL       __aeabi_fadd
   \       0xE0   0x4683             MOV      R11,R0
   \       0xE2   0xF8DA 0x100C      LDR      R1,[R10, #+12]
   \       0xE6   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0xEA   0x.... 0x....      BL       __aeabi_fmul
   \       0xEE   0x4659             MOV      R1,R11
   \       0xF0   0x.... 0x....      BL       __aeabi_fadd
   \       0xF4   0x4683             MOV      R11,R0
   \       0xF6   0xF8DA 0x1010      LDR      R1,[R10, #+16]
   \       0xFA   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0xFE   0x.... 0x....      BL       __aeabi_fmul
   \      0x102   0x4659             MOV      R1,R11
   \      0x104   0x.... 0x....      BL       __aeabi_fadd
   \      0x108   0x4621             MOV      R1,R4
   \      0x10A   0x.... 0x....      BL       __aeabi_fadd
   \      0x10E   0x4604             MOV      R4,R0
    451              }
   \      0x110   0xF109 0x0905      ADD      R9,R9,#+5
   \      0x114   0xE7C4             B.N      ??ddot_12
    452            }
   \                     ??ddot_9: (+1)
   \      0x116   0x4620             MOV      R0,R4
    453            return dtemp;
   \                     ??ddot_1: (+1)
   \      0x118   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    454          }
    455          /******************************************************************************/
    456          

   \                                 In section .text, align 2, keep-with-next
    457          float dnrm2(int n, float x[], int incx)
    458          
    459          /******************************************************************************/
    460          /**
    461            Purpose:
    462          
    463              DNRM2 returns the euclidean norm of a vector.
    464          
    465            Discussion:
    466          
    467               DNRM2 ( X ) = sqrt ( X' * X )
    468          
    469            Licensing:
    470          
    471              This code is distributed under the GNU LGPL license.
    472          
    473            Modified:
    474          
    475              30 March 2007
    476          
    477            Author:
    478          
    479              C version by John Burkardt
    480          
    481            Reference:
    482          
    483              Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
    484              LINPACK User's Guide,
    485              SIAM, 1979.
    486          
    487              Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,
    488              Basic Linear Algebra Subprograms for Fortran Usage,
    489              Algorithm 539,
    490              ACM Transactions on Mathematical Software,
    491              Volume 5, Number 3, September 1979, pages 308-323.
    492          
    493            Parameters:
    494          
    495              Input, int N, the number of entries in the vector.
    496          
    497              Input, float X[*], the vector whose norm is to be computed.
    498          
    499              Input, int INCX, the increment between successive entries of X.
    500          
    501              Output, float DNRM2, the Euclidean norm of X.
    502          */
    503          {
   \                     _Z5dnrm2iPfi: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4690             MOV      R8,R2
    504            float norm;
    505            if (n < 1 || incx < 1)
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xDD02             BLE.N    ??dnrm2_0
   \        0xE   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x12   0xDC01             BGT.N    ??dnrm2_1
    506              norm = 0.0;
   \                     ??dnrm2_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE042             B.N      ??dnrm2_2
    507            else if (n == 1)
   \                     ??dnrm2_1: (+1)
   \       0x18   0x2E01             CMP      R6,#+1
   \       0x1A   0xD103             BNE.N    ??dnrm2_3
    508              norm = r8_abs(x[0]);
   \       0x1C   0x6838             LDR      R0,[R7, #+0]
   \       0x1E   0xE8BD 0x4FF2      POP      {R1,R4-R11,LR}
   \       0x22   0x....             B.N      _Z6r8_absf
    509            else {
    510              float scale = 0.0, ssq = 1.0;
   \                     ??dnrm2_3: (+1)
   \       0x24   0xF04F 0x0900      MOV      R9,#+0
   \       0x28   0xF04F 0x5A7E      MOV      R10,#+1065353216
    511              int ix = 0;
   \       0x2C   0x464C             MOV      R4,R9
    512              for (int i = 0; i < n; i++) {
   \       0x2E   0x4625             MOV      R5,R4
   \                     ??dnrm2_4: (+1)
   \       0x30   0x42B5             CMP      R5,R6
   \       0x32   0xDA2C             BGE.N    ??dnrm2_5
    513                if (x[ix] != 0.0) {
   \       0x34   0xF857 0x2024      LDR      R2,[R7, R4, LSL #+2]
   \       0x38   0x4610             MOV      R0,R2
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x40   0xD022             BEQ.N    ??dnrm2_6
    514                  float absxi = r8_abs(x[ix]);
   \       0x42   0x.... 0x....      BL       _Z6r8_absf
   \       0x46   0x4683             MOV      R11,R0
    515                  if (scale < absxi) {
   \       0x48   0x4648             MOV      R0,R9
   \       0x4A   0x4659             MOV      R1,R11
   \       0x4C   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x50   0xD30B             BCC.N    ??dnrm2_7
    516                    ssq = 1.0 + ssq * (scale / absxi) * (scale / absxi);
    517                    scale = absxi;
    518                  }
    519                  else
    520                    ssq = ssq + (absxi / scale) * (absxi / scale);
   \       0x52   0x4658             MOV      R0,R11
   \       0x54   0x4649             MOV      R1,R9
   \       0x56   0x.... 0x....      BL       __aeabi_fdiv
   \       0x5A   0x4601             MOV      R1,R0
   \       0x5C   0x.... 0x....      BL       __aeabi_fmul
   \       0x60   0x4651             MOV      R1,R10
   \       0x62   0x.... 0x....      BL       __aeabi_fadd
   \       0x66   0x4682             MOV      R10,R0
   \       0x68   0xE00E             B.N      ??dnrm2_6
   \                     ??dnrm2_7: (+1)
   \       0x6A   0x.... 0x....      BL       __aeabi_fdiv
   \       0x6E   0x4681             MOV      R9,R0
   \       0x70   0x4651             MOV      R1,R10
   \       0x72   0x.... 0x....      BL       __aeabi_fmul
   \       0x76   0x4649             MOV      R1,R9
   \       0x78   0x.... 0x....      BL       __aeabi_fmul
   \       0x7C   0xF04F 0x517E      MOV      R1,#+1065353216
   \       0x80   0x.... 0x....      BL       __aeabi_fadd
   \       0x84   0x4682             MOV      R10,R0
   \       0x86   0x46D9             MOV      R9,R11
    521                }
    522                ix += incx;
   \                     ??dnrm2_6: (+1)
   \       0x88   0x4444             ADD      R4,R8,R4
    523              }
   \       0x8A   0x1C6D             ADDS     R5,R5,#+1
   \       0x8C   0xE7D0             B.N      ??dnrm2_4
    524              norm = scale * sqrt(ssq);
   \                     ??dnrm2_5: (+1)
   \       0x8E   0x4650             MOV      R0,R10
   \       0x90   0x.... 0x....      BL       sqrtf
   \       0x94   0x4649             MOV      R1,R9
   \       0x96   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \       0x9A   0x.... 0x....      B.W      __aeabi_fmul
    525            }
    526            return norm;
   \                     ??dnrm2_2: (+1)
   \       0x9E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    527          }
    528          /******************************************************************************/
    529          

   \                                 In section .text, align 2, keep-with-next
    530          void dqrank(float a[], int lda, int m, int n, float tol, int* kr,
    531                      int jpvt[], float qraux[])
    532          
    533          /******************************************************************************/
    534          /**
    535            Purpose:
    536          
    537              DQRANK computes the QR factorization of a rectangular matrix.
    538          
    539            Discussion:
    540          
    541              This routine is used in conjunction with DQRLSS to solve
    542              overdetermined, underdetermined and singular linear systems
    543              in a least squares sense.
    544          
    545              DQRANK uses the LINPACK subroutine DQRDC to compute the QR
    546              factorization, with column pivoting, of an M by N matrix A.
    547              The numerical rank is determined using the tolerance TOL.
    548          
    549              Note that on output, ABS ( A(1,1) ) / ABS ( A(KR,KR) ) is an estimate
    550              of the condition number of the matrix of independent columns,
    551              and of R.  This estimate will be <= 1/TOL.
    552          
    553            Licensing:
    554          
    555              This code is distributed under the GNU LGPL license.
    556          
    557            Modified:
    558          
    559              21 April 2012
    560          
    561            Author:
    562          
    563              C version by John Burkardt.
    564          
    565            Reference:
    566          
    567              Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
    568              LINPACK User's Guide,
    569              SIAM, 1979,
    570              ISBN13: 978-0-898711-72-1,
    571              LC: QA214.L56.
    572          
    573            Parameters:
    574          
    575              Input/output, float A[LDA*N].  On input, the matrix whose
    576              decomposition is to be computed.  On output, the information from DQRDC.
    577              The triangular matrix R of the QR factorization is contained in the
    578              upper triangle and information needed to recover the orthogonal
    579              matrix Q is stored below the diagonal in A and in the vector QRAUX.
    580          
    581              Input, int LDA, the leading dimension of A, which must
    582              be at least M.
    583          
    584              Input, int M, the number of rows of A.
    585          
    586              Input, int N, the number of columns of A.
    587          
    588              Input, float TOL, a relative tolerance used to determine the
    589              numerical rank.  The problem should be scaled so that all the elements
    590              of A have roughly the same absolute accuracy, EPS.  Then a reasonable
    591              value for TOL is roughly EPS divided by the magnitude of the largest
    592              element.
    593          
    594              Output, int *KR, the numerical rank.
    595          
    596              Output, int JPVT[N], the pivot information from DQRDC.
    597              Columns JPVT(1), ..., JPVT(KR) of the original matrix are linearly
    598              independent to within the tolerance TOL and the remaining columns
    599              are linearly dependent.
    600          
    601              Output, float QRAUX[N], will contain extra information defining
    602              the QR factorization.
    603          */
    604          {
   \                     _Z6dqrankPfiiifPiS0_S_: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4607             MOV      R7,R0
   \        0x8   0x468A             MOV      R10,R1
   \        0xA   0x4691             MOV      R9,R2
   \        0xC   0x461D             MOV      R5,R3
   \        0xE   0x9E10             LDR      R6,[SP, #+64]
    605          	//float work[n];	/*--mks--*/
    606          	float *work = NULL;
    607          	work = (float *)malloc(n * sizeof(float));
   \       0x10   0x00A8             LSLS     R0,R5,#+2
   \       0x12   0x.... 0x....      BL       malloc
   \       0x16   0x4604             MOV      R4,R0
    608          
    609            for (int i = 0; i < n; i++)
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x4630             MOV      R0,R6
   \       0x1C   0x460A             MOV      R2,R1
   \       0x1E   0xE002             B.N      ??dqrank_0
    610              jpvt[i] = 0;
   \                     ??dqrank_1: (+1)
   \       0x20   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   \       0x24   0x1C49             ADDS     R1,R1,#+1
   \                     ??dqrank_0: (+1)
   \       0x26   0x42A9             CMP      R1,R5
   \       0x28   0xDBFA             BLT.N    ??dqrank_1
   \       0x2A   0x9911             LDR      R1,[SP, #+68]
   \       0x2C   0xF8DD 0x803C      LDR      R8,[SP, #+60]
   \       0x30   0x4656             MOV      R6,R10
    611          
    612            int job = 1;
    613          
    614            dqrdc(a, lda, m, n, qraux, jpvt, work, job);
   \       0x32   0x2201             MOVS     R2,#+1
   \       0x34   0x9203             STR      R2,[SP, #+12]
   \       0x36   0x9402             STR      R4,[SP, #+8]
   \       0x38   0x9001             STR      R0,[SP, #+4]
   \       0x3A   0x9100             STR      R1,[SP, #+0]
   \       0x3C   0x462B             MOV      R3,R5
   \       0x3E   0x464A             MOV      R2,R9
   \       0x40   0x4631             MOV      R1,R6
   \       0x42   0x4638             MOV      R0,R7
   \       0x44   0x.... 0x....      BL       _Z5dqrdcPfiiiS_PiS_i
    615          
    616            *kr = 0;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xF8C8 0x0000      STR      R0,[R8, #+0]
    617            int k = i4_min(m, n);
   \       0x4E   0x4629             MOV      R1,R5
   \       0x50   0x4648             MOV      R0,R9
   \       0x52   0x.... 0x....      BL       _Z6i4_minii
   \       0x56   0x4681             MOV      R9,R0
    618            for (int j = 0; j < k; j++) {
   \       0x58   0xF04F 0x0A00      MOV      R10,#+0
   \       0x5C   0x980E             LDR      R0,[SP, #+56]
   \       0x5E   0x463D             MOV      R5,R7
   \       0x60   0x4607             MOV      R7,R0
   \       0x62   0xE003             B.N      ??dqrank_2
    619              if (r8_abs(a[j + j * lda]) <= tol * r8_abs(a[0 + 0 * lda]))
    620                return;
    621              *kr = j + 1;
   \                     ??dqrank_3: (+1)
   \       0x64   0xF10A 0x0A01      ADD      R10,R10,#+1
   \       0x68   0xF8C8 0xA000      STR      R10,[R8, #+0]
   \                     ??dqrank_2: (+1)
   \       0x6C   0x45CA             CMP      R10,R9
   \       0x6E   0xDA14             BGE.N    ??dqrank_4
   \       0x70   0x6828             LDR      R0,[R5, #+0]
   \       0x72   0x.... 0x....      BL       _Z6r8_absf
   \       0x76   0x4683             MOV      R11,R0
   \       0x78   0xFB06 0xA00A      MLA      R0,R6,R10,R10
   \       0x7C   0xF855 0x0020      LDR      R0,[R5, R0, LSL #+2]
   \       0x80   0x.... 0x....      BL       _Z6r8_absf
   \       0x84   0x4601             MOV      R1,R0
   \       0x86   0x9100             STR      R1,[SP, #+0]
   \       0x88   0x4638             MOV      R0,R7
   \       0x8A   0x4659             MOV      R1,R11
   \       0x8C   0x.... 0x....      BL       __aeabi_fmul
   \       0x90   0x9900             LDR      R1,[SP, #+0]
   \       0x92   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x96   0xD8E5             BHI.N    ??dqrank_3
   \       0x98   0xE005             B.N      ??dqrank_5
    622            }
    623            free(work); 
   \                     ??dqrank_4: (+1)
   \       0x9A   0x4620             MOV      R0,R4
   \       0x9C   0xB005             ADD      SP,SP,#+20
   \       0x9E   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \       0xA2   0x.... 0x....      B.W      free
   \                     ??dqrank_5: (+1)
   \       0xA6   0xB005             ADD      SP,SP,#+20
   \       0xA8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    624          }
    625          /******************************************************************************/
    626          

   \                                 In section .text, align 2, keep-with-next
    627          void dqrdc(float a[], int lda, int n, int p, float qraux[], int jpvt[],
    628                     float work[], int job)
    629          
    630          /******************************************************************************/
    631          /**
    632            Purpose:
    633          
    634              DQRDC computes the QR factorization of a real rectangular matrix.
    635          
    636            Discussion:
    637          
    638              DQRDC uses Householder transformations.
    639          
    640              Column pivoting based on the 2-norms of the reduced columns may be
    641              performed at the user's option.
    642          
    643            Licensing:
    644          
    645              This code is distributed under the GNU LGPL license.
    646          
    647            Modified:
    648          
    649              07 June 2005
    650          
    651            Author:
    652          
    653              C version by John Burkardt.
    654          
    655            Reference:
    656          
    657              Jack Dongarra, Cleve Moler, Jim Bunch and Pete Stewart,
    658              LINPACK User's Guide,
    659              SIAM, (Society for Industrial and Applied Mathematics),
    660              3600 University City Science Center,
    661              Philadelphia, PA, 19104-2688.
    662              ISBN 0-89871-172-X
    663          
    664            Parameters:
    665          
    666              Input/output, float A(LDA,P).  On input, the N by P matrix
    667              whose decomposition is to be computed.  On output, A contains in
    668              its upper triangle the upper triangular matrix R of the QR
    669              factorization.  Below its diagonal A contains information from
    670              which the orthogonal part of the decomposition can be recovered.
    671              Note that if pivoting has been requested, the decomposition is not that
    672              of the original matrix A but that of A with its columns permuted
    673              as described by JPVT.
    674          
    675              Input, int LDA, the leading dimension of the array A.  LDA must
    676              be at least N.
    677          
    678              Input, int N, the number of rows of the matrix A.
    679          
    680              Input, int P, the number of columns of the matrix A.
    681          
    682              Output, float QRAUX[P], contains further information required
    683              to recover the orthogonal part of the decomposition.
    684          
    685              Input/output, integer JPVT[P].  On input, JPVT contains integers that
    686              control the selection of the pivot columns.  The K-th column A(*,K) of A
    687              is placed in one of three classes according to the value of JPVT(K).
    688                > 0, then A(K) is an initial column.
    689                = 0, then A(K) is a free column.
    690                < 0, then A(K) is a final column.
    691              Before the decomposition is computed, initial columns are moved to
    692              the beginning of the array A and final columns to the end.  Both
    693              initial and final columns are frozen in place during the computation
    694              and only free columns are moved.  At the K-th stage of the
    695              reduction, if A(*,K) is occupied by a free column it is interchanged
    696              with the free column of largest reduced norm.  JPVT is not referenced
    697              if JOB == 0.  On output, JPVT(K) contains the index of the column of the
    698              original matrix that has been interchanged into the K-th column, if
    699              pivoting was requested.
    700          
    701              Workspace, float WORK[P].  WORK is not referenced if JOB == 0.
    702          
    703              Input, int JOB, initiates column pivoting.
    704              0, no pivoting is done.
    705              nonzero, pivoting is done.
    706          */
    707          {
   \                     _Z5dqrdcPfiiiS_PiS_i: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x9B1D             LDR      R3,[SP, #+116]
    708            int jp;
    709            int j;
    710            int lup;
    711            int maxj;
    712            float maxnrm, nrmxl, t, tt;
    713          
    714            int pl = 1, pu = 0;
   \        0x8   0x2401             MOVS     R4,#+1
   \        0xA   0x9404             STR      R4,[SP, #+16]
   \        0xC   0x2700             MOVS     R7,#+0
    715            /**
    716              If pivoting is requested, rearrange the columns.
    717            */
    718            if (job != 0) {
   \        0xE   0x2B00             CMP      R3,#+0
   \       0x10   0xD064             BEQ.N    ??dqrdc_0
    719              for (j = 1; j <= p; j++) {
   \       0x12   0x46A2             MOV      R10,R4
   \       0x14   0x4604             MOV      R4,R0
   \       0x16   0x460D             MOV      R5,R1
   \       0x18   0x4616             MOV      R6,R2
   \       0x1A   0x9F10             LDR      R7,[SP, #+64]
   \       0x1C   0xF8DD 0x806C      LDR      R8,[SP, #+108]
   \       0x20   0xF04F 0x0901      MOV      R9,#+1
   \       0x24   0xF1A8 0x0B04      SUB      R11,R8,#+4
   \       0x28   0xE024             B.N      ??dqrdc_1
    720                int swapj = (0 < jpvt[j - 1]);
    721                jpvt[j - 1] = (jpvt[j - 1] < 0) ? -j : j;
   \                     ??dqrdc_2: (+1)
   \       0x2A   0x4651             MOV      R1,R10
   \       0x2C   0xE004             B.N      ??dqrdc_3
   \                     ??dqrdc_4: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \                     ??dqrdc_5: (+1)
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD5FA             BPL.N    ??dqrdc_2
   \       0x34   0xF1CA 0x0100      RSB      R1,R10,#+0
   \                     ??dqrdc_3: (+1)
   \       0x38   0xF84B 0x102A      STR      R1,[R11, R10, LSL #+2]
    722                if (swapj) {
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD017             BEQ.N    ??dqrdc_6
    723                  if (j != pl)
   \       0x40   0x45CA             CMP      R10,R9
   \       0x42   0xD00D             BEQ.N    ??dqrdc_7
    724                    dswap(n, a + 0 + (pl - 1)*lda, 1, a + 0 + (j - 1), 1);
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x9000             STR      R0,[SP, #+0]
   \       0x48   0x1F20             SUBS     R0,R4,#+4
   \       0x4A   0xEB00 0x038A      ADD      R3,R0,R10, LSL #+2
   \       0x4E   0x2201             MOVS     R2,#+1
   \       0x50   0xF1A9 0x0001      SUB      R0,R9,#+1
   \       0x54   0x4368             MULS     R0,R5,R0
   \       0x56   0xEB04 0x0180      ADD      R1,R4,R0, LSL #+2
   \       0x5A   0x4630             MOV      R0,R6
   \       0x5C   0x.... 0x....      BL       _Z5dswapiPfiS_i
    725                  jpvt[j - 1] = jpvt[pl - 1];
   \                     ??dqrdc_7: (+1)
   \       0x60   0xF85B 0x0029      LDR      R0,[R11, R9, LSL #+2]
   \       0x64   0xF84B 0x002A      STR      R0,[R11, R10, LSL #+2]
    726                  jpvt[pl - 1] = j;
   \       0x68   0xF84B 0xA029      STR      R10,[R11, R9, LSL #+2]
    727                  pl++;
   \       0x6C   0xF109 0x0901      ADD      R9,R9,#+1
    728                }
   \                     ??dqrdc_6: (+1)
   \       0x70   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??dqrdc_1: (+1)
   \       0x74   0x4557             CMP      R7,R10
   \       0x76   0xF2C0 0x81B7      BLT.W    ??dqrdc_8
   \       0x7A   0xF85B 0x102A      LDR      R1,[R11, R10, LSL #+2]
   \       0x7E   0x2900             CMP      R1,#+0
   \       0x80   0xDDD5             BLE.N    ??dqrdc_4
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0xE7D4             B.N      ??dqrdc_5
    729              }
    730              pu = p;
    731              for (j = p; 1 <= j; j--) {
    732                if (jpvt[j - 1] < 0) {
   \                     ??dqrdc_9: (+1)
   \       0x86   0xF85B 0x0028      LDR      R0,[R11, R8, LSL #+2]
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD51E             BPL.N    ??dqrdc_10
    733                  jpvt[j - 1] = -jpvt[j - 1];
   \       0x8E   0x4240             RSBS     R0,R0,#+0
   \       0x90   0xF84B 0x0028      STR      R0,[R11, R8, LSL #+2]
    734                  if (j != pu) {
   \       0x94   0xF1A7 0x0901      SUB      R9,R7,#+1
   \       0x98   0x45B8             CMP      R8,R7
   \       0x9A   0xD016             BEQ.N    ??dqrdc_11
    735                    dswap(n, a + 0 + (pu - 1)*lda, 1, a + 0 + (j - 1)*lda, 1);
   \       0x9C   0x2001             MOVS     R0,#+1
   \       0x9E   0x9000             STR      R0,[SP, #+0]
   \       0xA0   0xF1A8 0x0001      SUB      R0,R8,#+1
   \       0xA4   0x4368             MULS     R0,R5,R0
   \       0xA6   0xEB06 0x0380      ADD      R3,R6,R0, LSL #+2
   \       0xAA   0x2201             MOVS     R2,#+1
   \       0xAC   0xFB05 0xF009      MUL      R0,R5,R9
   \       0xB0   0xEB06 0x0180      ADD      R1,R6,R0, LSL #+2
   \       0xB4   0x4620             MOV      R0,R4
   \       0xB6   0x.... 0x....      BL       _Z5dswapiPfiS_i
    736                    jp = jpvt[pu - 1];
   \       0xBA   0xF85B 0x0027      LDR      R0,[R11, R7, LSL #+2]
    737                    jpvt[pu - 1] = jpvt[j - 1];
   \       0xBE   0xF85B 0x1028      LDR      R1,[R11, R8, LSL #+2]
   \       0xC2   0xF84B 0x1027      STR      R1,[R11, R7, LSL #+2]
    738                    jpvt[j - 1] = jp;
   \       0xC6   0xF84B 0x0028      STR      R0,[R11, R8, LSL #+2]
    739                  }
    740                  pu = pu - 1;
   \                     ??dqrdc_11: (+1)
   \       0xCA   0x464F             MOV      R7,R9
    741                }
    742              }
   \                     ??dqrdc_10: (+1)
   \       0xCC   0xF1A8 0x0801      SUB      R8,R8,#+1
   \                     ??dqrdc_12: (+1)
   \       0xD0   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xD4   0xDCD7             BGT.N    ??dqrdc_9
   \       0xD6   0x4630             MOV      R0,R6
   \       0xD8   0x4629             MOV      R1,R5
   \       0xDA   0x4622             MOV      R2,R4
    743            }
    744            /**
    745              Compute the norms of the free columns.
    746            */
    747            for (j = pl; j <= pu; j++)
   \                     ??dqrdc_0: (+1)
   \       0xDC   0xF8DD 0x9010      LDR      R9,[SP, #+16]
   \       0xE0   0xF8DD 0x8068      LDR      R8,[SP, #+104]
   \       0xE4   0x4604             MOV      R4,R0
   \       0xE6   0x460D             MOV      R5,R1
   \       0xE8   0x4616             MOV      R6,R2
   \       0xEA   0xE00E             B.N      ??dqrdc_13
    748              qraux[j - 1] = dnrm2(n, a + 0 + (j - 1) * lda, 1);
   \                     ??dqrdc_14: (+1)
   \       0xEC   0x2201             MOVS     R2,#+1
   \       0xEE   0xF1A9 0x0001      SUB      R0,R9,#+1
   \       0xF2   0x4368             MULS     R0,R5,R0
   \       0xF4   0xEB04 0x0180      ADD      R1,R4,R0, LSL #+2
   \       0xF8   0x4630             MOV      R0,R6
   \       0xFA   0x.... 0x....      BL       _Z5dnrm2iPfi
   \       0xFE   0xF1A8 0x0104      SUB      R1,R8,#+4
   \      0x102   0xF841 0x0029      STR      R0,[R1, R9, LSL #+2]
   \      0x106   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??dqrdc_13: (+1)
   \      0x10A   0x454F             CMP      R7,R9
   \      0x10C   0xDAEE             BGE.N    ??dqrdc_14
   \      0x10E   0x940A             STR      R4,[SP, #+40]
   \      0x110   0x9505             STR      R5,[SP, #+20]
   \      0x112   0x9609             STR      R6,[SP, #+36]
    749            for (j = pl; j <= pu; j++)
   \      0x114   0x9904             LDR      R1,[SP, #+16]
   \      0x116   0x981C             LDR      R0,[SP, #+112]
   \      0x118   0xF8CD 0x8068      STR      R8,[SP, #+104]
   \      0x11C   0x901C             STR      R0,[SP, #+112]
   \      0x11E   0x9702             STR      R7,[SP, #+8]
   \      0x120   0xE008             B.N      ??dqrdc_15
    750              work[j - 1] = qraux[j - 1];
   \                     ??dqrdc_16: (+1)
   \      0x122   0x981A             LDR      R0,[SP, #+104]
   \      0x124   0x1F00             SUBS     R0,R0,#+4
   \      0x126   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \      0x12A   0x9A1C             LDR      R2,[SP, #+112]
   \      0x12C   0x1F12             SUBS     R2,R2,#+4
   \      0x12E   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \      0x132   0x1C49             ADDS     R1,R1,#+1
   \                     ??dqrdc_15: (+1)
   \      0x134   0x9802             LDR      R0,[SP, #+8]
   \      0x136   0x4288             CMP      R0,R1
   \      0x138   0xDAF3             BGE.N    ??dqrdc_16
    751            /**
    752              Perform the Householder reduction of A.
    753            */
    754            lup = i4_min(n, p);
   \      0x13A   0x9910             LDR      R1,[SP, #+64]
   \      0x13C   0x9809             LDR      R0,[SP, #+36]
   \      0x13E   0x.... 0x....      BL       _Z6i4_minii
   \      0x142   0x900E             STR      R0,[SP, #+56]
    755            for (int l = 1; l <= lup; l++) {
   \      0x144   0x2401             MOVS     R4,#+1
   \      0x146   0xE00B             B.N      ??dqrdc_17
    756              /**
    757                Bring the column of largest norm into the pivot position.
    758              */
    759              if (pl <= l && l < pu) {
    760                maxnrm = 0.0;
    761                maxj = l;
    762                for (j = l; j <= pu; j++) {
    763                  if (maxnrm < qraux[j - 1]) {
    764                    maxnrm = qraux[j - 1];
    765                    maxj = j;
    766                  }
    767                }
    768                if (maxj != l) {
    769                  dswap(n, a + 0 + (l - 1)*lda, 1, a + 0 + (maxj - 1)*lda, 1);
    770                  qraux[maxj - 1] = qraux[l - 1];
    771                  work[maxj - 1] = work[l - 1];
    772                  jp = jpvt[maxj - 1];
    773                  jpvt[maxj - 1] = jpvt[l - 1];
    774                  jpvt[l - 1] = jp;
    775                }
    776              }
    777              /**
    778                Compute the Householder transformation for column L.
    779              */
    780              qraux[l - 1] = 0.0;
    781              if (l != n) {
    782                nrmxl = dnrm2(n - l + 1, a + l - 1 + (l - 1) * lda, 1);
    783                if (nrmxl != 0.0) {
    784                  if (a[l - 1 + (l - 1)*lda] != 0.0)
    785                    nrmxl = nrmxl * r8_sign(a[l - 1 + (l - 1) * lda]);
    786                  dscal(n - l + 1, 1.0 / nrmxl, a + l - 1 + (l - 1)*lda, 1);
    787                  a[l - 1 + (l - 1)*lda] = 1.0 + a[l - 1 + (l - 1) * lda];
    788                  /**
    789                    Apply the transformation to the remaining columns, updating the norms.
    790                  */
    791                  for (j = l + 1; j <= p; j++) {
    792                    t = -ddot(n - l + 1, a + l - 1 + (l - 1) * lda, 1, a + l - 1 + (j - 1) * lda, 1)
    793                        / a[l - 1 + (l - 1) * lda];
    794                    daxpy(n - l + 1, t, a + l - 1 + (l - 1)*lda, 1, a + l - 1 + (j - 1)*lda, 1);
    795                    if (pl <= j && j <= pu) {
    796                      if (qraux[j - 1] != 0.0) {
    797                        tt = 1.0 - pow(r8_abs(a[l - 1 + (j - 1) * lda]) / qraux[j - 1], 2);
    798                        tt = r8_max(tt, 0.0);
    799                        t = tt;
    800                        tt = 1.0 + 0.05 * tt * pow(qraux[j - 1] / work[j - 1], 2);
    801                        if (tt != 1.0)
    802                          qraux[j - 1] = qraux[j - 1] * sqrt(t);
    803                        else {
    804                          qraux[j - 1] = dnrm2(n - l, a + l + (j - 1) * lda, 1);
    805                          work[j - 1] = qraux[j - 1];
    806                        }
    807                      }
    808                    }
    809                  }
    810                  /**
    811                    Save the transformation.
    812                  */
    813                  qraux[l - 1] = a[l - 1 + (l - 1) * lda];
   \                     ??dqrdc_18: (+1)
   \      0x148   0x9803             LDR      R0,[SP, #+12]
   \      0x14A   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \      0x14E   0xF848 0x0024      STR      R0,[R8, R4, LSL #+2]
    814                  a[l - 1 + (l - 1)*lda] = -nrmxl;
   \      0x152   0x9806             LDR      R0,[SP, #+24]
   \      0x154   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \      0x158   0x9903             LDR      R1,[SP, #+12]
   \      0x15A   0xF841 0x0029      STR      R0,[R1, R9, LSL #+2]
   \                     ??dqrdc_19: (+1)
   \      0x15E   0x1C64             ADDS     R4,R4,#+1
   \                     ??dqrdc_17: (+1)
   \      0x160   0x980E             LDR      R0,[SP, #+56]
   \      0x162   0x42A0             CMP      R0,R4
   \      0x164   0xF2C0 0x813D      BLT.W    ??dqrdc_20
   \      0x168   0x9804             LDR      R0,[SP, #+16]
   \      0x16A   0x4284             CMP      R4,R0
   \      0x16C   0xDB3D             BLT.N    ??dqrdc_21
   \      0x16E   0x9802             LDR      R0,[SP, #+8]
   \      0x170   0x4284             CMP      R4,R0
   \      0x172   0xDA3A             BGE.N    ??dqrdc_21
   \      0x174   0x2000             MOVS     R0,#+0
   \      0x176   0x4625             MOV      R5,R4
   \      0x178   0x4626             MOV      R6,R4
   \      0x17A   0x9A1A             LDR      R2,[SP, #+104]
   \      0x17C   0x9B02             LDR      R3,[SP, #+8]
   \      0x17E   0xE008             B.N      ??dqrdc_22
   \                     ??dqrdc_23: (+1)
   \      0x180   0x1F11             SUBS     R1,R2,#+4
   \      0x182   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \      0x186   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x18A   0xD201             BCS.N    ??dqrdc_24
   \      0x18C   0x4608             MOV      R0,R1
   \      0x18E   0x4635             MOV      R5,R6
   \                     ??dqrdc_24: (+1)
   \      0x190   0x1C76             ADDS     R6,R6,#+1
   \                     ??dqrdc_22: (+1)
   \      0x192   0x42B3             CMP      R3,R6
   \      0x194   0xDAF4             BGE.N    ??dqrdc_23
   \      0x196   0x921A             STR      R2,[SP, #+104]
   \      0x198   0x9302             STR      R3,[SP, #+8]
   \      0x19A   0x42A5             CMP      R5,R4
   \      0x19C   0xD025             BEQ.N    ??dqrdc_21
   \      0x19E   0x2001             MOVS     R0,#+1
   \      0x1A0   0x9000             STR      R0,[SP, #+0]
   \      0x1A2   0x990A             LDR      R1,[SP, #+40]
   \      0x1A4   0x1E6A             SUBS     R2,R5,#+1
   \      0x1A6   0x9805             LDR      R0,[SP, #+20]
   \      0x1A8   0x4342             MULS     R2,R0,R2
   \      0x1AA   0xEB01 0x0382      ADD      R3,R1,R2, LSL #+2
   \      0x1AE   0x2201             MOVS     R2,#+1
   \      0x1B0   0x1E66             SUBS     R6,R4,#+1
   \      0x1B2   0x4346             MULS     R6,R0,R6
   \      0x1B4   0xEB01 0x0186      ADD      R1,R1,R6, LSL #+2
   \      0x1B8   0x9809             LDR      R0,[SP, #+36]
   \      0x1BA   0x.... 0x....      BL       _Z5dswapiPfiS_i
   \      0x1BE   0x981A             LDR      R0,[SP, #+104]
   \      0x1C0   0x1F00             SUBS     R0,R0,#+4
   \      0x1C2   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \      0x1C6   0xF840 0x1025      STR      R1,[R0, R5, LSL #+2]
   \      0x1CA   0x981C             LDR      R0,[SP, #+112]
   \      0x1CC   0x1F00             SUBS     R0,R0,#+4
   \      0x1CE   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \      0x1D2   0xF840 0x1025      STR      R1,[R0, R5, LSL #+2]
   \      0x1D6   0x981B             LDR      R0,[SP, #+108]
   \      0x1D8   0x1F00             SUBS     R0,R0,#+4
   \      0x1DA   0xF850 0x1025      LDR      R1,[R0, R5, LSL #+2]
   \      0x1DE   0xF850 0x2024      LDR      R2,[R0, R4, LSL #+2]
   \      0x1E2   0xF840 0x2025      STR      R2,[R0, R5, LSL #+2]
   \      0x1E6   0xF840 0x1024      STR      R1,[R0, R4, LSL #+2]
   \                     ??dqrdc_21: (+1)
   \      0x1EA   0x981A             LDR      R0,[SP, #+104]
   \      0x1EC   0xF1A0 0x0804      SUB      R8,R0,#+4
   \      0x1F0   0x2000             MOVS     R0,#+0
   \      0x1F2   0xF848 0x0024      STR      R0,[R8, R4, LSL #+2]
   \      0x1F6   0x9809             LDR      R0,[SP, #+36]
   \      0x1F8   0x4284             CMP      R4,R0
   \      0x1FA   0xD0B0             BEQ.N    ??dqrdc_19
   \      0x1FC   0x980A             LDR      R0,[SP, #+40]
   \      0x1FE   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \      0x202   0x900D             STR      R0,[SP, #+52]
   \      0x204   0x4601             MOV      R1,R0
   \      0x206   0x1E62             SUBS     R2,R4,#+1
   \      0x208   0x9805             LDR      R0,[SP, #+20]
   \      0x20A   0x4342             MULS     R2,R0,R2
   \      0x20C   0xEB01 0x0082      ADD      R0,R1,R2, LSL #+2
   \      0x210   0x1F00             SUBS     R0,R0,#+4
   \      0x212   0x9008             STR      R0,[SP, #+32]
   \      0x214   0x9809             LDR      R0,[SP, #+36]
   \      0x216   0x1B00             SUBS     R0,R0,R4
   \      0x218   0x900C             STR      R0,[SP, #+48]
   \      0x21A   0x1C40             ADDS     R0,R0,#+1
   \      0x21C   0x9007             STR      R0,[SP, #+28]
   \      0x21E   0x2201             MOVS     R2,#+1
   \      0x220   0x9908             LDR      R1,[SP, #+32]
   \      0x222   0x.... 0x....      BL       _Z5dnrm2iPfi
   \      0x226   0x9006             STR      R0,[SP, #+24]
   \      0x228   0x2100             MOVS     R1,#+0
   \      0x22A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x22E   0xD096             BEQ.N    ??dqrdc_19
   \      0x230   0x980A             LDR      R0,[SP, #+40]
   \      0x232   0x1F00             SUBS     R0,R0,#+4
   \      0x234   0x9003             STR      R0,[SP, #+12]
   \      0x236   0x4601             MOV      R1,R0
   \      0x238   0x1E62             SUBS     R2,R4,#+1
   \      0x23A   0x9805             LDR      R0,[SP, #+20]
   \      0x23C   0xFB00 0x4202      MLA      R2,R0,R2,R4
   \      0x240   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
   \      0x244   0x4610             MOV      R0,R2
   \      0x246   0x2100             MOVS     R1,#+0
   \      0x248   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x24C   0xD005             BEQ.N    ??dqrdc_25
   \      0x24E   0x.... 0x....      BL       _Z7r8_signf
   \      0x252   0x9906             LDR      R1,[SP, #+24]
   \      0x254   0x.... 0x....      BL       __aeabi_fmul
   \      0x258   0x9006             STR      R0,[SP, #+24]
   \                     ??dqrdc_25: (+1)
   \      0x25A   0x2301             MOVS     R3,#+1
   \      0x25C   0x9A08             LDR      R2,[SP, #+32]
   \      0x25E   0x4615             MOV      R5,R2
   \      0x260   0x461E             MOV      R6,R3
   \      0x262   0xF04F 0x507E      MOV      R0,#+1065353216
   \      0x266   0x9906             LDR      R1,[SP, #+24]
   \      0x268   0x.... 0x....      BL       __aeabi_fdiv
   \      0x26C   0x4601             MOV      R1,R0
   \      0x26E   0x4633             MOV      R3,R6
   \      0x270   0x462A             MOV      R2,R5
   \      0x272   0x9807             LDR      R0,[SP, #+28]
   \      0x274   0x.... 0x....      BL       _Z5dscalifPfi
   \      0x278   0xF1A4 0x0901      SUB      R9,R4,#+1
   \      0x27C   0x9805             LDR      R0,[SP, #+20]
   \      0x27E   0xFB00 0x4909      MLA      R9,R0,R9,R4
   \      0x282   0x9803             LDR      R0,[SP, #+12]
   \      0x284   0xF850 0x1029      LDR      R1,[R0, R9, LSL #+2]
   \      0x288   0xF04F 0x507E      MOV      R0,#+1065353216
   \      0x28C   0x.... 0x....      BL       __aeabi_fadd
   \      0x290   0x9903             LDR      R1,[SP, #+12]
   \      0x292   0xF841 0x0029      STR      R0,[R1, R9, LSL #+2]
   \      0x296   0x1C65             ADDS     R5,R4,#+1
   \      0x298   0xE03E             B.N      ??dqrdc_26
   \                     ??dqrdc_27: (+1)
   \      0x29A   0x2201             MOVS     R2,#+1
   \      0x29C   0x990B             LDR      R1,[SP, #+44]
   \      0x29E   0x980C             LDR      R0,[SP, #+48]
   \      0x2A0   0x.... 0x....      BL       _Z5dnrm2iPfi
   \      0x2A4   0xF848 0x0025      STR      R0,[R8, R5, LSL #+2]
   \      0x2A8   0x9900             LDR      R1,[SP, #+0]
   \      0x2AA   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \      0x2AE   0xE032             B.N      ??dqrdc_28
   \                     ??dqrdc_29: (+1)
   \      0x2B0   0x4659             MOV      R1,R11
   \      0x2B2   0x4658             MOV      R0,R11
   \      0x2B4   0x.... 0x....      BL       __aeabi_fmul
   \      0x2B8   0x4683             MOV      R11,R0
   \                     ??dqrdc_30: (+1)
   \      0x2BA   0x07F8             LSLS     R0,R7,#+31
   \      0x2BC   0xD504             BPL.N    ??dqrdc_31
   \      0x2BE   0x4650             MOV      R0,R10
   \      0x2C0   0x4659             MOV      R1,R11
   \      0x2C2   0x.... 0x....      BL       __aeabi_fmul
   \      0x2C6   0x4682             MOV      R10,R0
   \                     ??dqrdc_31: (+1)
   \      0x2C8   0x087F             LSRS     R7,R7,#+1
   \      0x2CA   0xD1F1             BNE.N    ??dqrdc_29
   \      0x2CC   0x4657             MOV      R7,R10
   \      0x2CE   0x4630             MOV      R0,R6
   \      0x2D0   0x.... 0x....      BL       __aeabi_f2d
   \      0x2D4   0x....             LDR.N    R2,??DataTable2_1  ;; 0x9999999a
   \      0x2D6   0x....             LDR.N    R3,??DataTable2_2  ;; 0x3fa99999
   \      0x2D8   0x.... 0x....      BL       __aeabi_dmul
   \      0x2DC   0x4682             MOV      R10,R0
   \      0x2DE   0x468B             MOV      R11,R1
   \      0x2E0   0x4638             MOV      R0,R7
   \      0x2E2   0x.... 0x....      BL       __aeabi_f2d
   \      0x2E6   0x4652             MOV      R2,R10
   \      0x2E8   0x465B             MOV      R3,R11
   \      0x2EA   0x.... 0x....      BL       __aeabi_dmul
   \      0x2EE   0x2200             MOVS     R2,#+0
   \      0x2F0   0x....             LDR.N    R3,??DataTable2_3  ;; 0x3ff00000
   \      0x2F2   0x.... 0x....      BL       __aeabi_dadd
   \      0x2F6   0x.... 0x....      BL       __aeabi_d2f
   \      0x2FA   0xF04F 0x517E      MOV      R1,#+1065353216
   \      0x2FE   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x302   0xD0CA             BEQ.N    ??dqrdc_27
   \      0x304   0x4630             MOV      R0,R6
   \      0x306   0x.... 0x....      BL       sqrtf
   \      0x30A   0xF858 0x1025      LDR      R1,[R8, R5, LSL #+2]
   \      0x30E   0x.... 0x....      BL       __aeabi_fmul
   \      0x312   0xF848 0x0025      STR      R0,[R8, R5, LSL #+2]
   \                     ??dqrdc_28: (+1)
   \      0x316   0x1C6D             ADDS     R5,R5,#+1
   \                     ??dqrdc_26: (+1)
   \      0x318   0x9810             LDR      R0,[SP, #+64]
   \      0x31A   0x42A8             CMP      R0,R5
   \      0x31C   0xF6FF 0xAF14      BLT.W    ??dqrdc_18
   \      0x320   0x1E6E             SUBS     R6,R5,#+1
   \      0x322   0x9805             LDR      R0,[SP, #+20]
   \      0x324   0x4346             MULS     R6,R0,R6
   \      0x326   0x980D             LDR      R0,[SP, #+52]
   \      0x328   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \      0x32C   0x900B             STR      R0,[SP, #+44]
   \      0x32E   0x1F07             SUBS     R7,R0,#+4
   \      0x330   0x2001             MOVS     R0,#+1
   \      0x332   0x9000             STR      R0,[SP, #+0]
   \      0x334   0x463B             MOV      R3,R7
   \      0x336   0x4602             MOV      R2,R0
   \      0x338   0x9908             LDR      R1,[SP, #+32]
   \      0x33A   0x9807             LDR      R0,[SP, #+28]
   \      0x33C   0x.... 0x....      BL       _Z4ddotiPfiS_i
   \      0x340   0x9903             LDR      R1,[SP, #+12]
   \      0x342   0xF851 0x1029      LDR      R1,[R1, R9, LSL #+2]
   \      0x346   0x.... 0x....      BL       __aeabi_fdiv
   \      0x34A   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \      0x34E   0x2101             MOVS     R1,#+1
   \      0x350   0x9101             STR      R1,[SP, #+4]
   \      0x352   0x9700             STR      R7,[SP, #+0]
   \      0x354   0x460B             MOV      R3,R1
   \      0x356   0x9A08             LDR      R2,[SP, #+32]
   \      0x358   0x4601             MOV      R1,R0
   \      0x35A   0x9807             LDR      R0,[SP, #+28]
   \      0x35C   0x.... 0x....      BL       _Z5daxpyifPfiS_i
   \      0x360   0x9804             LDR      R0,[SP, #+16]
   \      0x362   0x4285             CMP      R5,R0
   \      0x364   0xDBD7             BLT.N    ??dqrdc_28
   \      0x366   0x9802             LDR      R0,[SP, #+8]
   \      0x368   0x42A8             CMP      R0,R5
   \      0x36A   0xDBD4             BLT.N    ??dqrdc_28
   \      0x36C   0xF858 0x0025      LDR      R0,[R8, R5, LSL #+2]
   \      0x370   0x2100             MOVS     R1,#+0
   \      0x372   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x376   0xD0CE             BEQ.N    ??dqrdc_28
   \      0x378   0x9803             LDR      R0,[SP, #+12]
   \      0x37A   0x1936             ADDS     R6,R6,R4
   \      0x37C   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \      0x380   0x.... 0x....      BL       _Z6r8_absf
   \      0x384   0xF858 0x1025      LDR      R1,[R8, R5, LSL #+2]
   \      0x388   0x.... 0x....      BL       __aeabi_fdiv
   \      0x38C   0x4607             MOV      R7,R0
   \      0x38E   0x2602             MOVS     R6,#+2
   \      0x390   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \      0x394   0x46D3             MOV      R11,R10
   \      0x396   0xE004             B.N      ??dqrdc_32
   \                     ??dqrdc_33: (+1)
   \      0x398   0x4639             MOV      R1,R7
   \      0x39A   0x4638             MOV      R0,R7
   \      0x39C   0x.... 0x....      BL       __aeabi_fmul
   \      0x3A0   0x4607             MOV      R7,R0
   \                     ??dqrdc_32: (+1)
   \      0x3A2   0x07F0             LSLS     R0,R6,#+31
   \      0x3A4   0xD504             BPL.N    ??dqrdc_34
   \      0x3A6   0x4658             MOV      R0,R11
   \      0x3A8   0x4639             MOV      R1,R7
   \      0x3AA   0x.... 0x....      BL       __aeabi_fmul
   \      0x3AE   0x4683             MOV      R11,R0
   \                     ??dqrdc_34: (+1)
   \      0x3B0   0x0876             LSRS     R6,R6,#+1
   \      0x3B2   0xD1F1             BNE.N    ??dqrdc_33
   \      0x3B4   0x2100             MOVS     R1,#+0
   \      0x3B6   0x460E             MOV      R6,R1
   \      0x3B8   0x4650             MOV      R0,R10
   \      0x3BA   0x4659             MOV      R1,R11
   \      0x3BC   0x.... 0x....      BL       __aeabi_fsub
   \      0x3C0   0x4631             MOV      R1,R6
   \      0x3C2   0x.... 0x....      BL       _Z6r8_maxff
   \      0x3C6   0x4606             MOV      R6,R0
   \      0x3C8   0x981C             LDR      R0,[SP, #+112]
   \      0x3CA   0x1F00             SUBS     R0,R0,#+4
   \      0x3CC   0x9000             STR      R0,[SP, #+0]
   \      0x3CE   0xF858 0x0025      LDR      R0,[R8, R5, LSL #+2]
   \      0x3D2   0x9900             LDR      R1,[SP, #+0]
   \      0x3D4   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \      0x3D8   0x.... 0x....      BL       __aeabi_fdiv
   \      0x3DC   0x4683             MOV      R11,R0
   \      0x3DE   0x2702             MOVS     R7,#+2
   \      0x3E0   0xE76B             B.N      ??dqrdc_30
    815                }
    816              }
    817            }
    818          }
   \                     ??dqrdc_20: (+1)
   \      0x3E2   0xB011             ADD      SP,SP,#+68
   \      0x3E4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??dqrdc_8: (+1)
   \      0x3E8   0x4620             MOV      R0,R4
   \      0x3EA   0x4634             MOV      R4,R6
   \      0x3EC   0x9710             STR      R7,[SP, #+64]
   \      0x3EE   0xF8CD 0x806C      STR      R8,[SP, #+108]
   \      0x3F2   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \      0x3F6   0x9F10             LDR      R7,[SP, #+64]
   \      0x3F8   0x46B8             MOV      R8,R7
   \      0x3FA   0x4606             MOV      R6,R0
   \      0x3FC   0xE668             B.N      ??dqrdc_12
    819          /******************************************************************************/
    820          

   \                                 In section .text, align 2, keep-with-next
    821          int dqrls(float a[], int lda, int m, int n, float tol, int* kr, float b[],
    822                    float x[], float rsd[], int jpvt[], float qraux[], int itask)
    823          
    824          /******************************************************************************/
    825          /**
    826            Purpose:
    827          
    828              DQRLS factors and solves a linear system in the least squares sense.
    829          
    830            Discussion:
    831          
    832              The linear system may be overdetermined, underdetermined or singular.
    833              The solution is obtained using a QR factorization of the
    834              coefficient matrix.
    835          
    836              DQRLS can be efficiently used to solve several least squares
    837              problems with the same matrix A.  The first system is solved
    838              with ITASK = 1.  The subsequent systems are solved with
    839              ITASK = 2, to avoid the recomputation of the matrix factors.
    840              The parameters KR, JPVT, and QRAUX must not be modified
    841              between calls to DQRLS.
    842          
    843              DQRLS is used to solve in a least squares sense
    844              overdetermined, underdetermined and singular linear systems.
    845              The system is A*X approximates B where A is M by N.
    846              B is a given M-vector, and X is the N-vector to be computed.
    847              A solution X is found which minimimzes the sum of squares (2-norm)
    848              of the residual,  A*X - B.
    849          
    850              The numerical rank of A is determined using the tolerance TOL.
    851          
    852              DQRLS uses the LINPACK subroutine DQRDC to compute the QR
    853              factorization, with column pivoting, of an M by N matrix A.
    854          
    855            Licensing:
    856          
    857              This code is distributed under the GNU LGPL license.
    858          
    859            Modified:
    860          
    861              10 September 2012
    862          
    863            Author:
    864          
    865              C version by John Burkardt.
    866          
    867            Reference:
    868          
    869              David Kahaner, Cleve Moler, Steven Nash,
    870              Numerical Methods and Software,
    871              Prentice Hall, 1989,
    872              ISBN: 0-13-627258-4,
    873              LC: TA345.K34.
    874          
    875            Parameters:
    876          
    877              Input/output, float A[LDA*N], an M by N matrix.
    878              On input, the matrix whose decomposition is to be computed.
    879              In a least squares data fitting problem, A(I,J) is the
    880              value of the J-th basis (model) function at the I-th data point.
    881              On output, A contains the output from DQRDC.  The triangular matrix R
    882              of the QR factorization is contained in the upper triangle and
    883              information needed to recover the orthogonal matrix Q is stored
    884              below the diagonal in A and in the vector QRAUX.
    885          
    886              Input, int LDA, the leading dimension of A.
    887          
    888              Input, int M, the number of rows of A.
    889          
    890              Input, int N, the number of columns of A.
    891          
    892              Input, float TOL, a relative tolerance used to determine the
    893              numerical rank.  The problem should be scaled so that all the elements
    894              of A have roughly the same absolute accuracy EPS.  Then a reasonable
    895              value for TOL is roughly EPS divided by the magnitude of the largest
    896              element.
    897          
    898              Output, int *KR, the numerical rank.
    899          
    900              Input, float B[M], the right hand side of the linear system.
    901          
    902              Output, float X[N], a least squares solution to the linear
    903              system.
    904          
    905              Output, float RSD[M], the residual, B - A*X.  RSD may
    906              overwrite B.
    907          
    908              Workspace, int JPVT[N], required if ITASK = 1.
    909              Columns JPVT(1), ..., JPVT(KR) of the original matrix are linearly
    910              independent to within the tolerance TOL and the remaining columns
    911              are linearly dependent.  ABS ( A(1,1) ) / ABS ( A(KR,KR) ) is an estimate
    912              of the condition number of the matrix of independent columns,
    913              and of R.  This estimate will be <= 1/TOL.
    914          
    915              Workspace, float QRAUX[N], required if ITASK = 1.
    916          
    917              Input, int ITASK.
    918              1, DQRLS factors the matrix A and solves the least squares problem.
    919              2, DQRLS assumes that the matrix A was factored with an earlier
    920                 call to DQRLS, and only solves the least squares problem.
    921          
    922              Output, int DQRLS, error code.
    923              0:  no error
    924              -1: LDA < M   (fatal error)
    925              -2: N < 1     (fatal error)
    926              -3: ITASK < 1 (fatal error)
    927          */
    928          {
   \                     _Z5dqrlsPfiiifPiS_S_S_S0_S_i: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x469A             MOV      R10,R3
    929            int ind;
    930            if (lda < m) {
   \        0xE   0x42AC             CMP      R4,R5
   \       0x10   0xDA02             BGE.N    ??dqrls_0
    931              /*fprintf ( stderr, "\n" );
    932              fprintf ( stderr, "DQRLS - Fatal error!\n" );
    933              fprintf ( stderr, "  LDA < M.\n" );*/
    934              ind = -1;
    935              return ind;
   \       0x12   0xF04F 0x30FF      MOV      R0,#-1
   \       0x16   0xE02C             B.N      ??dqrls_1
    936            }
    937          
    938            if (n <= 0) {
   \                     ??dqrls_0: (+1)
   \       0x18   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x1C   0xDC02             BGT.N    ??dqrls_2
    939              /*fprintf ( stderr, "\n" );
    940              fprintf ( stderr, "DQRLS - Fatal error!\n" );
    941              fprintf ( stderr, "  N <= 0.\n" );*/
    942              ind = -2;
    943              return ind;
   \       0x1E   0xF06F 0x0001      MVN      R0,#+1
   \       0x22   0xE026             B.N      ??dqrls_1
    944            }
   \                     ??dqrls_2: (+1)
   \       0x24   0x9815             LDR      R0,[SP, #+84]
    945          
    946            if (itask < 1) {
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xDC02             BGT.N    ??dqrls_3
    947              /*fprintf ( stderr, "\n" );
    948              fprintf ( stderr, "DQRLS - Fatal error!\n" );
    949              fprintf ( stderr, "  ITASK < 1.\n" );*/
    950              ind = -3;
    951              return ind;
   \       0x2A   0xF06F 0x0002      MVN      R0,#+2
   \       0x2E   0xE020             B.N      ??dqrls_1
    952            }
   \                     ??dqrls_3: (+1)
   \       0x30   0x9E0F             LDR      R6,[SP, #+60]
   \       0x32   0x9F13             LDR      R7,[SP, #+76]
   \       0x34   0xF8DD 0x8050      LDR      R8,[SP, #+80]
    953          
    954            ind = 0;
    955            /**
    956              Factor the matrix.
    957            */
    958            if (itask == 1)
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD108             BNE.N    ??dqrls_4
   \       0x3C   0x980E             LDR      R0,[SP, #+56]
    959              dqrank(a, lda, m, n, tol, kr, jpvt, qraux);
   \       0x3E   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x42   0x9702             STR      R7,[SP, #+8]
   \       0x44   0x9601             STR      R6,[SP, #+4]
   \       0x46   0x9000             STR      R0,[SP, #+0]
   \       0x48   0x4648             MOV      R0,R9
   \       0x4A   0x.... 0x....      BL       _Z6dqrankPfiiifPiS0_S_
   \                     ??dqrls_4: (+1)
   \       0x4E   0x9A12             LDR      R2,[SP, #+72]
   \       0x50   0x9911             LDR      R1,[SP, #+68]
   \       0x52   0x9810             LDR      R0,[SP, #+64]
    960            /**
    961              Solve the least-squares problem.
    962            */
    963            dqrlss(a, lda, m, n, *kr, b, x, rsd, jpvt, qraux);
   \       0x54   0xF8CD 0x8014      STR      R8,[SP, #+20]
   \       0x58   0x9704             STR      R7,[SP, #+16]
   \       0x5A   0x9203             STR      R2,[SP, #+12]
   \       0x5C   0x9102             STR      R1,[SP, #+8]
   \       0x5E   0x9001             STR      R0,[SP, #+4]
   \       0x60   0x6830             LDR      R0,[R6, #+0]
   \       0x62   0x9000             STR      R0,[SP, #+0]
   \       0x64   0x4653             MOV      R3,R10
   \       0x66   0x462A             MOV      R2,R5
   \       0x68   0x4621             MOV      R1,R4
   \       0x6A   0x4648             MOV      R0,R9
   \       0x6C   0x.... 0x....      BL       _Z6dqrlssPfiiiiS_S_S_PiS_
    964            return ind;
   \       0x70   0x2000             MOVS     R0,#+0
   \                     ??dqrls_1: (+1)
   \       0x72   0xB006             ADD      SP,SP,#+24
   \       0x74   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    965          }
    966          /******************************************************************************/
    967          

   \                                 In section .text, align 2, keep-with-next
    968          void dqrlss(float a[], int lda, int m, int n, int kr, float b[], float x[],
    969                      float rsd[], int jpvt[], float qraux[])
    970          
    971          /******************************************************************************/
    972          /**
    973            Purpose:
    974          
    975              DQRLSS solves a linear system in a least squares sense.
    976          
    977            Discussion:
    978          
    979              DQRLSS must be preceded by a call to DQRANK.
    980          
    981              The system is to be solved is
    982                A * X = B
    983              where
    984                A is an M by N matrix with rank KR, as determined by DQRANK,
    985                B is a given M-vector,
    986                X is the N-vector to be computed.
    987          
    988              A solution X, with at most KR nonzero components, is found which
    989              minimizes the 2-norm of the residual (A*X-B).
    990          
    991              Once the matrix A has been formed, DQRANK should be
    992              called once to decompose it.  Then, for each right hand
    993              side B, DQRLSS should be called once to obtain the
    994              solution and residual.
    995          
    996            Licensing:
    997          
    998              This code is distributed under the GNU LGPL license.
    999          
   1000            Modified:
   1001          
   1002              10 September 2012
   1003          
   1004            Author:
   1005          
   1006              C version by John Burkardt
   1007          
   1008            Parameters:
   1009          
   1010              Input, float A[LDA*N], the QR factorization information
   1011              from DQRANK.  The triangular matrix R of the QR factorization is
   1012              contained in the upper triangle and information needed to recover
   1013              the orthogonal matrix Q is stored below the diagonal in A and in
   1014              the vector QRAUX.
   1015          
   1016              Input, int LDA, the leading dimension of A, which must
   1017              be at least M.
   1018          
   1019              Input, int M, the number of rows of A.
   1020          
   1021              Input, int N, the number of columns of A.
   1022          
   1023              Input, int KR, the rank of the matrix, as estimated by DQRANK.
   1024          
   1025              Input, float B[M], the right hand side of the linear system.
   1026          
   1027              Output, float X[N], a least squares solution to the
   1028              linear system.
   1029          
   1030              Output, float RSD[M], the residual, B - A*X.  RSD may
   1031              overwrite B.
   1032          
   1033              Input, int JPVT[N], the pivot information from DQRANK.
   1034              Columns JPVT[0], ..., JPVT[KR-1] of the original matrix are linearly
   1035              independent to within the tolerance TOL and the remaining columns
   1036              are linearly dependent.
   1037          
   1038              Input, float QRAUX[N], auxiliary information from DQRANK
   1039              defining the QR factorization.
   1040          */
   1041          {
   \                     _Z6dqrlssPfiiiiS_S_S_PiS_: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x461E             MOV      R6,R3
   \        0x6   0x9C0E             LDR      R4,[SP, #+56]
   \        0x8   0x9D10             LDR      R5,[SP, #+64]
   1042            int i;
   1043            int info;
                       ^
Warning[Pe550]: variable "info" was set but never used
   1044            int j;
   1045            int job;
   1046            int k;
   1047            float t;
   1048          
   1049            if (kr != 0) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD012             BEQ.N    ??dqrlss_0
   \        0xE   0xF8DD 0xC04C      LDR      R12,[SP, #+76]
   \       0x12   0x9F11             LDR      R7,[SP, #+68]
   \       0x14   0x9B0F             LDR      R3,[SP, #+60]
   1050              job = 110;
   1051              info = dqrsl(a, lda, m, kr, qraux, b, rsd, rsd, x, rsd, rsd, job); UNUSED(info);
   \       0x16   0xF04F 0x0E6E      MOV      LR,#+110
   \       0x1A   0xF8CD 0xE01C      STR      LR,[SP, #+28]
   \       0x1E   0x9706             STR      R7,[SP, #+24]
   \       0x20   0x9705             STR      R7,[SP, #+20]
   \       0x22   0x9504             STR      R5,[SP, #+16]
   \       0x24   0x9703             STR      R7,[SP, #+12]
   \       0x26   0x9702             STR      R7,[SP, #+8]
   \       0x28   0x9301             STR      R3,[SP, #+4]
   \       0x2A   0xF8CD 0xC000      STR      R12,[SP, #+0]
   \       0x2E   0x4623             MOV      R3,R4
   \       0x30   0x.... 0x....      BL       _Z5dqrslPfiiiS_S_S_S_S_S_S_i
   1052            }
   1053          
   1054            for (i = 0; i < n; i++)
   \                     ??dqrlss_0: (+1)
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x9812             LDR      R0,[SP, #+72]
   \       0x38   0xE005             B.N      ??dqrlss_1
   1055              jpvt[i] = - jpvt[i];
   \                     ??dqrlss_2: (+1)
   \       0x3A   0xF850 0x2021      LDR      R2,[R0, R1, LSL #+2]
   \       0x3E   0x4252             RSBS     R2,R2,#+0
   \       0x40   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   \       0x44   0x1C49             ADDS     R1,R1,#+1
   \                     ??dqrlss_1: (+1)
   \       0x46   0x42B1             CMP      R1,R6
   \       0x48   0xDBF7             BLT.N    ??dqrlss_2
   1056          
   1057            for (i = kr; i < n; i++)
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0xE002             B.N      ??dqrlss_3
   1058              x[i] = 0.0;
   \                     ??dqrlss_4: (+1)
   \       0x4E   0xF845 0x1024      STR      R1,[R5, R4, LSL #+2]
   \       0x52   0x1C64             ADDS     R4,R4,#+1
   \                     ??dqrlss_3: (+1)
   \       0x54   0x42B4             CMP      R4,R6
   \       0x56   0xDBFA             BLT.N    ??dqrlss_4
   1059          
   1060            for (j = 1; j <= n; j++) {
   \       0x58   0x2101             MOVS     R1,#+1
   \       0x5A   0x1F03             SUBS     R3,R0,#+4
   \       0x5C   0xE011             B.N      ??dqrlss_5
   1061              if (jpvt[j - 1] <= 0) {
   1062                k = - jpvt[j - 1];
   1063                jpvt[j - 1] = k;
   1064          
   1065                while (k != j) {
   1066                  t = x[j - 1];
   \                     ??dqrlss_6: (+1)
   \       0x5E   0x1F2C             SUBS     R4,R5,#+4
   \       0x60   0xF854 0x7021      LDR      R7,[R4, R1, LSL #+2]
   1067                  x[j - 1] = x[k - 1];
   \       0x64   0xF854 0xC022      LDR      R12,[R4, R2, LSL #+2]
   \       0x68   0xF844 0xC021      STR      R12,[R4, R1, LSL #+2]
   1068                  x[k - 1] = t;
   \       0x6C   0xF844 0x7022      STR      R7,[R4, R2, LSL #+2]
   1069                  jpvt[k - 1] = -jpvt[k - 1];
   \       0x70   0xF853 0x4022      LDR      R4,[R3, R2, LSL #+2]
   \       0x74   0x4264             RSBS     R4,R4,#+0
   \       0x76   0xF843 0x4022      STR      R4,[R3, R2, LSL #+2]
   1070                  k = jpvt[k - 1];
   \       0x7A   0x4622             MOV      R2,R4
   1071                }
   \                     ??dqrlss_7: (+1)
   \       0x7C   0x428A             CMP      R2,R1
   \       0x7E   0xD1EE             BNE.N    ??dqrlss_6
   \                     ??dqrlss_8: (+1)
   \       0x80   0x1C49             ADDS     R1,R1,#+1
   \                     ??dqrlss_5: (+1)
   \       0x82   0x428E             CMP      R6,R1
   \       0x84   0xDB07             BLT.N    ??dqrlss_9
   \       0x86   0xF853 0x2021      LDR      R2,[R3, R1, LSL #+2]
   \       0x8A   0x2A00             CMP      R2,#+0
   \       0x8C   0xDCF8             BGT.N    ??dqrlss_8
   \       0x8E   0x4252             RSBS     R2,R2,#+0
   \       0x90   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \       0x94   0xE7F2             B.N      ??dqrlss_7
   1072              }
   1073            }
   1074          }
   \                     ??dqrlss_9: (+1)
   \       0x96   0xB009             ADD      SP,SP,#+36
   \       0x98   0xBDF0             POP      {R4-R7,PC}       ;; return
   1075          /******************************************************************************/
   1076          

   \                                 In section .text, align 2, keep-with-next
   1077          int dqrsl(float a[], int lda, int n, int k, float qraux[], float y[],
   1078                    float qy[], float qty[], float b[], float rsd[], float ab[], int job)
   1079          
   1080          /******************************************************************************/
   1081          /**
   1082            Purpose:
   1083          
   1084              DQRSL computes transformations, projections, and least squares solutions.
   1085          
   1086            Discussion:
   1087          
   1088              DQRSL requires the output of DQRDC.
   1089          
   1090              For K <= min(N,P), let AK be the matrix
   1091          
   1092                AK = ( A(JPVT[0]), A(JPVT(2)), ..., A(JPVT(K)) )
   1093          
   1094              formed from columns JPVT[0], ..., JPVT(K) of the original
   1095              N by P matrix A that was input to DQRDC.  If no pivoting was
   1096              done, AK consists of the first K columns of A in their
   1097              original order.  DQRDC produces a factored orthogonal matrix Q
   1098              and an upper triangular matrix R such that
   1099          
   1100                AK = Q * (R)
   1101                         (0)
   1102          
   1103              This information is contained in coded form in the arrays
   1104              A and QRAUX.
   1105          
   1106              The parameters QY, QTY, B, RSD, and AB are not referenced
   1107              if their computation is not requested and in this case
   1108              can be replaced by dummy variables in the calling program.
   1109              To save storage, the user may in some cases use the same
   1110              array for different parameters in the calling sequence.  A
   1111              frequently occurring example is when one wishes to compute
   1112              any of B, RSD, or AB and does not need Y or QTY.  In this
   1113              case one may identify Y, QTY, and one of B, RSD, or AB, while
   1114              providing separate arrays for anything else that is to be
   1115              computed.
   1116          
   1117              Thus the calling sequence
   1118          
   1119                dqrsl ( a, lda, n, k, qraux, y, dum, y, b, y, dum, 110, info )
   1120          
   1121              will result in the computation of B and RSD, with RSD
   1122              overwriting Y.  More generally, each item in the following
   1123              list contains groups of permissible identifications for
   1124              a single calling sequence.
   1125          
   1126                1. (Y,QTY,B) (RSD) (AB) (QY)
   1127          
   1128                2. (Y,QTY,RSD) (B) (AB) (QY)
   1129          
   1130                3. (Y,QTY,AB) (B) (RSD) (QY)
   1131          
   1132                4. (Y,QY) (QTY,B) (RSD) (AB)
   1133          
   1134                5. (Y,QY) (QTY,RSD) (B) (AB)
   1135          
   1136                6. (Y,QY) (QTY,AB) (B) (RSD)
   1137          
   1138              In any group the value returned in the array allocated to
   1139              the group corresponds to the last member of the group.
   1140          
   1141            Licensing:
   1142          
   1143              This code is distributed under the GNU LGPL license.
   1144          
   1145            Modified:
   1146          
   1147              07 June 2005
   1148          
   1149            Author:
   1150          
   1151              C version by John Burkardt.
   1152          
   1153            Reference:
   1154          
   1155              Jack Dongarra, Cleve Moler, Jim Bunch and Pete Stewart,
   1156              LINPACK User's Guide,
   1157              SIAM, (Society for Industrial and Applied Mathematics),
   1158              3600 University City Science Center,
   1159              Philadelphia, PA, 19104-2688.
   1160              ISBN 0-89871-172-X
   1161          
   1162            Parameters:
   1163          
   1164              Input, float A[LDA*P], contains the output of DQRDC.
   1165          
   1166              Input, int LDA, the leading dimension of the array A.
   1167          
   1168              Input, int N, the number of rows of the matrix AK.  It must
   1169              have the same value as N in DQRDC.
   1170          
   1171              Input, int K, the number of columns of the matrix AK.  K
   1172              must not be greater than min(N,P), where P is the same as in the
   1173              calling sequence to DQRDC.
   1174          
   1175              Input, float QRAUX[P], the auxiliary output from DQRDC.
   1176          
   1177              Input, float Y[N], a vector to be manipulated by DQRSL.
   1178          
   1179              Output, float QY[N], contains Q * Y, if requested.
   1180          
   1181              Output, float QTY[N], contains Q' * Y, if requested.
   1182          
   1183              Output, float B[K], the solution of the least squares problem
   1184                minimize norm2 ( Y - AK * B),
   1185              if its computation has been requested.  Note that if pivoting was
   1186              requested in DQRDC, the J-th component of B will be associated with
   1187              column JPVT(J) of the original matrix A that was input into DQRDC.
   1188          
   1189              Output, float RSD[N], the least squares residual Y - AK * B,
   1190              if its computation has been requested.  RSD is also the orthogonal
   1191              projection of Y onto the orthogonal complement of the column space
   1192              of AK.
   1193          
   1194              Output, float AB[N], the least squares approximation Ak * B,
   1195              if its computation has been requested.  AB is also the orthogonal
   1196              projection of Y onto the column space of A.
   1197          
   1198              Input, integer JOB, specifies what is to be computed.  JOB has
   1199              the decimal expansion ABCDE, with the following meaning:
   1200          
   1201                if A != 0, compute QY.
   1202                if B != 0, compute QTY.
   1203                if C != 0, compute QTY and B.
   1204                if D != 0, compute QTY and RSD.
   1205                if E != 0, compute QTY and AB.
   1206          
   1207              Note that a request to compute B, RSD, or AB automatically triggers
   1208              the computation of QTY, for which an array must be provided in the
   1209              calling sequence.
   1210          
   1211              Output, int DQRSL, is zero unless the computation of B has
   1212              been requested and R is exactly singular.  In this case, INFO is the
   1213              index of the first zero diagonal element of R, and B is left unaltered.
   1214          */
   1215          {
   \                     _Z5dqrslPfiiiS_S_S_S_S_S_S_i: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x4606             MOV      R6,R0
   \        0x8   0x460F             MOV      R7,R1
   \        0xA   0xF8DD 0x8054      LDR      R8,[SP, #+84]
   \        0xE   0x9D16             LDR      R5,[SP, #+88]
   \       0x10   0x991B             LDR      R1,[SP, #+108]
   1216            int cab;
   1217            int cb;
   1218            int cqty;
   1219            int cqy;
   1220            int cr;
   1221            int i;
   1222            int info;
   1223            int j;
   1224            int jj;
   1225            int ju;
   1226            float t;
   1227            float temp;
   1228            /**
   1229              Set INFO flag.
   1230            */
   1231            info = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9008             STR      R0,[SP, #+32]
   1232          
   1233            /**
   1234              Determine what is to be computed.
   1235            */
   1236            cqy  = ( job / 10000        != 0);
   \       0x16   0xF242 0x7010      MOVW     R0,#+10000
   \       0x1A   0xFB91 0xF2F0      SDIV     R2,R1,R0
   \       0x1E   0x4614             MOV      R4,R2
   \       0x20   0x1E64             SUBS     R4,R4,#+1
   \       0x22   0x41A4             SBCS     R4,R4,R4
   \       0x24   0x43E4             MVNS     R4,R4
   \       0x26   0x0FE4             LSRS     R4,R4,#+31
   1237            cqty = ((job % 10000)       != 0);
   \       0x28   0xFB00 0x1212      MLS      R2,R0,R2,R1
   \       0x2C   0x4610             MOV      R0,R2
   \       0x2E   0x1E40             SUBS     R0,R0,#+1
   \       0x30   0x4180             SBCS     R0,R0,R0
   \       0x32   0x43C0             MVNS     R0,R0
   \       0x34   0x0FC0             LSRS     R0,R0,#+31
   \       0x36   0x9007             STR      R0,[SP, #+28]
   1238            cb   = ((job %  1000) / 100 != 0);
   \       0x38   0xF44F 0x707A      MOV      R0,#+1000
   \       0x3C   0xFB91 0xF2F0      SDIV     R2,R1,R0
   \       0x40   0xFB00 0x1212      MLS      R2,R0,R2,R1
   \       0x44   0x2064             MOVS     R0,#+100
   \       0x46   0xFB92 0xF0F0      SDIV     R0,R2,R0
   \       0x4A   0x1E40             SUBS     R0,R0,#+1
   \       0x4C   0x4180             SBCS     R0,R0,R0
   \       0x4E   0x43C0             MVNS     R0,R0
   \       0x50   0x0FC0             LSRS     R0,R0,#+31
   \       0x52   0x9006             STR      R0,[SP, #+24]
   1239            cr   = ((job %   100) /  10 != 0);
   \       0x54   0x2064             MOVS     R0,#+100
   \       0x56   0xFB91 0xF2F0      SDIV     R2,R1,R0
   \       0x5A   0xFB00 0x1212      MLS      R2,R0,R2,R1
   \       0x5E   0x200A             MOVS     R0,#+10
   \       0x60   0xFB92 0xF0F0      SDIV     R0,R2,R0
   \       0x64   0x1E40             SUBS     R0,R0,#+1
   \       0x66   0x4180             SBCS     R0,R0,R0
   \       0x68   0x43C0             MVNS     R0,R0
   \       0x6A   0x0FC0             LSRS     R0,R0,#+31
   \       0x6C   0x9004             STR      R0,[SP, #+16]
   1240            cab  = ((job %    10)       != 0);
   \       0x6E   0x200A             MOVS     R0,#+10
   \       0x70   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \       0x74   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \       0x78   0xEBA1 0x0142      SUB      R1,R1,R2, LSL #+1
   \       0x7C   0x4608             MOV      R0,R1
   \       0x7E   0x1E40             SUBS     R0,R0,#+1
   \       0x80   0x4180             SBCS     R0,R0,R0
   \       0x82   0x43C0             MVNS     R0,R0
   \       0x84   0x0FC0             LSRS     R0,R0,#+31
   \       0x86   0x9003             STR      R0,[SP, #+12]
   1241            ju = i4_min(k, n - 1);
   \       0x88   0x9909             LDR      R1,[SP, #+36]
   \       0x8A   0x1E49             SUBS     R1,R1,#+1
   \       0x8C   0x980A             LDR      R0,[SP, #+40]
   \       0x8E   0x.... 0x....      BL       _Z6i4_minii
   \       0x92   0x9002             STR      R0,[SP, #+8]
   1242          
   1243            /**
   1244              Special action when N = 1.
   1245            */
   1246            if (ju == 0) {
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD12D             BNE.N    ??dqrsl_0
   1247              if (cqy)
   \       0x98   0x2C00             CMP      R4,#+0
   \       0x9A   0xD002             BEQ.N    ??dqrsl_1
   1248                qy[0] = y[0];
   \       0x9C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xA0   0x6028             STR      R0,[R5, #+0]
   1249              if (cqty)
   \                     ??dqrsl_1: (+1)
   \       0xA2   0x9807             LDR      R0,[SP, #+28]
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD003             BEQ.N    ??dqrsl_2
   1250                qty[0] = y[0];
   \       0xA8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xAC   0x9917             LDR      R1,[SP, #+92]
   \       0xAE   0x6008             STR      R0,[R1, #+0]
   1251              if (cab)
   \                     ??dqrsl_2: (+1)
   \       0xB0   0x9803             LDR      R0,[SP, #+12]
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD003             BEQ.N    ??dqrsl_3
   1252                ab[0] = y[0];
   \       0xB6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xBA   0x991A             LDR      R1,[SP, #+104]
   \       0xBC   0x6008             STR      R0,[R1, #+0]
   1253              if (cb) {
   \                     ??dqrsl_3: (+1)
   \       0xBE   0x9806             LDR      R0,[SP, #+24]
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD00F             BEQ.N    ??dqrsl_4
   1254                if (a[0 + 0 * lda] == 0.0)
   \       0xC4   0x6832             LDR      R2,[R6, #+0]
   \       0xC6   0x4610             MOV      R0,R2
   \       0xC8   0x2100             MOVS     R1,#+0
   \       0xCA   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0xCE   0xD102             BNE.N    ??dqrsl_5
   1255                  info = 1;
   \       0xD0   0x2001             MOVS     R0,#+1
   \       0xD2   0x9008             STR      R0,[SP, #+32]
   \       0xD4   0xE006             B.N      ??dqrsl_4
   1256                else
   1257                  b[0] = y[0] / a[0 + 0 * lda];
   \                     ??dqrsl_5: (+1)
   \       0xD6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xDA   0x4611             MOV      R1,R2
   \       0xDC   0x.... 0x....      BL       __aeabi_fdiv
   \       0xE0   0x9918             LDR      R1,[SP, #+96]
   \       0xE2   0x6008             STR      R0,[R1, #+0]
   1258              }
   1259              if (cr)
   \                     ??dqrsl_4: (+1)
   \       0xE4   0x9804             LDR      R0,[SP, #+16]
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xF000 0x81D8      BEQ.W    ??dqrsl_6
   1260                rsd[0] = 0.0;
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0x9919             LDR      R1,[SP, #+100]
   \       0xF0   0x6008             STR      R0,[R1, #+0]
   \       0xF2   0xE1D3             B.N      ??dqrsl_6
   1261              return info;
   1262            }
   1263            /**
   1264              Set up to compute QY or QTY.
   1265            */
   1266            if (cqy) {
   \                     ??dqrsl_0: (+1)
   \       0xF4   0x2C00             CMP      R4,#+0
   \       0xF6   0xD00D             BEQ.N    ??dqrsl_7
   1267              for (i = 1; i <= n; i++)
   \       0xF8   0x2101             MOVS     R1,#+1
   \       0xFA   0x9809             LDR      R0,[SP, #+36]
   \       0xFC   0x1F2B             SUBS     R3,R5,#+4
   \       0xFE   0xE006             B.N      ??dqrsl_8
   1268                qy[i - 1] = y[i - 1];
   \                     ??dqrsl_9: (+1)
   \      0x100   0xF1A8 0x0204      SUB      R2,R8,#+4
   \      0x104   0xF852 0x2021      LDR      R2,[R2, R1, LSL #+2]
   \      0x108   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \      0x10C   0x1C49             ADDS     R1,R1,#+1
   \                     ??dqrsl_8: (+1)
   \      0x10E   0x4288             CMP      R0,R1
   \      0x110   0xDAF6             BGE.N    ??dqrsl_9
   \      0x112   0x9009             STR      R0,[SP, #+36]
   1269            }
   1270            if (cqty) {
   \                     ??dqrsl_7: (+1)
   \      0x114   0x9807             LDR      R0,[SP, #+28]
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD010             BEQ.N    ??dqrsl_10
   1271              for (i = 1; i <= n; i++)
   \      0x11A   0x2201             MOVS     R2,#+1
   \      0x11C   0x9809             LDR      R0,[SP, #+36]
   \      0x11E   0x9917             LDR      R1,[SP, #+92]
   \      0x120   0xF1A1 0x0C04      SUB      R12,R1,#+4
   \      0x124   0xE006             B.N      ??dqrsl_11
   1272                qty[i - 1] = y[i - 1];
   \                     ??dqrsl_12: (+1)
   \      0x126   0xF1A8 0x0304      SUB      R3,R8,#+4
   \      0x12A   0xF853 0x3022      LDR      R3,[R3, R2, LSL #+2]
   \      0x12E   0xF84C 0x3022      STR      R3,[R12, R2, LSL #+2]
   \      0x132   0x1C52             ADDS     R2,R2,#+1
   \                     ??dqrsl_11: (+1)
   \      0x134   0x4290             CMP      R0,R2
   \      0x136   0xDAF6             BGE.N    ??dqrsl_12
   \      0x138   0x9009             STR      R0,[SP, #+36]
   \      0x13A   0x9117             STR      R1,[SP, #+92]
   \                     ??dqrsl_10: (+1)
   \      0x13C   0x4638             MOV      R0,R7
   1273            }
   1274            /**
   1275              Compute QY.
   1276            */
   1277            if (cqy) {
   \      0x13E   0x2C00             CMP      R4,#+0
   \      0x140   0xD04C             BEQ.N    ??dqrsl_13
   1278              for (jj = 1; jj <= ju; jj++) {
   \      0x142   0x2101             MOVS     R1,#+1
   \      0x144   0x4634             MOV      R4,R6
   \      0x146   0x9005             STR      R0,[SP, #+20]
   \      0x148   0x9516             STR      R5,[SP, #+88]
   \      0x14A   0x9D02             LDR      R5,[SP, #+8]
   \      0x14C   0x460E             MOV      R6,R1
   \      0x14E   0xF1A4 0x0804      SUB      R8,R4,#+4
   \      0x152   0xE03E             B.N      ??dqrsl_14
   1279                j = ju - jj + 1;
   \                     ??dqrsl_15: (+1)
   \      0x154   0x1BAA             SUBS     R2,R5,R6
   \      0x156   0x1C52             ADDS     R2,R2,#+1
   1280                if (qraux[j - 1] != 0.0) {
   \      0x158   0x9814             LDR      R0,[SP, #+80]
   \      0x15A   0x1F00             SUBS     R0,R0,#+4
   \      0x15C   0xF850 0x3022      LDR      R3,[R0, R2, LSL #+2]
   \      0x160   0x4618             MOV      R0,R3
   \      0x162   0x2100             MOVS     R1,#+0
   \      0x164   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x168   0xD032             BEQ.N    ??dqrsl_16
   1281                  temp = a[j - 1 + (j - 1) * lda];
   \      0x16A   0x1E50             SUBS     R0,R2,#+1
   \      0x16C   0x9905             LDR      R1,[SP, #+20]
   \      0x16E   0x4348             MULS     R0,R1,R0
   \      0x170   0x1887             ADDS     R7,R0,R2
   \      0x172   0xF858 0x9027      LDR      R9,[R8, R7, LSL #+2]
   1282                  a[j - 1 + (j - 1)*lda] = qraux[j - 1];
   \      0x176   0xF848 0x3027      STR      R3,[R8, R7, LSL #+2]
   1283                  t = -ddot(n - j + 1, a + j - 1 + (j - 1) * lda, 1, qy + j - 1, 1) / a[j - 1 + (j - 1) * lda];
   \      0x17A   0xEB04 0x0182      ADD      R1,R4,R2, LSL #+2
   \      0x17E   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \      0x182   0xF1A0 0x0A04      SUB      R10,R0,#+4
   \      0x186   0xF8DD 0xB024      LDR      R11,[SP, #+36]
   \      0x18A   0xEBAB 0x0B02      SUB      R11,R11,R2
   \      0x18E   0xF10B 0x0B01      ADD      R11,R11,#+1
   \      0x192   0x9816             LDR      R0,[SP, #+88]
   \      0x194   0x1F00             SUBS     R0,R0,#+4
   \      0x196   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \      0x19A   0x9002             STR      R0,[SP, #+8]
   \      0x19C   0x2001             MOVS     R0,#+1
   \      0x19E   0x9000             STR      R0,[SP, #+0]
   \      0x1A0   0x9B02             LDR      R3,[SP, #+8]
   \      0x1A2   0x4602             MOV      R2,R0
   \      0x1A4   0x4651             MOV      R1,R10
   \      0x1A6   0x4658             MOV      R0,R11
   \      0x1A8   0x.... 0x....      BL       _Z4ddotiPfiS_i
   \      0x1AC   0xF858 0x1027      LDR      R1,[R8, R7, LSL #+2]
   \      0x1B0   0x.... 0x....      BL       __aeabi_fdiv
   \      0x1B4   0xF080 0x4000      EOR      R0,R0,#0x80000000
   1284                  daxpy(n - j + 1, t, a + j - 1 + (j - 1)*lda, 1, qy + j - 1, 1);
   \      0x1B8   0x2101             MOVS     R1,#+1
   \      0x1BA   0x9101             STR      R1,[SP, #+4]
   \      0x1BC   0x9902             LDR      R1,[SP, #+8]
   \      0x1BE   0x9100             STR      R1,[SP, #+0]
   \      0x1C0   0x2301             MOVS     R3,#+1
   \      0x1C2   0x4652             MOV      R2,R10
   \      0x1C4   0x4601             MOV      R1,R0
   \      0x1C6   0x4658             MOV      R0,R11
   \      0x1C8   0x.... 0x....      BL       _Z5daxpyifPfiS_i
   1285                  a[j - 1 + (j - 1)*lda] = temp;
   \      0x1CC   0xF848 0x9027      STR      R9,[R8, R7, LSL #+2]
   1286                }
   1287              }
   \                     ??dqrsl_16: (+1)
   \      0x1D0   0x1C76             ADDS     R6,R6,#+1
   \                     ??dqrsl_14: (+1)
   \      0x1D2   0x42B5             CMP      R5,R6
   \      0x1D4   0xDABE             BGE.N    ??dqrsl_15
   \      0x1D6   0x4626             MOV      R6,R4
   \      0x1D8   0x9805             LDR      R0,[SP, #+20]
   \      0x1DA   0x9502             STR      R5,[SP, #+8]
   1288            }
   1289            /**
   1290              Compute Q'*Y.
   1291            */
   1292            if (cqty) {
   \                     ??dqrsl_13: (+1)
   \      0x1DC   0x9907             LDR      R1,[SP, #+28]
   \      0x1DE   0x2900             CMP      R1,#+0
   \      0x1E0   0xD046             BEQ.N    ??dqrsl_17
   1293              for (j = 1; j <= ju; j++) {
   \      0x1E2   0x2501             MOVS     R5,#+1
   \      0x1E4   0x9005             STR      R0,[SP, #+20]
   \      0x1E6   0x9C02             LDR      R4,[SP, #+8]
   \      0x1E8   0xF1A6 0x0804      SUB      R8,R6,#+4
   \      0x1EC   0xE03C             B.N      ??dqrsl_18
   1294                if (qraux[j - 1] != 0.0) {
   \                     ??dqrsl_19: (+1)
   \      0x1EE   0x9814             LDR      R0,[SP, #+80]
   \      0x1F0   0x1F00             SUBS     R0,R0,#+4
   \      0x1F2   0xF850 0x2025      LDR      R2,[R0, R5, LSL #+2]
   \      0x1F6   0x4610             MOV      R0,R2
   \      0x1F8   0x2100             MOVS     R1,#+0
   \      0x1FA   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x1FE   0xD032             BEQ.N    ??dqrsl_20
   1295                  temp = a[j - 1 + (j - 1) * lda];
   \      0x200   0x1E68             SUBS     R0,R5,#+1
   \      0x202   0x9905             LDR      R1,[SP, #+20]
   \      0x204   0x4348             MULS     R0,R1,R0
   \      0x206   0x1947             ADDS     R7,R0,R5
   \      0x208   0xF858 0x9027      LDR      R9,[R8, R7, LSL #+2]
   1296                  a[j - 1 + (j - 1)*lda] = qraux[j - 1];
   \      0x20C   0xF848 0x2027      STR      R2,[R8, R7, LSL #+2]
   1297                  t = -ddot(n - j + 1, a + j - 1 + (j - 1) * lda, 1, qty + j - 1, 1) / a[j - 1 + (j - 1) * lda];
   \      0x210   0xEB06 0x0185      ADD      R1,R6,R5, LSL #+2
   \      0x214   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \      0x218   0xF1A0 0x0A04      SUB      R10,R0,#+4
   \      0x21C   0xF8DD 0xB024      LDR      R11,[SP, #+36]
   \      0x220   0xEBAB 0x0B05      SUB      R11,R11,R5
   \      0x224   0xF10B 0x0B01      ADD      R11,R11,#+1
   \      0x228   0x9817             LDR      R0,[SP, #+92]
   \      0x22A   0x1F00             SUBS     R0,R0,#+4
   \      0x22C   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \      0x230   0x9002             STR      R0,[SP, #+8]
   \      0x232   0x2001             MOVS     R0,#+1
   \      0x234   0x9000             STR      R0,[SP, #+0]
   \      0x236   0x9B02             LDR      R3,[SP, #+8]
   \      0x238   0x4602             MOV      R2,R0
   \      0x23A   0x4651             MOV      R1,R10
   \      0x23C   0x4658             MOV      R0,R11
   \      0x23E   0x.... 0x....      BL       _Z4ddotiPfiS_i
   \      0x242   0xF858 0x1027      LDR      R1,[R8, R7, LSL #+2]
   \      0x246   0x.... 0x....      BL       __aeabi_fdiv
   \      0x24A   0xF080 0x4000      EOR      R0,R0,#0x80000000
   1298                  daxpy(n - j + 1, t, a + j - 1 + (j - 1)*lda, 1, qty + j - 1, 1);
   \      0x24E   0x2101             MOVS     R1,#+1
   \      0x250   0x9101             STR      R1,[SP, #+4]
   \      0x252   0x9902             LDR      R1,[SP, #+8]
   \      0x254   0x9100             STR      R1,[SP, #+0]
   \      0x256   0x2301             MOVS     R3,#+1
   \      0x258   0x4652             MOV      R2,R10
   \      0x25A   0x4601             MOV      R1,R0
   \      0x25C   0x4658             MOV      R0,R11
   \      0x25E   0x.... 0x....      BL       _Z5daxpyifPfiS_i
   1299                  a[j - 1 + (j - 1)*lda] = temp;
   \      0x262   0xF848 0x9027      STR      R9,[R8, R7, LSL #+2]
   1300                }
   1301              }
   \                     ??dqrsl_20: (+1)
   \      0x266   0x1C6D             ADDS     R5,R5,#+1
   \                     ??dqrsl_18: (+1)
   \      0x268   0x42AC             CMP      R4,R5
   \      0x26A   0xDAC0             BGE.N    ??dqrsl_19
   \      0x26C   0x9805             LDR      R0,[SP, #+20]
   \      0x26E   0x9402             STR      R4,[SP, #+8]
   1302            }
   1303            /**
   1304              Set up to compute B, RSD, or AB.
   1305            */
   1306            if (cb) {
   \                     ??dqrsl_17: (+1)
   \      0x270   0x9906             LDR      R1,[SP, #+24]
   \      0x272   0x2900             CMP      R1,#+0
   \      0x274   0xD010             BEQ.N    ??dqrsl_21
   1307              for (i = 1; i <= k; i++)
   \      0x276   0x2401             MOVS     R4,#+1
   \      0x278   0x990A             LDR      R1,[SP, #+40]
   \      0x27A   0x9A17             LDR      R2,[SP, #+92]
   \      0x27C   0x9B18             LDR      R3,[SP, #+96]
   \      0x27E   0x1F1F             SUBS     R7,R3,#+4
   \      0x280   0xE005             B.N      ??dqrsl_22
   1308                b[i - 1] = qty[i - 1];
   \                     ??dqrsl_23: (+1)
   \      0x282   0x1F15             SUBS     R5,R2,#+4
   \      0x284   0xF855 0x5024      LDR      R5,[R5, R4, LSL #+2]
   \      0x288   0xF847 0x5024      STR      R5,[R7, R4, LSL #+2]
   \      0x28C   0x1C64             ADDS     R4,R4,#+1
   \                     ??dqrsl_22: (+1)
   \      0x28E   0x42A1             CMP      R1,R4
   \      0x290   0xDAF7             BGE.N    ??dqrsl_23
   \      0x292   0x910A             STR      R1,[SP, #+40]
   \      0x294   0x9217             STR      R2,[SP, #+92]
   \      0x296   0x9318             STR      R3,[SP, #+96]
   1309            }
   1310            if (cab) {
   \                     ??dqrsl_21: (+1)
   \      0x298   0x9903             LDR      R1,[SP, #+12]
   \      0x29A   0x2900             CMP      R1,#+0
   \      0x29C   0xD010             BEQ.N    ??dqrsl_24
   1311              for (i = 1; i <= k; i++)
   \      0x29E   0x2401             MOVS     R4,#+1
   \      0x2A0   0x990A             LDR      R1,[SP, #+40]
   \      0x2A2   0x9A17             LDR      R2,[SP, #+92]
   \      0x2A4   0x9B1A             LDR      R3,[SP, #+104]
   \      0x2A6   0x1F1F             SUBS     R7,R3,#+4
   \      0x2A8   0xE005             B.N      ??dqrsl_25
   1312                ab[i - 1] = qty[i - 1];
   \                     ??dqrsl_26: (+1)
   \      0x2AA   0x1F15             SUBS     R5,R2,#+4
   \      0x2AC   0xF855 0x5024      LDR      R5,[R5, R4, LSL #+2]
   \      0x2B0   0xF847 0x5024      STR      R5,[R7, R4, LSL #+2]
   \      0x2B4   0x1C64             ADDS     R4,R4,#+1
   \                     ??dqrsl_25: (+1)
   \      0x2B6   0x42A1             CMP      R1,R4
   \      0x2B8   0xDAF7             BGE.N    ??dqrsl_26
   \      0x2BA   0x910A             STR      R1,[SP, #+40]
   \      0x2BC   0x9217             STR      R2,[SP, #+92]
   \      0x2BE   0x931A             STR      R3,[SP, #+104]
   1313            }
   1314            if (cr && k < n) {
   \                     ??dqrsl_24: (+1)
   \      0x2C0   0x9904             LDR      R1,[SP, #+16]
   \      0x2C2   0x2900             CMP      R1,#+0
   \      0x2C4   0xD014             BEQ.N    ??dqrsl_27
   \      0x2C6   0x990A             LDR      R1,[SP, #+40]
   \      0x2C8   0x9A09             LDR      R2,[SP, #+36]
   \      0x2CA   0x4291             CMP      R1,R2
   \      0x2CC   0xDA10             BGE.N    ??dqrsl_27
   1315              for (i = k + 1; i <= n; i++)
   \      0x2CE   0x460C             MOV      R4,R1
   \      0x2D0   0x1C64             ADDS     R4,R4,#+1
   \      0x2D2   0x4611             MOV      R1,R2
   \      0x2D4   0x9A17             LDR      R2,[SP, #+92]
   \      0x2D6   0x9B19             LDR      R3,[SP, #+100]
   \      0x2D8   0x1F1F             SUBS     R7,R3,#+4
   \      0x2DA   0xE005             B.N      ??dqrsl_28
   1316                rsd[i - 1] = qty[i - 1];
   \                     ??dqrsl_29: (+1)
   \      0x2DC   0x1F15             SUBS     R5,R2,#+4
   \      0x2DE   0xF855 0x5024      LDR      R5,[R5, R4, LSL #+2]
   \      0x2E2   0xF847 0x5024      STR      R5,[R7, R4, LSL #+2]
   \      0x2E6   0x1C64             ADDS     R4,R4,#+1
   \                     ??dqrsl_28: (+1)
   \      0x2E8   0x42A1             CMP      R1,R4
   \      0x2EA   0xDAF7             BGE.N    ??dqrsl_29
   \      0x2EC   0x9109             STR      R1,[SP, #+36]
   \      0x2EE   0x9319             STR      R3,[SP, #+100]
   1317            }
   1318            if (cab && k + 1 <= n) {
   \                     ??dqrsl_27: (+1)
   \      0x2F0   0x9903             LDR      R1,[SP, #+12]
   \      0x2F2   0x2900             CMP      R1,#+0
   \      0x2F4   0xD00F             BEQ.N    ??dqrsl_30
   \      0x2F6   0x9B0A             LDR      R3,[SP, #+40]
   \      0x2F8   0x1C5B             ADDS     R3,R3,#+1
   \      0x2FA   0x9909             LDR      R1,[SP, #+36]
   \      0x2FC   0x4299             CMP      R1,R3
   \      0x2FE   0xDB0A             BLT.N    ??dqrsl_30
   1319              for (i = k + 1; i <= n; i++)
   \      0x300   0x9A1A             LDR      R2,[SP, #+104]
   \      0x302   0x2400             MOVS     R4,#+0
   \      0x304   0x1F15             SUBS     R5,R2,#+4
   \      0x306   0xE002             B.N      ??dqrsl_31
   1320                ab[i - 1] = 0.0;
   \                     ??dqrsl_32: (+1)
   \      0x308   0xF845 0x4023      STR      R4,[R5, R3, LSL #+2]
   \      0x30C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??dqrsl_31: (+1)
   \      0x30E   0x4299             CMP      R1,R3
   \      0x310   0xDAFA             BGE.N    ??dqrsl_32
   \      0x312   0x9109             STR      R1,[SP, #+36]
   \      0x314   0x921A             STR      R2,[SP, #+104]
   1321            }
   1322            if (cr) {
   \                     ??dqrsl_30: (+1)
   \      0x316   0x9904             LDR      R1,[SP, #+16]
   \      0x318   0x2900             CMP      R1,#+0
   \      0x31A   0xD00C             BEQ.N    ??dqrsl_33
   1323              for (i = 1; i <= k; i++)
   \      0x31C   0x2301             MOVS     R3,#+1
   \      0x31E   0x990A             LDR      R1,[SP, #+40]
   \      0x320   0x9A19             LDR      R2,[SP, #+100]
   \      0x322   0x2400             MOVS     R4,#+0
   \      0x324   0x1F15             SUBS     R5,R2,#+4
   \      0x326   0xE002             B.N      ??dqrsl_34
   1324                rsd[i - 1] = 0.0;
   \                     ??dqrsl_35: (+1)
   \      0x328   0xF845 0x4023      STR      R4,[R5, R3, LSL #+2]
   \      0x32C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??dqrsl_34: (+1)
   \      0x32E   0x4299             CMP      R1,R3
   \      0x330   0xDAFA             BGE.N    ??dqrsl_35
   \      0x332   0x910A             STR      R1,[SP, #+40]
   \      0x334   0x9219             STR      R2,[SP, #+100]
   1325            }
   1326            /**
   1327              Compute B.
   1328            */
   1329            if (cb) {
   \                     ??dqrsl_33: (+1)
   \      0x336   0x9906             LDR      R1,[SP, #+24]
   \      0x338   0x2900             CMP      R1,#+0
   \      0x33A   0xD035             BEQ.N    ??dqrsl_36
   1330              for (jj = 1; jj <= k; jj++) {
   \      0x33C   0xF04F 0x0801      MOV      R8,#+1
   \      0x340   0x4604             MOV      R4,R0
   \      0x342   0x9F18             LDR      R7,[SP, #+96]
   \      0x344   0xF1A7 0x0B04      SUB      R11,R7,#+4
   \      0x348   0xE016             B.N      ??dqrsl_37
   1331                j = k - jj + 1;
   1332                if (a[j - 1 + (j - 1)*lda] == 0.0) {
   1333                  info = j;
   1334                  break;
   1335                }
   1336                b[j - 1] = b[j - 1] / a[j - 1 + (j - 1) * lda];
   \                     ??dqrsl_38: (+1)
   \      0x34A   0xF85B 0x0025      LDR      R0,[R11, R5, LSL #+2]
   \      0x34E   0x4611             MOV      R1,R2
   \      0x350   0x.... 0x....      BL       __aeabi_fdiv
   \      0x354   0xF84B 0x0025      STR      R0,[R11, R5, LSL #+2]
   1337                if (j != 1) {
   \      0x358   0x2D01             CMP      R5,#+1
   \      0x35A   0xD00B             BEQ.N    ??dqrsl_39
   1338                  t = -b[j - 1];
   1339                  daxpy(j - 1, t, a + 0 + (j - 1)*lda, 1, b, 1);
   \      0x35C   0x2101             MOVS     R1,#+1
   \      0x35E   0x9101             STR      R1,[SP, #+4]
   \      0x360   0x9700             STR      R7,[SP, #+0]
   \      0x362   0x460B             MOV      R3,R1
   \      0x364   0xEB06 0x028A      ADD      R2,R6,R10, LSL #+2
   \      0x368   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \      0x36C   0x4601             MOV      R1,R0
   \      0x36E   0x4648             MOV      R0,R9
   \      0x370   0x.... 0x....      BL       _Z5daxpyifPfiS_i
   1340                }
   \                     ??dqrsl_39: (+1)
   \      0x374   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??dqrsl_37: (+1)
   \      0x378   0x980A             LDR      R0,[SP, #+40]
   \      0x37A   0x4540             CMP      R0,R8
   \      0x37C   0xF2C0 0x8092      BLT.W    ??dqrsl_40
   \      0x380   0x4605             MOV      R5,R0
   \      0x382   0xEBA5 0x0508      SUB      R5,R5,R8
   \      0x386   0x1C6D             ADDS     R5,R5,#+1
   \      0x388   0xF1A5 0x0901      SUB      R9,R5,#+1
   \      0x38C   0xFB04 0xFA09      MUL      R10,R4,R9
   \      0x390   0x1F30             SUBS     R0,R6,#+4
   \      0x392   0xEB0A 0x0105      ADD      R1,R10,R5
   \      0x396   0xF850 0x2021      LDR      R2,[R0, R1, LSL #+2]
   \      0x39A   0x4610             MOV      R0,R2
   \      0x39C   0x2100             MOVS     R1,#+0
   \      0x39E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x3A2   0xD1D2             BNE.N    ??dqrsl_38
   \      0x3A4   0x4620             MOV      R0,R4
   \      0x3A6   0x9508             STR      R5,[SP, #+32]
   1341              }
   1342            }
   1343            /**
   1344              Compute RSD or AB as required.
   1345            */
   1346            if (cr || cab) {
   \                     ??dqrsl_36: (+1)
   \      0x3A8   0x9904             LDR      R1,[SP, #+16]
   \      0x3AA   0x9A03             LDR      R2,[SP, #+12]
   \      0x3AC   0x4311             ORRS     R1,R2,R1
   \      0x3AE   0xD075             BEQ.N    ??dqrsl_6
   1347              for (jj = 1; jj <= ju; jj++) {
   \      0x3B0   0x2401             MOVS     R4,#+1
   \      0x3B2   0x9606             STR      R6,[SP, #+24]
   \      0x3B4   0x9005             STR      R0,[SP, #+20]
   \      0x3B6   0xE06E             B.N      ??dqrsl_41
   1348                j = ju - jj + 1;
   \                     ??dqrsl_42: (+1)
   \      0x3B8   0x4605             MOV      R5,R0
   \      0x3BA   0x1B2D             SUBS     R5,R5,R4
   \      0x3BC   0x1C6D             ADDS     R5,R5,#+1
   1349                if (qraux[j - 1] != 0.0) {
   \      0x3BE   0x9814             LDR      R0,[SP, #+80]
   \      0x3C0   0x1F00             SUBS     R0,R0,#+4
   \      0x3C2   0xF850 0x2025      LDR      R2,[R0, R5, LSL #+2]
   \      0x3C6   0x4610             MOV      R0,R2
   \      0x3C8   0x2100             MOVS     R1,#+0
   \      0x3CA   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x3CE   0xD061             BEQ.N    ??dqrsl_43
   1350                  temp = a[j - 1 + (j - 1) * lda];
   \      0x3D0   0x1E6E             SUBS     R6,R5,#+1
   \      0x3D2   0x9805             LDR      R0,[SP, #+20]
   \      0x3D4   0x4346             MULS     R6,R0,R6
   \      0x3D6   0x1977             ADDS     R7,R6,R5
   \      0x3D8   0x9806             LDR      R0,[SP, #+24]
   \      0x3DA   0xF1A0 0x0804      SUB      R8,R0,#+4
   \      0x3DE   0xF858 0x9027      LDR      R9,[R8, R7, LSL #+2]
   1351                  a[j - 1 + (j - 1)*lda] = qraux[j - 1];
   \      0x3E2   0xF848 0x2027      STR      R2,[R8, R7, LSL #+2]
   1352                  if (cr) {
   \      0x3E6   0x9804             LDR      R0,[SP, #+16]
   \      0x3E8   0x2800             CMP      R0,#+0
   \      0x3EA   0xD029             BEQ.N    ??dqrsl_44
   1353                    t = -ddot(n - j + 1, a + j - 1 + (j - 1) * lda, 1, rsd + j - 1, 1)
   1354                        / a[j - 1 + (j - 1) * lda];
   \      0x3EC   0x9806             LDR      R0,[SP, #+24]
   \      0x3EE   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \      0x3F2   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \      0x3F6   0xF1A0 0x0A04      SUB      R10,R0,#+4
   \      0x3FA   0xF8DD 0xB024      LDR      R11,[SP, #+36]
   \      0x3FE   0xEBAB 0x0B05      SUB      R11,R11,R5
   \      0x402   0xF10B 0x0B01      ADD      R11,R11,#+1
   \      0x406   0x9819             LDR      R0,[SP, #+100]
   \      0x408   0x1F00             SUBS     R0,R0,#+4
   \      0x40A   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \      0x40E   0x9007             STR      R0,[SP, #+28]
   \      0x410   0x2001             MOVS     R0,#+1
   \      0x412   0x9000             STR      R0,[SP, #+0]
   \      0x414   0x9B07             LDR      R3,[SP, #+28]
   \      0x416   0x4602             MOV      R2,R0
   \      0x418   0x4651             MOV      R1,R10
   \      0x41A   0x4658             MOV      R0,R11
   \      0x41C   0x.... 0x....      BL       _Z4ddotiPfiS_i
   \      0x420   0xF858 0x1027      LDR      R1,[R8, R7, LSL #+2]
   \      0x424   0x.... 0x....      BL       __aeabi_fdiv
   \      0x428   0xF080 0x4000      EOR      R0,R0,#0x80000000
   1355                    daxpy(n - j + 1, t, a + j - 1 + (j - 1)*lda, 1, rsd + j - 1, 1);
   \      0x42C   0x2101             MOVS     R1,#+1
   \      0x42E   0x9101             STR      R1,[SP, #+4]
   \      0x430   0x9907             LDR      R1,[SP, #+28]
   \      0x432   0x9100             STR      R1,[SP, #+0]
   \      0x434   0x2301             MOVS     R3,#+1
   \      0x436   0x4652             MOV      R2,R10
   \      0x438   0x4601             MOV      R1,R0
   \      0x43A   0x4658             MOV      R0,R11
   \      0x43C   0x.... 0x....      BL       _Z5daxpyifPfiS_i
   1356                  }
   1357                  if (cab) {
   \                     ??dqrsl_44: (+1)
   \      0x440   0x9803             LDR      R0,[SP, #+12]
   \      0x442   0x2800             CMP      R0,#+0
   \      0x444   0xD024             BEQ.N    ??dqrsl_45
   1358                    t = -ddot(n - j + 1, a + j - 1 + (j - 1) * lda, 1, ab + j - 1, 1)
   1359                        / a[j - 1 + (j - 1) * lda];
   \      0x446   0x9806             LDR      R0,[SP, #+24]
   \      0x448   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \      0x44C   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \      0x450   0x1F06             SUBS     R6,R0,#+4
   \      0x452   0x981A             LDR      R0,[SP, #+104]
   \      0x454   0x1F00             SUBS     R0,R0,#+4
   \      0x456   0xEB00 0x0A85      ADD      R10,R0,R5, LSL #+2
   \      0x45A   0x9809             LDR      R0,[SP, #+36]
   \      0x45C   0x1B45             SUBS     R5,R0,R5
   \      0x45E   0x1C6D             ADDS     R5,R5,#+1
   \      0x460   0x2001             MOVS     R0,#+1
   \      0x462   0x9000             STR      R0,[SP, #+0]
   \      0x464   0x4653             MOV      R3,R10
   \      0x466   0x4602             MOV      R2,R0
   \      0x468   0x4631             MOV      R1,R6
   \      0x46A   0x4628             MOV      R0,R5
   \      0x46C   0x.... 0x....      BL       _Z4ddotiPfiS_i
   \      0x470   0xF858 0x1027      LDR      R1,[R8, R7, LSL #+2]
   \      0x474   0x.... 0x....      BL       __aeabi_fdiv
   \      0x478   0xF080 0x4000      EOR      R0,R0,#0x80000000
   1360                    daxpy(n - j + 1, t, a + j - 1 + (j - 1)*lda, 1, ab + j - 1, 1);
   \      0x47C   0x2101             MOVS     R1,#+1
   \      0x47E   0x9101             STR      R1,[SP, #+4]
   \      0x480   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \      0x484   0x460B             MOV      R3,R1
   \      0x486   0x4632             MOV      R2,R6
   \      0x488   0x4601             MOV      R1,R0
   \      0x48A   0x4628             MOV      R0,R5
   \      0x48C   0x.... 0x....      BL       _Z5daxpyifPfiS_i
   1361                  }
   1362                  a[j - 1 + (j - 1)*lda] = temp;
   \                     ??dqrsl_45: (+1)
   \      0x490   0xF848 0x9027      STR      R9,[R8, R7, LSL #+2]
   1363                }
   1364              }
   \                     ??dqrsl_43: (+1)
   \      0x494   0x1C64             ADDS     R4,R4,#+1
   \                     ??dqrsl_41: (+1)
   \      0x496   0x9802             LDR      R0,[SP, #+8]
   \      0x498   0x42A0             CMP      R0,R4
   \      0x49A   0xDA8D             BGE.N    ??dqrsl_42
   1365            }
   1366            return info;
   \                     ??dqrsl_6: (+1)
   \      0x49C   0x9808             LDR      R0,[SP, #+32]
   \      0x49E   0xB00B             ADD      SP,SP,#+44
   \      0x4A0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??dqrsl_40: (+1)
   \      0x4A4   0x4620             MOV      R0,R4
   \      0x4A6   0xE77F             B.N      ??dqrsl_36
   1367          }
   1368          /******************************************************************************/
   1369          
   1370          /******************************************************************************/
   1371          

   \                                 In section .text, align 2, keep-with-next
   1372          void dscal(int n, float sa, float x[], int incx)
   1373          
   1374          /******************************************************************************/
   1375          /**
   1376            Purpose:
   1377          
   1378              DSCAL scales a vector by a constant.
   1379          
   1380            Licensing:
   1381          
   1382              This code is distributed under the GNU LGPL license.
   1383          
   1384            Modified:
   1385          
   1386              30 March 2007
   1387          
   1388            Author:
   1389          
   1390              C version by John Burkardt
   1391          
   1392            Reference:
   1393          
   1394              Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
   1395              LINPACK User's Guide,
   1396              SIAM, 1979.
   1397          
   1398              Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,
   1399              Basic Linear Algebra Subprograms for Fortran Usage,
   1400              Algorithm 539,
   1401              ACM Transactions on Mathematical Software,
   1402              Volume 5, Number 3, September 1979, pages 308-323.
   1403          
   1404            Parameters:
   1405          
   1406              Input, int N, the number of entries in the vector.
   1407          
   1408              Input, float SA, the multiplier.
   1409          
   1410              Input/output, float X[*], the vector to be scaled.
   1411          
   1412              Input, int INCX, the increment between successive entries of X.
   1413          */
   1414          {
   \                     _Z5dscalifPfi: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
   1415            int i;
   1416            int ix;
   1417            int m;
   1418          
   1419            if (n <= 0) return;
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xDD56             BLE.N    ??dscal_0
   1420          
   1421            if (incx == 1) {
   \       0x10   0x2F01             CMP      R7,#+1
   \       0x12   0xD13C             BNE.N    ??dscal_1
   1422              m = n % 5;
   \       0x14   0x2005             MOVS     R0,#+5
   \       0x16   0xFB94 0xF7F0      SDIV     R7,R4,R0
   \       0x1A   0xEB07 0x0787      ADD      R7,R7,R7, LSL #+2
   \       0x1E   0x1BE7             SUBS     R7,R4,R7
   1423              for (i = 0; i < m; i++)
   \       0x20   0xF04F 0x0800      MOV      R8,#+0
   \       0x24   0xE008             B.N      ??dscal_2
   1424                x[i] = sa * x[i];
   \                     ??dscal_3: (+1)
   \       0x26   0xF856 0x0028      LDR      R0,[R6, R8, LSL #+2]
   \       0x2A   0x4629             MOV      R1,R5
   \       0x2C   0x.... 0x....      BL       __aeabi_fmul
   \       0x30   0xF846 0x0028      STR      R0,[R6, R8, LSL #+2]
   \       0x34   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??dscal_2: (+1)
   \       0x38   0x45B8             CMP      R8,R7
   \       0x3A   0xDBF4             BLT.N    ??dscal_3
   1425              for (i = m; i < n; i = i + 5) {
   \                     ??dscal_4: (+1)
   \       0x3C   0x42A7             CMP      R7,R4
   \       0x3E   0xDA3E             BGE.N    ??dscal_0
   1426                x[i]   = sa * x[i];
   \       0x40   0xEB06 0x0887      ADD      R8,R6,R7, LSL #+2
   \       0x44   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x48   0x4629             MOV      R1,R5
   \       0x4A   0x.... 0x....      BL       __aeabi_fmul
   \       0x4E   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1427                x[i + 1] = sa * x[i + 1];
   \       0x52   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x56   0x4629             MOV      R1,R5
   \       0x58   0x.... 0x....      BL       __aeabi_fmul
   \       0x5C   0xF8C8 0x0004      STR      R0,[R8, #+4]
   1428                x[i + 2] = sa * x[i + 2];
   \       0x60   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x64   0x4629             MOV      R1,R5
   \       0x66   0x.... 0x....      BL       __aeabi_fmul
   \       0x6A   0xF8C8 0x0008      STR      R0,[R8, #+8]
   1429                x[i + 3] = sa * x[i + 3];
   \       0x6E   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0x72   0x4629             MOV      R1,R5
   \       0x74   0x.... 0x....      BL       __aeabi_fmul
   \       0x78   0xF8C8 0x000C      STR      R0,[R8, #+12]
   1430                x[i + 4] = sa * x[i + 4];
   \       0x7C   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0x80   0x4629             MOV      R1,R5
   \       0x82   0x.... 0x....      BL       __aeabi_fmul
   \       0x86   0xF8C8 0x0010      STR      R0,[R8, #+16]
   1431              }
   \       0x8A   0x1D7F             ADDS     R7,R7,#+5
   \       0x8C   0xE7D6             B.N      ??dscal_4
   1432            }
   1433            else {
   1434              if (0 <= incx)
   \                     ??dscal_1: (+1)
   \       0x8E   0x2F00             CMP      R7,#+0
   \       0x90   0xD402             BMI.N    ??dscal_5
   1435                ix = 0;
   \       0x92   0xF04F 0x0900      MOV      R9,#+0
   \       0x96   0xE003             B.N      ??dscal_6
   1436              else
   1437                ix = (- n + 1) * incx;
   \                     ??dscal_5: (+1)
   \       0x98   0xF1C4 0x0901      RSB      R9,R4,#+1
   \       0x9C   0xFB07 0xF909      MUL      R9,R7,R9
   1438              for (i = 0; i < n; i++) {
   \                     ??dscal_6: (+1)
   \       0xA0   0xF04F 0x0800      MOV      R8,#+0
   \                     ??dscal_7: (+1)
   \       0xA4   0x45A0             CMP      R8,R4
   \       0xA6   0xDA0A             BGE.N    ??dscal_0
   1439                x[ix] = sa * x[ix];
   \       0xA8   0xF856 0x0029      LDR      R0,[R6, R9, LSL #+2]
   \       0xAC   0x4629             MOV      R1,R5
   \       0xAE   0x.... 0x....      BL       __aeabi_fmul
   \       0xB2   0xF846 0x0029      STR      R0,[R6, R9, LSL #+2]
   1440                ix = ix + incx;
   \       0xB6   0x44B9             ADD      R9,R7,R9
   1441              }
   \       0xB8   0xF108 0x0801      ADD      R8,R8,#+1
   \       0xBC   0xE7F2             B.N      ??dscal_7
   1442            }
   1443          }
   \                     ??dscal_0: (+1)
   \       0xBE   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1444          /******************************************************************************/
   1445          
   1446          

   \                                 In section .text, align 2, keep-with-next
   1447          void dswap(int n, float x[], int incx, float y[], int incy)
   1448          
   1449          /******************************************************************************/
   1450          /**
   1451            Purpose:
   1452          
   1453              DSWAP interchanges two vectors.
   1454          
   1455            Licensing:
   1456          
   1457              This code is distributed under the GNU LGPL license.
   1458          
   1459            Modified:
   1460          
   1461              30 March 2007
   1462          
   1463            Author:
   1464          
   1465              C version by John Burkardt
   1466          
   1467            Reference:
   1468          
   1469              Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
   1470              LINPACK User's Guide,
   1471              SIAM, 1979.
   1472          
   1473              Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,
   1474              Basic Linear Algebra Subprograms for Fortran Usage,
   1475              Algorithm 539,
   1476              ACM Transactions on Mathematical Software,
   1477              Volume 5, Number 3, September 1979, pages 308-323.
   1478          
   1479            Parameters:
   1480          
   1481              Input, int N, the number of entries in the vectors.
   1482          
   1483              Input/output, float X[*], one of the vectors to swap.
   1484          
   1485              Input, int INCX, the increment between successive entries of X.
   1486          
   1487              Input/output, float Y[*], one of the vectors to swap.
   1488          
   1489              Input, int INCY, the increment between successive elements of Y.
   1490          */
   1491          {
   \                     _Z5dswapiPfiS_i: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xDC00             BGT.N    ??dswap_0
   \        0x4   0x4770             BX       LR
   \                     ??dswap_0: (+1)
   \        0x6   0xB5F0             PUSH     {R4-R7,LR}
   1492            if (n <= 0) return;
   \        0x8   0x9C05             LDR      R4,[SP, #+20]
   1493          
   1494            int i, ix, iy, m;
   1495            float temp;
   1496          
   1497            if (incx == 1 && incy == 1) {
   \        0xA   0x2A01             CMP      R2,#+1
   \        0xC   0xD128             BNE.N    ??dswap_1
   \        0xE   0x2C01             CMP      R4,#+1
   \       0x10   0xD126             BNE.N    ??dswap_1
   1498              m = n % 3;
   \       0x12   0x2203             MOVS     R2,#+3
   \       0x14   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \       0x18   0xEB02 0x0242      ADD      R2,R2,R2, LSL #+1
   \       0x1C   0x1A82             SUBS     R2,R0,R2
   1499              for (i = 0; i < m; i++) {
   \       0x1E   0x2400             MOVS     R4,#+0
   \       0x20   0xE008             B.N      ??dswap_2
   1500                temp = x[i];
   \                     ??dswap_3: (+1)
   \       0x22   0xF851 0x5024      LDR      R5,[R1, R4, LSL #+2]
   1501                x[i] = y[i];
   \       0x26   0xF853 0x6024      LDR      R6,[R3, R4, LSL #+2]
   \       0x2A   0xF841 0x6024      STR      R6,[R1, R4, LSL #+2]
   1502                y[i] = temp;
   \       0x2E   0xF843 0x5024      STR      R5,[R3, R4, LSL #+2]
   1503              }
   \       0x32   0x1C64             ADDS     R4,R4,#+1
   \                     ??dswap_2: (+1)
   \       0x34   0x4294             CMP      R4,R2
   \       0x36   0xDBF4             BLT.N    ??dswap_3
   1504              for (i = m; i < n; i = i + 3) {
   \                     ??dswap_4: (+1)
   \       0x38   0x4282             CMP      R2,R0
   \       0x3A   0xDA30             BGE.N    ??dswap_5
   1505                temp = x[i];
   \       0x3C   0xEB01 0x0582      ADD      R5,R1,R2, LSL #+2
   \       0x40   0x682C             LDR      R4,[R5, #+0]
   1506                x[i] = y[i];
   \       0x42   0xEB03 0x0682      ADD      R6,R3,R2, LSL #+2
   \       0x46   0x6837             LDR      R7,[R6, #+0]
   \       0x48   0x602F             STR      R7,[R5, #+0]
   1507                y[i] = temp;
   \       0x4A   0x6034             STR      R4,[R6, #+0]
   1508                temp = x[i + 1];
   \       0x4C   0x686C             LDR      R4,[R5, #+4]
   1509                x[i + 1] = y[i + 1];
   \       0x4E   0x6877             LDR      R7,[R6, #+4]
   \       0x50   0x606F             STR      R7,[R5, #+4]
   1510                y[i + 1] = temp;
   \       0x52   0x6074             STR      R4,[R6, #+4]
   1511                temp = x[i + 2];
   \       0x54   0x68AC             LDR      R4,[R5, #+8]
   1512                x[i + 2] = y[i + 2];
   \       0x56   0x68B7             LDR      R7,[R6, #+8]
   \       0x58   0x60AF             STR      R7,[R5, #+8]
   1513                y[i + 2] = temp;
   \       0x5A   0x60B4             STR      R4,[R6, #+8]
   1514              }
   \       0x5C   0x1CD2             ADDS     R2,R2,#+3
   \       0x5E   0xE7EB             B.N      ??dswap_4
   1515            }
   1516            else {
   1517              ix = (incx >= 0) ? 0 : (-n + 1) * incx;
   \                     ??dswap_1: (+1)
   \       0x60   0x2A00             CMP      R2,#+0
   \       0x62   0xD401             BMI.N    ??dswap_6
   \       0x64   0x2700             MOVS     R7,#+0
   \       0x66   0xE002             B.N      ??dswap_7
   \                     ??dswap_6: (+1)
   \       0x68   0xF1C0 0x0701      RSB      R7,R0,#+1
   \       0x6C   0x4357             MULS     R7,R2,R7
   1518              iy = (incy >= 0) ? 0 : (-n + 1) * incy;
   \                     ??dswap_7: (+1)
   \       0x6E   0x2C00             CMP      R4,#+0
   \       0x70   0xD402             BMI.N    ??dswap_8
   \       0x72   0xF04F 0x0C00      MOV      R12,#+0
   \       0x76   0xE003             B.N      ??dswap_9
   \                     ??dswap_8: (+1)
   \       0x78   0xF1C0 0x0C01      RSB      R12,R0,#+1
   \       0x7C   0xFB04 0xFC0C      MUL      R12,R4,R12
   1519              for (i = 0; i < n; i++) {
   \                     ??dswap_9: (+1)
   \       0x80   0x2500             MOVS     R5,#+0
   \                     ??dswap_10: (+1)
   \       0x82   0x4285             CMP      R5,R0
   \       0x84   0xDA0B             BGE.N    ??dswap_5
   1520                temp = x[ix];
   \       0x86   0xF851 0x6027      LDR      R6,[R1, R7, LSL #+2]
   1521                x[ix] = y[iy];
   \       0x8A   0xF853 0xE02C      LDR      LR,[R3, R12, LSL #+2]
   \       0x8E   0xF841 0xE027      STR      LR,[R1, R7, LSL #+2]
   1522                y[iy] = temp;
   \       0x92   0xF843 0x602C      STR      R6,[R3, R12, LSL #+2]
   1523                ix = ix + incx;
   \       0x96   0x19D7             ADDS     R7,R2,R7
   1524                iy = iy + incy;
   \       0x98   0x44A4             ADD      R12,R4,R12
   1525              }
   \       0x9A   0x1C6D             ADDS     R5,R5,#+1
   \       0x9C   0xE7F1             B.N      ??dswap_10
   1526            }
   1527          }
   \                     ??dswap_5: (+1)
   \       0x9E   0xBDF0             POP      {R4-R7,PC}       ;; return
   1528          /******************************************************************************/
   1529          
   1530          /******************************************************************************/
   1531          

   \                                 In section .text, align 2, keep-with-next
   1532          void qr_solve(float x[], int m, int n, float a[], float b[])
   1533          
   1534          /******************************************************************************/
   1535          /**
   1536            Purpose:
   1537          
   1538              QR_SOLVE solves a linear system in the least squares sense.
   1539          
   1540            Discussion:
   1541          
   1542              If the matrix A has full column rank, then the solution X should be the
   1543              unique vector that minimizes the Euclidean norm of the residual.
   1544          
   1545              If the matrix A does not have full column rank, then the solution is
   1546              not unique; the vector X will minimize the residual norm, but so will
   1547              various other vectors.
   1548          
   1549            Licensing:
   1550          
   1551              This code is distributed under the GNU LGPL license.
   1552          
   1553            Modified:
   1554          
   1555              11 September 2012
   1556          
   1557            Author:
   1558          
   1559              John Burkardt
   1560          
   1561            Reference:
   1562          
   1563              David Kahaner, Cleve Moler, Steven Nash,
   1564              Numerical Methods and Software,
   1565              Prentice Hall, 1989,
   1566              ISBN: 0-13-627258-4,
   1567              LC: TA345.K34.
   1568          
   1569            Parameters:
   1570          
   1571              Input, int M, the number of rows of A.
   1572          
   1573              Input, int N, the number of columns of A.
   1574          
   1575              Input, float A[M*N], the matrix.
   1576          
   1577              Input, float B[M], the right hand side.
   1578          
   1579              Output, float QR_SOLVE[N], the least squares solution.
   1580          */
   1581          {
   \                     _Z8qr_solvePfiiS_S_: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x469B             MOV      R11,R3
   \        0xC   0x9E14             LDR      R6,[SP, #+80]
   1582            //  float a_qr[n * m], qraux[n], r[m], tol;	/*--mks--*/
   1583            //  int ind, itask, jpvt[n], kr, lda;
   1584            
   1585          	float *a_qr,*qraux,*r,tol;
   1586          	a_qr = (float *)malloc(n*m*sizeof(float));
   \        0xE   0xFB04 0xF005      MUL      R0,R4,R5
   \       0x12   0x0080             LSLS     R0,R0,#+2
   \       0x14   0x.... 0x....      BL       malloc
   \       0x18   0x4607             MOV      R7,R0
   1587          	qraux = (float *)malloc(n*sizeof(float));
   \       0x1A   0xEA4F 0x0A85      LSL      R10,R5,#+2
   \       0x1E   0x4650             MOV      R0,R10
   \       0x20   0x.... 0x....      BL       malloc
   \       0x24   0x4680             MOV      R8,R0
   1588          	r = (float *)malloc(m*sizeof(float));
   \       0x26   0x00A0             LSLS     R0,R4,#+2
   \       0x28   0x.... 0x....      BL       malloc
   \       0x2C   0x4681             MOV      R9,R0
   1589          	int ind, itask, *jpvt, kr, lda;
                 	    ^
Warning[Pe550]: variable "ind" was set but never used
   1590          	jpvt = (int *)malloc(n*sizeof(int));
   \       0x2E   0x4650             MOV      R0,R10
   \       0x30   0x.... 0x....      BL       malloc
   \       0x34   0x4682             MOV      R10,R0
   1591          
   1592            r8mat_copy(a_qr, m, n, a);
   \       0x36   0x465B             MOV      R3,R11
   \       0x38   0x462A             MOV      R2,R5
   \       0x3A   0x4621             MOV      R1,R4
   \       0x3C   0x4638             MOV      R0,R7
   \       0x3E   0x.... 0x....      BL       _Z10r8mat_copyPfiiS_
   1593            lda = m;
   1594            tol = r8_epsilon() / r8mat_amax(m, n, a_qr);
   \       0x42   0x.... 0x....      BL       _Z10r8_epsilonv
   \       0x46   0x4683             MOV      R11,R0
   \       0x48   0x463A             MOV      R2,R7
   \       0x4A   0x4629             MOV      R1,R5
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x.... 0x....      BL       _Z10r8mat_amaxiiPf
   \       0x52   0x4601             MOV      R1,R0
   \       0x54   0x4658             MOV      R0,R11
   \       0x56   0x.... 0x....      BL       __aeabi_fdiv
   1595            itask = 1;
   1596          
   1597            ind = dqrls(a_qr, lda, m, n, tol, &kr, b, x, r, jpvt, qraux, itask); UNUSED(ind);
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x9107             STR      R1,[SP, #+28]
   \       0x5E   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \       0x62   0xF8CD 0xA014      STR      R10,[SP, #+20]
   \       0x66   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x6A   0x990A             LDR      R1,[SP, #+40]
   \       0x6C   0x9103             STR      R1,[SP, #+12]
   \       0x6E   0x9602             STR      R6,[SP, #+8]
   \       0x70   0xA908             ADD      R1,SP,#+32
   \       0x72   0x9101             STR      R1,[SP, #+4]
   \       0x74   0x9000             STR      R0,[SP, #+0]
   \       0x76   0x462B             MOV      R3,R5
   \       0x78   0x4622             MOV      R2,R4
   \       0x7A   0x4621             MOV      R1,R4
   \       0x7C   0x4638             MOV      R0,R7
   \       0x7E   0x.... 0x....      BL       _Z5dqrlsPfiiifPiS_S_S_S0_S_i
   1598            free(a_qr);
   \       0x82   0x4638             MOV      R0,R7
   \       0x84   0x.... 0x....      BL       free
   1599            free(qraux);
   \       0x88   0x4640             MOV      R0,R8
   \       0x8A   0x.... 0x....      BL       free
   1600            free(r);
   \       0x8E   0x4648             MOV      R0,R9
   \       0x90   0x.... 0x....      BL       free
   1601            free(jpvt);
   \       0x94   0x4650             MOV      R0,R10
   \       0x96   0x.... 0x....      BL       free
   1602          }
   \       0x9A   0xB00B             ADD      SP,SP,#+44
   \       0x9C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0xBF80'0000        DC32     0xbf800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x9999'999A        DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x3FA9'9999        DC32     0x3fa99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x3FF0'0000        DC32     0x3ff00000
   1603          /******************************************************************************/
   1604          
   1605          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   daxpy(int, float, float *, int, float *, int)
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40 __aeabi_cfcmpeq
      40   ddot(int, float *, int, float *, int)
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
      40   dnrm2(int, float *, int)
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
         0   -> __aeabi_fmul
        40   -> __aeabi_fmul
         0   -> r8_abs(float)
        40   -> r8_abs(float)
        40   -> sqrtf
        40 __aeabi_cfcmpeq
        40 __aeabi_cfcmple
      56   dqrank(float *, int, int, int, float, int *, int *, float *)
        56   -> __aeabi_fmul
        56   -> dqrdc(float *, int, int, int, float *, int *, float *, int)
         0   -> free
        56   -> i4_min(int, int)
        56   -> malloc
        56   -> r8_abs(float)
        56 __aeabi_cfrcmple
     104   dqrdc(float *, int, int, int, float *, int *, float *, int)
       104   -> __aeabi_d2f
       104   -> __aeabi_dadd
       104   -> __aeabi_dmul
       104   -> __aeabi_f2d
       104   -> __aeabi_fadd
       104   -> __aeabi_fdiv
       104   -> __aeabi_fmul
       104   -> __aeabi_fsub
       104   -> daxpy(int, float, float *, int, float *, int)
       104   -> ddot(int, float *, int, float *, int)
       104   -> dnrm2(int, float *, int)
       104   -> dscal(int, float, float *, int)
       104   -> dswap(int, float *, int, float *, int)
       104   -> i4_min(int, int)
       104   -> r8_abs(float)
       104   -> r8_max(float, float)
       104   -> r8_sign(float)
       104   -> sqrtf
       104 __aeabi_cfcmpeq
       104 __aeabi_cfcmple
      56   dqrls(float *, int, int, int, float, int *, float *, float *, float *, int *, float *, int)
        56   -> dqrank(float *, int, int, int, float, int *, int *, float *)
        56   -> dqrlss(float *, int, int, int, int, float *, float *, float *, int *, float *)
      56   dqrlss(float *, int, int, int, int, float *, float *, float *, int *, float *)
        56   -> dqrsl(float *, int, int, int, float *, float *, float *, float *, float *, float *, float *, int)
      80   dqrsl(float *, int, int, int, float *, float *, float *, float *, float *, float *, float *, int)
        80   -> __aeabi_fdiv
        80   -> daxpy(int, float, float *, int, float *, int)
        80   -> ddot(int, float *, int, float *, int)
        80   -> i4_min(int, int)
        80 __aeabi_cfcmpeq
      32   dscal(int, float, float *, int)
        32   -> __aeabi_fmul
      20   dswap(int, float *, int, float *, int)
       0   i4_min(int, int)
      80   qr_solve(float *, int, int, float *, float *)
        80   -> __aeabi_fdiv
        80   -> dqrls(float *, int, int, int, float, int *, float *, float *, float *, int *, float *, int)
        80   -> free
        80   -> malloc
        80   -> r8_epsilon()
        80   -> r8mat_amax(int, int, float *)
        80   -> r8mat_copy(float *, int, int, float *)
       8   r8_abs(float)
         8 __aeabi_cfcmple
       0   r8_epsilon()
       8   r8_max(float, float)
         8 __aeabi_cfcmple
       8   r8_sign(float)
         8 __aeabi_cfcmple
      32   r8mat_amax(int, int, float *)
        32   -> r8_abs(float)
        32 __aeabi_cfcmple
      16   r8mat_copy(float *, int, int, float *)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
     302  daxpy(int, float, float *, int, float *, int)
     284  ddot(int, float *, int, float *, int)
     162  dnrm2(int, float *, int)
     172  dqrank(float *, int, int, int, float, int *, int *, float *)
    1022  dqrdc(float *, int, int, int, float *, int *, float *, int)
     120  dqrls(float *, int, int, int, float, int *, float *, float *, float *, int *, float *, int)
     154  dqrlss(float *, int, int, int, int, float *, float *, float *, int *, float *)
    1192  dqrsl(float *, int, int, int, float *, float *, float *, float *, float *, float *, float *, int)
     194  dscal(int, float, float *, int)
     160  dswap(int, float *, int, float *, int)
       8  i4_min(int, int)
     160  qr_solve(float *, int, int, float *, float *)
      16  r8_abs(float)
       6  r8_epsilon()
      20  r8_max(float, float)
      22  r8_sign(float)
      84  r8mat_amax(int, int, float *)
      38  r8mat_copy(float *, int, int, float *)

 
 4 132 bytes in section .text
 
 4 132 bytes of CODE memory

Errors: none
Warnings: 4
