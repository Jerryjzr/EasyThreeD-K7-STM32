###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  21:37:12
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_polygon.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EW5857.tmp
#        (F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_polygon.c -D
#        USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\u8g_polygon.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\u8g_polygon.o
#
###############################################################################

F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_polygon.c
      1          /*
      2          
      3            u8g_polygon.c
      4          
      5            Implementation of a polygon draw algorithm for "convex" polygons. 
      6           
      7            Universal 8bit Graphics Library
      8            
      9            Copyright (c) 2013, olikraus@gmail.com
     10            All rights reserved.
     11          
     12            Redistribution and use in source and binary forms, with or without modification, 
     13            are permitted provided that the following conditions are met:
     14          
     15            * Redistributions of source code must retain the above copyright notice, this list 
     16              of conditions and the following disclaimer.
     17              
     18            * Redistributions in binary form must reproduce the above copyright notice, this 
     19              list of conditions and the following disclaimer in the documentation and/or other 
     20              materials provided with the distribution.
     21          
     22            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
     23            CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
     24            INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
     25            MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
     26            DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
     27            CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     28            SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
     29            NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
     30            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
     31            CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     32            STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
     33            ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
     34            ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
     35           
     36            See also:
     37            http://www.angelfire.com/linux/myp/ConvexPolRas/ConvexPolRas.html
     38            Computer Graphics, Principles and Practice, Foley, van Dam, Feiner, Hughes (pp 92)
     39            Michael Abrash's Graphics Programming Black Book, Special Edition (Chapter 38 and 39)
     40          
     41            Optimized for embedded systems
     42            - static memory usage only
     43            - consistent data types
     44            - low flash ROM consumption
     45            
     46          */
     47          
     48          
     49          #include "u8g.h"
     50          
     51          
     52          
     53          
     54          /*===========================================*/
     55          /* procedures, which should not be inlined (save as much flash ROM as possible */
     56          
     57          static uint8_t pge_Next(struct pg_edge_struct *pge) PG_NOINLINE;
     58          static uint8_t pg_inc(pg_struct *pg, uint8_t i) PG_NOINLINE;
     59          static uint8_t pg_dec(pg_struct *pg, uint8_t i) PG_NOINLINE;
     60          static void pg_expand_min_y(pg_struct *pg, pg_word_t min_y, uint8_t pge_idx) PG_NOINLINE;
     61          static void pg_line_init(pg_struct * const pg, uint8_t pge_index) PG_NOINLINE;
     62          
     63          /*===========================================*/
     64          /* line draw algorithm */
     65          

   \                                 In section .text, align 2, keep-with-next
     66          static uint8_t pge_Next(struct pg_edge_struct *pge)
     67          {
     68            if ( pge->current_y >= pge->max_y )
   \                     pge_Next: (+1)
   \   00000000   0xF9B0 0x1008      LDRSH    R1,[R0, #+8]
   \   00000004   0xF9B0 0x200A      LDRSH    R2,[R0, #+10]
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xDB01             BLT.N    ??pge_Next_0
     69              return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR
     70            
     71            pge->current_x += pge->current_x_offset;
   \                     ??pge_Next_0: (+1)
   \   00000010   0x8982             LDRH     R2,[R0, #+12]
   \   00000012   0x8881             LDRH     R1,[R0, #+4]
   \   00000014   0x188A             ADDS     R2,R1,R2
   \   00000016   0x8182             STRH     R2,[R0, #+12]
     72            pge->error += pge->error_offset;
   \   00000018   0x89C2             LDRH     R2,[R0, #+14]
   \   0000001A   0x88C1             LDRH     R1,[R0, #+6]
   \   0000001C   0x188A             ADDS     R2,R1,R2
   \   0000001E   0x81C2             STRH     R2,[R0, #+14]
     73            if ( pge->error > 0 )
   \   00000020   0xB212             SXTH     R2,R2
   \   00000022   0x2A01             CMP      R2,#+1
   \   00000024   0xDB07             BLT.N    ??pge_Next_1
     74            {
     75              pge->current_x += pge->x_direction;
   \   00000026   0x8982             LDRH     R2,[R0, #+12]
   \   00000028   0x8801             LDRH     R1,[R0, #+0]
   \   0000002A   0x188A             ADDS     R2,R1,R2
   \   0000002C   0x8182             STRH     R2,[R0, #+12]
     76              pge->error -= pge->height;
   \   0000002E   0x89C2             LDRH     R2,[R0, #+14]
   \   00000030   0x8841             LDRH     R1,[R0, #+2]
   \   00000032   0x1A52             SUBS     R2,R2,R1
   \   00000034   0x81C2             STRH     R2,[R0, #+14]
     77            }  
     78            
     79            pge->current_y++;
   \                     ??pge_Next_1: (+1)
   \   00000036   0x8901             LDRH     R1,[R0, #+8]
   \   00000038   0x1C49             ADDS     R1,R1,#+1
   \   0000003A   0x8101             STRH     R1,[R0, #+8]
     80            return 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x4770             BX       LR               ;; return
     81          }
     82          
     83          /* assumes y2 > y1 */

   \                                 In section .text, align 2, keep-with-next
     84          static void pge_Init(struct pg_edge_struct *pge, pg_word_t x1, pg_word_t y1, pg_word_t x2, pg_word_t y2)
     85          {
   \                     pge_Init: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0xF9BD 0x4008      LDRSH    R4,[SP, #+8]
     86            pg_word_t dx = x2 - x1;
   \   00000006   0x1A5B             SUBS     R3,R3,R1
   \   00000008   0xB21B             SXTH     R3,R3
     87            pg_word_t width;
     88          
     89            pge->height = y2 - y1;
   \   0000000A   0x1AA5             SUBS     R5,R4,R2
   \   0000000C   0x8045             STRH     R5,[R0, #+2]
     90            pge->max_y = y2;
   \   0000000E   0x8144             STRH     R4,[R0, #+10]
     91            pge->current_y = y1;
   \   00000010   0x8102             STRH     R2,[R0, #+8]
     92            pge->current_x = x1;
   \   00000012   0x8181             STRH     R1,[R0, #+12]
     93          
     94            if ( dx >= 0 )
   \   00000014   0x2B00             CMP      R3,#+0
   \   00000016   0xD405             BMI.N    ??pge_Init_0
     95            {
     96              pge->x_direction = 1;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x8001             STRH     R1,[R0, #+0]
     97              width = dx;
   \   0000001C   0x4619             MOV      R1,R3
     98              pge->error = 0;
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x81C2             STRH     R2,[R0, #+14]
   \   00000022   0xE007             B.N      ??pge_Init_1
     99            }
    100            else
    101            {
    102              pge->x_direction = -1;
   \                     ??pge_Init_0: (+1)
   \   00000024   0xF04F 0x31FF      MOV      R1,#-1
   \   00000028   0x8001             STRH     R1,[R0, #+0]
    103              width = -dx;
   \   0000002A   0x4259             RSBS     R1,R3,#+0
    104              pge->error = 1 - pge->height;
   \   0000002C   0x8842             LDRH     R2,[R0, #+2]
   \   0000002E   0xF1C2 0x0201      RSB      R2,R2,#+1
   \   00000032   0x81C2             STRH     R2,[R0, #+14]
    105            }
    106            
    107            pge->current_x_offset = dx / pge->height;
   \                     ??pge_Init_1: (+1)
   \   00000034   0xF9B0 0x2002      LDRSH    R2,[R0, #+2]
   \   00000038   0xFB93 0xF2F2      SDIV     R2,R3,R2
   \   0000003C   0x8082             STRH     R2,[R0, #+4]
    108            pge->error_offset = width % pge->height;
   \   0000003E   0xB209             SXTH     R1,R1
   \   00000040   0xF9B0 0x2002      LDRSH    R2,[R0, #+2]
   \   00000044   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   00000048   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \   0000004C   0x80C1             STRH     R1,[R0, #+6]
    109          }
   \   0000004E   0xBC30             POP      {R4,R5}
   \   00000050   0x4770             BX       LR               ;; return
    110          
    111          /*===========================================*/
    112          /* convex polygon algorithm */
    113          

   \                                 In section .text, align 2, keep-with-next
    114          static uint8_t pg_inc(pg_struct *pg, uint8_t i)
    115          {
    116              i++;
   \                     pg_inc: (+1)
   \   00000000   0x1C49             ADDS     R1,R1,#+1
    117              if ( i >= pg->cnt )
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x7E00             LDRB     R0,[R0, #+24]
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x4282             CMP      R2,R0
   \   0000000A   0xD300             BCC.N    ??pg_inc_0
    118                i = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
    119              return i;
   \                     ??pg_inc_0: (+1)
   \   0000000E   0x4608             MOV      R0,R1
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x4770             BX       LR               ;; return
    120          }
    121          

   \                                 In section .text, align 2, keep-with-next
    122          static uint8_t pg_dec(pg_struct *pg, uint8_t i)
    123          {
   \                     pg_dec: (+1)
   \   00000000   0x4602             MOV      R2,R0
    124              i--;
   \   00000002   0x1E48             SUBS     R0,R1,#+1
    125              if ( i >= pg->cnt )
   \   00000004   0x7E11             LDRB     R1,[R2, #+24]
   \   00000006   0x4602             MOV      R2,R0
   \   00000008   0x460B             MOV      R3,R1
   \   0000000A   0xB2D2             UXTB     R2,R2
   \   0000000C   0x429A             CMP      R2,R3
   \   0000000E   0xD300             BCC.N    ??pg_dec_0
    126                i = pg->cnt-1;
   \   00000010   0x1E48             SUBS     R0,R1,#+1
    127              return i;
   \                     ??pg_dec_0: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x4770             BX       LR               ;; return
    128          }
    129          

   \                                 In section .text, align 2, keep-with-next
    130          static void pg_expand_min_y(pg_struct *pg, pg_word_t min_y, uint8_t pge_idx)
    131          {
   \                     pg_expand_min_y: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    132            uint8_t i = pg->pge[pge_idx].curr_idx;
   \   00000006   0xEB02 0x0042      ADD      R0,R2,R2, LSL #+1
   \   0000000A   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   0000000E   0xF100 0x062C      ADD      R6,R0,#+44
   \   00000012   0x7930             LDRB     R0,[R6, #+4]
   \   00000014   0xE000             B.N      ??pg_expand_min_y_0
    133            for(;;)
    134            {
    135              i = pg->pge[pge_idx].next_idx_fn(pg, i);
    136              if ( pg->list[i].y != min_y )
    137                break;	
    138              pg->pge[pge_idx].curr_idx = i;
   \                     ??pg_expand_min_y_1: (+1)
   \   00000016   0x7130             STRB     R0,[R6, #+4]
   \                     ??pg_expand_min_y_0: (+1)
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x6832             LDR      R2,[R6, #+0]
   \   0000001E   0x4790             BLX      R2
   \   00000020   0x4601             MOV      R1,R0
   \   00000022   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \   00000026   0xF9B1 0x1002      LDRSH    R1,[R1, #+2]
   \   0000002A   0x462A             MOV      R2,R5
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD0F2             BEQ.N    ??pg_expand_min_y_1
    139            }
    140          }
   \   00000030   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    141          

   \                                 In section .text, align 2, keep-with-next
    142          static uint8_t pg_prepare(pg_struct *pg)
    143          {
   \                     pg_prepare: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    144            pg_word_t max_y;
    145            pg_word_t min_y;
    146            uint8_t i;
    147          
    148            /* setup the next index procedures */
    149            pg->pge[PG_RIGHT].next_idx_fn = pg_inc;
   \   00000004   0xF104 0x0530      ADD      R5,R4,#+48
   \   00000008   0x....             LDR.N    R0,??DataTable4
   \   0000000A   0x6168             STR      R0,[R5, #+20]
    150            pg->pge[PG_LEFT].next_idx_fn = pg_dec;
   \   0000000C   0x....             LDR.N    R0,??DataTable4_1
   \   0000000E   0x62E0             STR      R0,[R4, #+44]
    151            
    152            /* search for highest and lowest point */
    153            max_y = pg->list[0].y;
   \   00000010   0xF9B4 0x0002      LDRSH    R0,[R4, #+2]
    154            min_y = pg->list[0].y;
   \   00000014   0x4606             MOV      R6,R0
    155            pg->pge[PG_LEFT].curr_idx = 0;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x7029             STRB     R1,[R5, #+0]
    156            for( i = 1; i < pg->cnt; i++ )
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0xE010             B.N      ??pg_prepare_0
    157            {
    158              if ( max_y < pg->list[i].y )
   \                     ??pg_prepare_1: (+1)
   \   0000001E   0xEB04 0x0281      ADD      R2,R4,R1, LSL #+2
   \   00000022   0xF9B2 0x3002      LDRSH    R3,[R2, #+2]
   \   00000026   0x4607             MOV      R7,R0
   \   00000028   0x469C             MOV      R12,R3
   \   0000002A   0x4567             CMP      R7,R12
   \   0000002C   0xDA00             BGE.N    ??pg_prepare_2
    159              {
    160                max_y = pg->list[i].y;
   \   0000002E   0x4618             MOV      R0,R3
    161              }
    162              if ( min_y > pg->list[i].y )
   \                     ??pg_prepare_2: (+1)
   \   00000030   0x4637             MOV      R7,R6
   \   00000032   0x42BB             CMP      R3,R7
   \   00000034   0xDA02             BGE.N    ??pg_prepare_3
    163              {
    164                pg->pge[PG_LEFT].curr_idx = i;
   \   00000036   0x7029             STRB     R1,[R5, #+0]
    165                min_y = pg->list[i].y;
   \   00000038   0xF9B2 0x6002      LDRSH    R6,[R2, #+2]
    166              }
    167            }
   \                     ??pg_prepare_3: (+1)
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
   \   0000003E   0xB2C9             UXTB     R1,R1
   \                     ??pg_prepare_0: (+1)
   \   00000040   0x7E22             LDRB     R2,[R4, #+24]
   \   00000042   0x4291             CMP      R1,R2
   \   00000044   0xDBEB             BLT.N    ??pg_prepare_1
    168          
    169            /* calculate total number of scan lines */
    170            pg->total_scan_line_cnt = max_y;
   \   00000046   0x8360             STRH     R0,[R4, #+26]
    171            pg->total_scan_line_cnt -= min_y;
   \   00000048   0x8B60             LDRH     R0,[R4, #+26]
   \   0000004A   0x1B80             SUBS     R0,R0,R6
   \   0000004C   0x8360             STRH     R0,[R4, #+26]
    172            
    173            /* exit if polygon height is zero */
    174            if ( pg->total_scan_line_cnt == 0 )
   \   0000004E   0xB200             SXTH     R0,R0
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD01F             BEQ.N    ??pg_prepare_4
    175              return 0;
    176            
    177            /* if the minimum y side is flat, try to find the lowest and highest x points */
    178            pg->pge[PG_RIGHT].curr_idx = pg->pge[PG_LEFT].curr_idx;  
   \   00000054   0x7828             LDRB     R0,[R5, #+0]
   \   00000056   0x7628             STRB     R0,[R5, #+24]
    179            pg_expand_min_y(pg, min_y, PG_RIGHT);
   \   00000058   0x2201             MOVS     R2,#+1
   \   0000005A   0x4631             MOV      R1,R6
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       pg_expand_min_y
    180            pg_expand_min_y(pg, min_y, PG_LEFT);
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0x4631             MOV      R1,R6
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       pg_expand_min_y
    181            
    182            /* check if the min side is really flat (depends on the x values) */
    183            pg->is_min_y_not_flat = 1;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x7660             STRB     R0,[R4, #+25]
    184            if ( pg->list[pg->pge[PG_LEFT].curr_idx].x != pg->list[pg->pge[PG_RIGHT].curr_idx].x )
   \   00000070   0x7828             LDRB     R0,[R5, #+0]
   \   00000072   0xF934 0x0020      LDRSH    R0,[R4, R0, LSL #+2]
   \   00000076   0x7E29             LDRB     R1,[R5, #+24]
   \   00000078   0xF934 0x1021      LDRSH    R1,[R4, R1, LSL #+2]
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD003             BEQ.N    ??pg_prepare_5
    185            {
    186              pg->is_min_y_not_flat = 0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x7660             STRB     R0,[R4, #+25]
    187            }
    188            else
    189            {
    190              pg->total_scan_line_cnt--;
    191              if ( pg->total_scan_line_cnt == 0 )
    192                return 0;
    193            }
    194          
    195            return 1;
   \                     ??pg_prepare_6: (+1)
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??pg_prepare_5: (+1)
   \   00000088   0x8B60             LDRH     R0,[R4, #+26]
   \   0000008A   0x1E40             SUBS     R0,R0,#+1
   \   0000008C   0x8360             STRH     R0,[R4, #+26]
   \   0000008E   0xB200             SXTH     R0,R0
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD1F7             BNE.N    ??pg_prepare_6
   \                     ??pg_prepare_4: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBDF2             POP      {R1,R4-R7,PC}
    196          }
    197          

   \                                 In section .text, align 2, keep-with-next
    198          static void pg_hline(pg_struct *pg, u8g_t *u8g)
    199          {
   \                     pg_hline: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x460C             MOV      R4,R1
    200            pg_word_t x1, x2, y;
    201            x1 = pg->pge[PG_LEFT].current_x;
   \   00000004   0xF9B0 0x1028      LDRSH    R1,[R0, #+40]
    202            x2 = pg->pge[PG_RIGHT].current_x;
   \   00000008   0xF9B0 0x5040      LDRSH    R5,[R0, #+64]
    203            y = pg->pge[PG_RIGHT].current_y;
   \   0000000C   0xF9B0 0x003C      LDRSH    R0,[R0, #+60]
    204            
    205            if ( y < 0 )
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD42F             BMI.N    ??pg_hline_0
    206              return;
    207            if ( y >= u8g_GetHeight(u8g) )
   \   00000014   0x7862             LDRB     R2,[R4, #+1]
   \   00000016   0x4290             CMP      R0,R2
   \   00000018   0xDA2C             BGE.N    ??pg_hline_0
    208              return;
    209            if ( x1 < x2 )
   \   0000001A   0x42A9             CMP      R1,R5
   \   0000001C   0xDA14             BGE.N    ??pg_hline_1
    210            {
    211              if ( x2 < 0 )
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD428             BMI.N    ??pg_hline_0
    212                return;
    213              if ( x1 >= u8g_GetWidth(u8g) )
   \   00000022   0x7822             LDRB     R2,[R4, #+0]
   \   00000024   0x4291             CMP      R1,R2
   \   00000026   0xDA25             BGE.N    ??pg_hline_0
    214                return;
    215              if ( x1 < 0 )
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD500             BPL.N    ??pg_hline_2
    216                x1 = 0;
   \   0000002C   0x2100             MOVS     R1,#+0
    217              if ( x2 >= u8g_GetWidth(u8g) )
   \                     ??pg_hline_2: (+1)
   \   0000002E   0x4295             CMP      R5,R2
   \   00000030   0xDB00             BLT.N    ??pg_hline_3
    218                x2 = u8g_GetWidth(u8g);
   \   00000032   0x4615             MOV      R5,R2
    219              u8g_DrawHLine(u8g, x1, y, x2 - x1);
   \                     ??pg_hline_3: (+1)
   \   00000034   0x1A6D             SUBS     R5,R5,R1
   \   00000036   0x462B             MOV      R3,R5
   \   00000038   0xB2DB             UXTB     R3,R3
   \   0000003A   0x4602             MOV      R2,R0
   \   0000003C   0xB2D2             UXTB     R2,R2
   \   0000003E   0xB2C9             UXTB     R1,R1
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0xBC30             POP      {R4,R5}
   \   00000044   0x.... 0x....      B.W      u8g_DrawHLine
    220            }
    221            else
    222            {
    223              if ( x1 < 0 )
   \                     ??pg_hline_1: (+1)
   \   00000048   0x2900             CMP      R1,#+0
   \   0000004A   0xD413             BMI.N    ??pg_hline_0
    224                return;
    225              if ( x2 >= u8g_GetWidth(u8g) )
   \   0000004C   0x7822             LDRB     R2,[R4, #+0]
   \   0000004E   0x4295             CMP      R5,R2
   \   00000050   0xDA10             BGE.N    ??pg_hline_0
    226                return;
    227              if ( x2 < 0 )
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD500             BPL.N    ??pg_hline_4
    228                x1 = 0;
   \   00000056   0x2100             MOVS     R1,#+0
    229              if ( x1 >= u8g_GetWidth(u8g) )
   \                     ??pg_hline_4: (+1)
   \   00000058   0x4291             CMP      R1,R2
   \   0000005A   0xDB00             BLT.N    ??pg_hline_5
    230                x1 = u8g_GetWidth(u8g);
   \   0000005C   0x4611             MOV      R1,R2
    231              u8g_DrawHLine(u8g, x2, y, x1 - x2);
   \                     ??pg_hline_5: (+1)
   \   0000005E   0x1B49             SUBS     R1,R1,R5
   \   00000060   0x460B             MOV      R3,R1
   \   00000062   0xB2DB             UXTB     R3,R3
   \   00000064   0x4602             MOV      R2,R0
   \   00000066   0xB2D2             UXTB     R2,R2
   \   00000068   0x4629             MOV      R1,R5
   \   0000006A   0xB2C9             UXTB     R1,R1
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0xBC30             POP      {R4,R5}
   \   00000070   0x.... 0x....      B.W      u8g_DrawHLine
    232            }
    233          }
   \                     ??pg_hline_0: (+1)
   \   00000074   0xBC30             POP      {R4,R5}
   \   00000076   0x4770             BX       LR               ;; return
    234          

   \                                 In section .text, align 2, keep-with-next
    235          static void pg_line_init(pg_struct * pg, uint8_t pge_index)
    236          {
   \                     pg_line_init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    237            struct pg_edge_struct  *pge = pg->pge+pge_index;
   \   00000004   0xEB01 0x0041      ADD      R0,R1,R1, LSL #+1
   \   00000008   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   0000000C   0xF100 0x051C      ADD      R5,R0,#+28
    238            uint8_t idx;  
    239            pg_word_t x1;
    240            pg_word_t y1;
    241            pg_word_t x2;
    242            pg_word_t y2;
    243          
    244            idx = pge->curr_idx;  
   \   00000010   0x7D29             LDRB     R1,[R5, #+20]
    245            y1 = pg->list[idx].y;
   \   00000012   0x1CA0             ADDS     R0,R4,#+2
   \   00000014   0xF930 0x6021      LDRSH    R6,[R0, R1, LSL #+2]
    246            x1 = pg->list[idx].x;
   \   00000018   0xF934 0x7021      LDRSH    R7,[R4, R1, LSL #+2]
    247            idx = pge->next_idx_fn(pg, idx);
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x692A             LDR      R2,[R5, #+16]
   \   00000020   0x4790             BLX      R2
    248            y2 = pg->list[idx].y;
   \   00000022   0x1CA1             ADDS     R1,R4,#+2
   \   00000024   0xF931 0x1020      LDRSH    R1,[R1, R0, LSL #+2]
    249            x2 = pg->list[idx].x; 
   \   00000028   0xF934 0x3020      LDRSH    R3,[R4, R0, LSL #+2]
    250            pge->curr_idx = idx;
   \   0000002C   0x7528             STRB     R0,[R5, #+20]
    251            
    252            pge_Init(pge, x1, y1, x2, y2);
   \   0000002E   0x9100             STR      R1,[SP, #+0]
   \   00000030   0x4632             MOV      R2,R6
   \   00000032   0x4639             MOV      R1,R7
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       pge_Init
    253          }
   \   0000003A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    254          

   \                                 In section .text, align 2, keep-with-next
    255          static void pg_exec(pg_struct *pg, u8g_t *u8g)
    256          {
   \                     pg_exec: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    257            pg_word_t i = pg->total_scan_line_cnt;
   \   00000006   0xF9B4 0x601A      LDRSH    R6,[R4, #+26]
    258          
    259            /* first line is skipped if the min y line is not flat */
    260            pg_line_init(pg, PG_LEFT);		
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      BL       pg_line_init
    261            pg_line_init(pg, PG_RIGHT);
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       pg_line_init
    262            
    263            if ( pg->is_min_y_not_flat != 0 )
   \   00000018   0x7E60             LDRB     R0,[R4, #+25]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD007             BEQ.N    ??pg_exec_0
    264            {
    265              pge_Next(&(pg->pge[PG_LEFT])); 
   \   0000001E   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000022   0x.... 0x....      BL       pge_Next
    266              pge_Next(&(pg->pge[PG_RIGHT]));
   \   00000026   0xF104 0x0034      ADD      R0,R4,#+52
   \   0000002A   0x.... 0x....      BL       pge_Next
    267            }
    268          
    269            do
    270            {
    271              pg_hline(pg, u8g);
   \                     ??pg_exec_0: (+1)
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       pg_hline
   \   00000036   0xE003             B.N      ??pg_exec_1
    272              while ( pge_Next(&(pg->pge[PG_LEFT])) == 0 )
    273              {
    274                pg_line_init(pg, PG_LEFT);
   \                     ??pg_exec_2: (+1)
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       pg_line_init
    275              }
   \                     ??pg_exec_1: (+1)
   \   00000040   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000044   0x.... 0x....      BL       pge_Next
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD0F5             BEQ.N    ??pg_exec_2
    276              while ( pge_Next(&(pg->pge[PG_RIGHT])) == 0 )
   \                     ??pg_exec_3: (+1)
   \   0000004C   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000050   0x.... 0x....      BL       pge_Next
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD104             BNE.N    ??pg_exec_4
    277              {
    278                pg_line_init(pg, PG_RIGHT);
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       pg_line_init
   \   00000060   0xE7F4             B.N      ??pg_exec_3
    279              }
    280              i--;
   \                     ??pg_exec_4: (+1)
   \   00000062   0x1E76             SUBS     R6,R6,#+1
    281            } while( i > 0 );
   \   00000064   0x4630             MOV      R0,R6
   \   00000066   0xB200             SXTH     R0,R0
   \   00000068   0x2801             CMP      R0,#+1
   \   0000006A   0xDAE0             BGE.N    ??pg_exec_0
    282          }
   \   0000006C   0xBD70             POP      {R4-R6,PC}       ;; return
    283          
    284          /*===========================================*/
    285          /* API procedures */
    286          

   \                                 In section .text, align 2, keep-with-next
    287          void pg_ClearPolygonXY(pg_struct *pg)
    288          {
    289            pg->cnt = 0;
   \                     pg_ClearPolygonXY: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7601             STRB     R1,[R0, #+24]
    290          }
   \   00000004   0x4770             BX       LR               ;; return
    291          

   \                                 In section .text, align 2, keep-with-next
    292          void pg_AddPolygonXY(pg_struct *pg, u8g_t *u8g, int16_t x, int16_t y)
    293          {
    294            if ( pg->cnt < PG_MAX_POINTS )
   \                     pg_AddPolygonXY: (+1)
   \   00000000   0x7E01             LDRB     R1,[R0, #+24]
   \   00000002   0x2906             CMP      R1,#+6
   \   00000004   0xDA08             BGE.N    ??pg_AddPolygonXY_0
    295            {
    296              pg->list[pg->cnt].x = x;
   \   00000006   0xF820 0x2021      STRH     R2,[R0, R1, LSL #+2]
    297              pg->list[pg->cnt].y = y;
   \   0000000A   0x7E01             LDRB     R1,[R0, #+24]
   \   0000000C   0xEB00 0x0181      ADD      R1,R0,R1, LSL #+2
   \   00000010   0x804B             STRH     R3,[R1, #+2]
    298              pg->cnt++;
   \   00000012   0x7E01             LDRB     R1,[R0, #+24]
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0x7601             STRB     R1,[R0, #+24]
    299            }
    300          }
   \                     ??pg_AddPolygonXY_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    301          

   \                                 In section .text, align 2, keep-with-next
    302          void pg_DrawPolygon(pg_struct *pg, u8g_t *u8g)
    303          {
   \                     pg_DrawPolygon: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    304            if ( pg_prepare(pg) == 0 )
   \   00000006   0x.... 0x....      BL       pg_prepare
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ.N    ??pg_DrawPolygon_0
    305              return;
    306            pg_exec(pg, u8g);
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000016   0x....             B.N      pg_exec
   \                     ??pg_DrawPolygon_0: (+1)
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    307          }
    308          

   \                                 In section .bss, align 4
    309          pg_struct u8g_pg;
   \                     u8g_pg:
   \   00000000                      DS8 76
    310          

   \                                 In section .text, align 2, keep-with-next
    311          void u8g_ClearPolygonXY(void)
    312          {
    313            pg_ClearPolygonXY(&u8g_pg);
   \                     u8g_ClearPolygonXY: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_2
   \   00000002   0x....             B.N      pg_ClearPolygonXY
    314          }
    315          

   \                                 In section .text, align 2, keep-with-next
    316          void u8g_AddPolygonXY(u8g_t *u8g, int16_t x, int16_t y)
    317          {
   \                     u8g_AddPolygonXY: (+1)
   \   00000000   0x4613             MOV      R3,R2
    318            pg_AddPolygonXY(&u8g_pg, u8g, x, y);
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x....             LDR.N    R0,??DataTable4_2
   \   00000008   0x....             B.N      pg_AddPolygonXY
    319          }
    320          

   \                                 In section .text, align 2, keep-with-next
    321          void u8g_DrawPolygon(u8g_t *u8g)
    322          {
   \                     u8g_DrawPolygon: (+1)
   \   00000000   0x4601             MOV      R1,R0
    323            pg_DrawPolygon(&u8g_pg, u8g);
   \   00000002   0x....             LDR.N    R0,??DataTable4_2
   \   00000004   0x....             B.N      pg_DrawPolygon
    324          }
    325          

   \                                 In section .text, align 2, keep-with-next
    326          void u8g_DrawTriangle(u8g_t *u8g, int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2)
    327          {
   \                     u8g_DrawTriangle: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   \   0000000C   0xF9BD 0x8020      LDRSH    R8,[SP, #+32]
   \   00000010   0xF9BD 0x9024      LDRSH    R9,[SP, #+36]
   \   00000014   0xF9BD 0xA028      LDRSH    R10,[SP, #+40]
    328            u8g_ClearPolygonXY();
   \   00000018   0x.... 0x....      BL       u8g_ClearPolygonXY
    329            u8g_AddPolygonXY(u8g, x0, y0);
   \   0000001C   0x4632             MOV      R2,R6
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       u8g_AddPolygonXY
    330            u8g_AddPolygonXY(u8g, x1, y1);
   \   00000026   0x4642             MOV      R2,R8
   \   00000028   0x4639             MOV      R1,R7
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       u8g_AddPolygonXY
    331            u8g_AddPolygonXY(u8g, x2, y2);
   \   00000030   0x4652             MOV      R2,R10
   \   00000032   0x4649             MOV      R1,R9
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       u8g_AddPolygonXY
    332            u8g_DrawPolygon(u8g);
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   00000040   0x....             B.N      u8g_DrawPolygon
    333          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     pg_inc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     pg_dec

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     u8g_pg
    334          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   pg_AddPolygonXY
       0   pg_ClearPolygonXY
      16   pg_DrawPolygon
         0   -> pg_exec
        16   -> pg_prepare
       0   pg_dec
      16   pg_exec
        16   -> pg_hline
        16   -> pg_line_init
        16   -> pge_Next
      24   pg_expand_min_y
        24   -- Indirect call
       8   pg_hline
         0   -> u8g_DrawHLine
       0   pg_inc
      24   pg_line_init
        24   -- Indirect call
        24   -> pge_Init
      24   pg_prepare
        24   -> pg_expand_min_y
       8   pge_Init
       0   pge_Next
       0   u8g_AddPolygonXY
         0   -> pg_AddPolygonXY
       0   u8g_ClearPolygonXY
         0   -> pg_ClearPolygonXY
       0   u8g_DrawPolygon
         0   -> pg_DrawPolygon
      32   u8g_DrawTriangle
        32   -> u8g_AddPolygonXY
        32   -> u8g_ClearPolygonXY
         0   -> u8g_DrawPolygon


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
      26  pg_AddPolygonXY
       6  pg_ClearPolygonXY
      26  pg_DrawPolygon
      22  pg_dec
     110  pg_exec
      50  pg_expand_min_y
     120  pg_hline
      20  pg_inc
      60  pg_line_init
     152  pg_prepare
      82  pge_Init
      64  pge_Next
      10  u8g_AddPolygonXY
       4  u8g_ClearPolygonXY
       6  u8g_DrawPolygon
      66  u8g_DrawTriangle
      76  u8g_pg

 
  76 bytes in section .bss
 836 bytes in section .text
 
 836 bytes of CODE memory
  76 bytes of DATA memory

Errors: none
Warnings: none
