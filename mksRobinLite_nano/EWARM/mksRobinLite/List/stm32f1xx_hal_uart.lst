###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  22:13:58
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EW170.tmp
#        (F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.c -D
#        USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\stm32f1xx_hal_uart.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\stm32f1xx_hal_uart.o
#
###############################################################################

F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   UART HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Universal Asynchronous Receiver Transmitter (UART) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State and Errors functions  
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18            [..]
     19              The UART HAL driver can be used as follows:
     20              
     21              (#) Declare a UART_HandleTypeDef handle structure.
     22          
     23              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     24                  (##) Enable the USARTx interface clock.
     25                  (##) UART pins configuration:
     26                      (+++) Enable the clock for the UART GPIOs.
     27                       (+++) Configure the USART pins (TX as alternate function pull-up, RX as alternate function Input).
     28                  (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     29                       and HAL_UART_Receive_IT() APIs):
     30                      (+++) Configure the USARTx interrupt priority.
     31                      (+++) Enable the NVIC USART IRQ handle.
     32                  (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     33                       and HAL_UART_Receive_DMA() APIs):
     34                      (+++) Declare a DMA handle structure for the Tx/Rx channel.
     35                      (+++) Enable the DMAx interface clock.
     36                      (+++) Configure the declared DMA handle structure with the required 
     37                            Tx/Rx parameters.                
     38                      (+++) Configure the DMA Tx/Rx channel.
     39                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     40                      (+++) Configure the priority and enable the NVIC for the transfer complete 
     41                            interrupt on the DMA Tx/Rx channel.
     42                      (+++) Configure the USARTx interrupt priority and enable the NVIC USART IRQ handle
     43                            (used for last byte sending completion detection in DMA non circular mode)
     44          
     45              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware 
     46                  flow control and Mode(Receiver/Transmitter) in the huart Init structure.
     47          
     48              (#) For the UART asynchronous mode, initialize the UART registers by calling
     49                  the HAL_UART_Init() API.
     50          
     51              (#) For the UART Half duplex mode, initialize the UART registers by calling 
     52                  the HAL_HalfDuplex_Init() API.
     53          
     54              (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
     55          
     56              (#) For the Multi-Processor mode, initialize the UART registers by calling 
     57                  the HAL_MultiProcessor_Init() API.
     58          
     59               [..] 
     60                 (@) The specific UART interrupts (Transmission complete interrupt, 
     61                      RXNE interrupt and Error Interrupts) will be managed using the macros
     62                      __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit 
     63                      and receive process.
     64          
     65               [..] 
     66                 (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the 
     67                      low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customed 
     68                      HAL_UART_MspInit() API.
     69          
     70               [..] 
     71                  Three operation modes are available within this driver :
     72          
     73               *** Polling mode IO operation ***
     74               =================================
     75               [..]    
     76                 (+) Send an amount of data in blocking mode using HAL_UART_Transmit() 
     77                 (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
     78                 
     79               *** Interrupt mode IO operation ***
     80               ===================================
     81               [..]
     82                 (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT() 
     83                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     84                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     85                 (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT() 
     86                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
     87                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
     88                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
     89                      add his own code by customization of function pointer HAL_UART_ErrorCallback
     90          
     91               *** DMA mode IO operation ***
     92               ==============================
     93               [..] 
     94                 (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA() 
     95                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can 
     96                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback 
     97                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     98                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     99                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA() 
    100                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can 
    101                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback 
    102                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
    103                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    104                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
    105                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    106                 (+) Pause the DMA Transfer using HAL_UART_DMAPause()
    107                 (+) Resume the DMA Transfer using HAL_UART_DMAResume()
    108                 (+) Stop the DMA Transfer using HAL_UART_DMAStop()
    109          
    110               *** UART HAL driver macros list ***
    111               =============================================
    112               [..]
    113                 Below the list of most used macros in UART HAL driver.
    114          
    115                (+) __HAL_UART_ENABLE: Enable the UART peripheral 
    116                (+) __HAL_UART_DISABLE: Disable the UART peripheral
    117                (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
    118                (+) __HAL_UART_CLEAR_FLAG : Clear the specified UART pending flag
    119                (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
    120                (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
    121                (+) __HAL_UART_GET_IT_SOURCE: Check whether the specified UART interrupt has occurred or not
    122          
    123               [..]
    124                 (@) You can refer to the UART HAL driver header file for more useful macros 
    125                
    126            @endverbatim
    127            ******************************************************************************
    128            * @attention
    129            *
    130            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    131            *
    132            * Redistribution and use in source and binary forms, with or without modification,
    133            * are permitted provided that the following conditions are met:
    134            *   1. Redistributions of source code must retain the above copyright notice,
    135            *      this list of conditions and the following disclaimer.
    136            *   2. Redistributions in binary form must reproduce the above copyright notice,
    137            *      this list of conditions and the following disclaimer in the documentation
    138            *      and/or other materials provided with the distribution.
    139            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    140            *      may be used to endorse or promote products derived from this software
    141            *      without specific prior written permission.
    142            *
    143            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    144            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    145            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    146            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    147            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    148            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    149            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    150            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    151            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    152            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    153            *
    154            ******************************************************************************
    155            */
    156          
    157          /* Includes ------------------------------------------------------------------*/
    158          #include "stm32f1xx_hal.h"
    159          
    160          /** @addtogroup STM32F1xx_HAL_Driver
    161            * @{
    162            */
    163          
    164          /** @defgroup UART UART
    165            * @brief HAL UART module driver
    166            * @{
    167            */
    168          #ifdef HAL_UART_MODULE_ENABLED
    169              
    170          /* Private typedef -----------------------------------------------------------*/
    171          /* Private define ------------------------------------------------------------*/
    172          /* Private macros ------------------------------------------------------------*/
    173          /* Private variables ---------------------------------------------------------*/
    174          /* Private function prototypes -----------------------------------------------*/
    175          /** @addtogroup UART_Private_Functions   UART Private Functions
    176            * @{
    177            */
    178          static void UART_SetConfig (UART_HandleTypeDef *huart);
    179          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
    180          static HAL_StatusTypeDef UART_EndTransmit_IT( BspUartDataType *puart);
    181          static HAL_StatusTypeDef UART_Receive_IT(BspUartDataType *puart);
    182          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    183          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    184          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    185          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    186          static void UART_DMAError(DMA_HandleTypeDef *hdma); 
    187          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    188          /**
    189            * @}
    190            */
    191          
    192          /* Exported functions ---------------------------------------------------------*/
    193          
    194          /** @defgroup UART_Exported_Functions UART Exported Functions
    195            * @{
    196            */
    197          
    198          /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions 
    199            *  @brief    Initialization and Configuration functions 
    200            *
    201          @verbatim
    202          ===============================================================================
    203                      ##### Initialization and Configuration functions #####
    204           ===============================================================================  
    205              [..]
    206              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy 
    207              in asynchronous mode.
    208                (+) For the asynchronous mode only these parameters can be configured: 
    209                  (++) Baud Rate
    210                  (++) Word Length 
    211                  (++) Stop Bit
    212                  (++) Parity
    213                  (++) Hardware flow control
    214                  (++) Receiver/transmitter modes
    215              [..]
    216              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs 
    217              follow respectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor
    218              configuration procedures (details for the procedures are available in reference manuals 
    219              (RM0008 for STM32F10Xxx MCUs and RM0041 for STM32F100xx MCUs)).
    220          
    221          
    222          @endverbatim
    223            * @{
    224            */
    225          
    226          /*
    227            Additionnal remark: If the parity is enabled, then the MSB bit of the data written
    228                                in the data register is transmitted but is changed by the parity bit.
    229                                Depending on the frame length defined by the M bit (8-bits or 9-bits),
    230                                the possible UART frame formats are as listed in the following table:
    231              +-------------------------------------------------------------+
    232              |   M bit |  PCE bit  |            UART frame                 |
    233              |---------------------|---------------------------------------|
    234              |    0    |    0      |    | SB | 8 bit data | STB |          |
    235              |---------|-----------|---------------------------------------|
    236              |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    237              |---------|-----------|---------------------------------------|
    238              |    1    |    0      |    | SB | 9 bit data | STB |          |
    239              |---------|-----------|---------------------------------------|
    240              |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    241              +-------------------------------------------------------------+
    242          */
    243          
    244          /**
    245            * @brief  Initializes the UART mode according to the specified parameters in
    246            *         the UART_InitTypeDef and create the associated handle.
    247            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    248            *                the configuration information for the specified UART module.
    249            * @retval HAL status
    250            */

   \                                 In section .text, align 2, keep-with-next
    251          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    252          {
   \                     HAL_UART_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    253            /* Check the UART handle allocation */
    254            if(huart == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_UART_Init_0
    255            {
    256              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    257            }
    258          
    259            /* Check the parameters */
    260            if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
    261            {
    262              /* The hardware flow control is available only for USART1, USART2, USART3 */
    263              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    264              assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
    265            }
    266            else
    267            {
    268              assert_param(IS_UART_INSTANCE(huart->Instance));
    269            }
    270            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    271            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    272            
    273            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_UART_Init_0: (+1)
   \   0000000A   0xF104 0x0538      ADD      R5,R4,#+56
   \   0000000E   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD104             BNE.N    ??HAL_UART_Init_1
    274            {  
    275              /* Allocate lock resource and initialize it */
    276              huart->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7028             STRB     R0,[R5, #+0]
    277              
    278              /* Init the low level hardware */
    279              HAL_UART_MspInit(huart);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_UART_MspInit
    280            }
    281          
    282            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_Init_1: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x7068             STRB     R0,[R5, #+1]
    283          
    284            /* Disable the peripheral */
    285            __HAL_UART_DISABLE(huart);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x68C1             LDR      R1,[R0, #+12]
   \   00000028   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000002C   0x60C1             STR      R1,[R0, #+12]
    286            
    287            /* Set the UART Communication parameters */
    288            UART_SetConfig(huart);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       UART_SetConfig
    289            
    290            /* In asynchronous mode, the following bits must be kept cleared: 
    291               - LINEN and CLKEN bits in the USART_CR2 register,
    292               - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    293            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6901             LDR      R1,[R0, #+16]
   \   00000038   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   0000003C   0x6101             STR      R1,[R0, #+16]
    294            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6941             LDR      R1,[R0, #+20]
   \   00000042   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   00000046   0x6141             STR      R1,[R0, #+20]
    295            
    296            /* Enable the peripheral */
    297            __HAL_UART_ENABLE(huart);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C1             LDR      R1,[R0, #+12]
   \   0000004C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000050   0x60C1             STR      R1,[R0, #+12]
    298            
    299            /* Initialize the UART state */
    300            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6068             STR      R0,[R5, #+4]
    301            huart->State= HAL_UART_STATE_READY;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x7068             STRB     R0,[R5, #+1]
    302            
    303            return HAL_OK;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    304          }
    305          
    306          /**
    307            * @brief  Initializes the half-duplex mode according to the specified
    308            *         parameters in the UART_InitTypeDef and create the associated handle.
    309            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    310            *                the configuration information for the specified UART module.
    311            * @retval HAL status
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    314          {
   \                     HAL_HalfDuplex_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    315            /* Check the UART handle allocation */
    316            if(huart == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_HalfDuplex_Init_0
    317            {
    318              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    319            }
    320            
    321            /* Check UART instance */
    322            assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
    323            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    324            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    325          
    326            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_HalfDuplex_Init_0: (+1)
   \   0000000A   0xF104 0x0538      ADD      R5,R4,#+56
   \   0000000E   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD104             BNE.N    ??HAL_HalfDuplex_Init_1
    327            {   
    328              /* Allocate lock resource and initialize it */
    329              huart->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7028             STRB     R0,[R5, #+0]
    330          
    331              /* Init the low level hardware */
    332              HAL_UART_MspInit(huart);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_UART_MspInit
    333            }
    334          
    335            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_HalfDuplex_Init_1: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x7068             STRB     R0,[R5, #+1]
    336          
    337            /* Disable the peripheral */
    338            __HAL_UART_DISABLE(huart);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x68C1             LDR      R1,[R0, #+12]
   \   00000028   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000002C   0x60C1             STR      R1,[R0, #+12]
    339            
    340            /* Set the UART Communication parameters */
    341            UART_SetConfig(huart);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       UART_SetConfig
    342            
    343            /* In half-duplex mode, the following bits must be kept cleared: 
    344               - LINEN and CLKEN bits in the USART_CR2 register,
    345               - SCEN and IREN bits in the USART_CR3 register.*/
    346            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6901             LDR      R1,[R0, #+16]
   \   00000038   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   0000003C   0x6101             STR      R1,[R0, #+16]
    347            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6941             LDR      R1,[R0, #+20]
   \   00000042   0xF021 0x0122      BIC      R1,R1,#0x22
   \   00000046   0x6141             STR      R1,[R0, #+20]
    348            
    349            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    350            SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6941             LDR      R1,[R0, #+20]
   \   0000004C   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000050   0x6141             STR      R1,[R0, #+20]
    351           
    352            /* Enable the peripheral */
    353            __HAL_UART_ENABLE(huart);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C1             LDR      R1,[R0, #+12]
   \   00000056   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000005A   0x60C1             STR      R1,[R0, #+12]
    354            
    355            /* Initialize the UART state*/
    356            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6068             STR      R0,[R5, #+4]
    357            huart->State= HAL_UART_STATE_READY;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x7068             STRB     R0,[R5, #+1]
    358            
    359            return HAL_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    360          }
    361          
    362          /**
    363            * @brief  Initializes the LIN mode according to the specified
    364            *         parameters in the UART_InitTypeDef and create the associated handle.
    365            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    366            *                the configuration information for the specified UART module.
    367            * @param  BreakDetectLength: Specifies the LIN break detection length.
    368            *         This parameter can be one of the following values:
    369            *            @arg UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection
    370            *            @arg UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection
    371            * @retval HAL status
    372            */

   \                                 In section .text, align 2, keep-with-next
    373          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    374          {
   \                     HAL_LIN_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
    375            /* Check the UART handle allocation */
    376            if(huart == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_LIN_Init_0
    377            {
    378              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD70             POP      {R4-R6,PC}
    379            }
    380            
    381            /* Check the LIN UART instance */  
    382            assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
    383            /* Check the Break detection length parameter */
    384            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    385            assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
    386            assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
    387            
    388            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_LIN_Init_0: (+1)
   \   0000000E   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000012   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD104             BNE.N    ??HAL_LIN_Init_1
    389            {   
    390              /* Allocate lock resource and initialize it */
    391              huart->Lock = HAL_UNLOCKED;  
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x7028             STRB     R0,[R5, #+0]
    392          
    393              /* Init the low level hardware */
    394              HAL_UART_MspInit(huart);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       HAL_UART_MspInit
    395            }
    396          
    397            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_LIN_Init_1: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x7068             STRB     R0,[R5, #+1]
    398          
    399            /* Disable the peripheral */
    400            __HAL_UART_DISABLE(huart);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C1             LDR      R1,[R0, #+12]
   \   0000002C   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000030   0x60C1             STR      R1,[R0, #+12]
    401            
    402            /* Set the UART Communication parameters */
    403            UART_SetConfig(huart);
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       UART_SetConfig
    404            
    405            /* In LIN mode, the following bits must be kept cleared: 
    406               - CLKEN bits in the USART_CR2 register,
    407               - SCEN and IREN bits in the USART_CR3 register.*/
    408            CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6901             LDR      R1,[R0, #+16]
   \   0000003C   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000040   0x6101             STR      R1,[R0, #+16]
    409            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6941             LDR      R1,[R0, #+20]
   \   00000046   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   0000004A   0x6141             STR      R1,[R0, #+20]
    410            
    411            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    412            SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6901             LDR      R1,[R0, #+16]
   \   00000050   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000054   0x6101             STR      R1,[R0, #+16]
    413            
    414            /* Set the USART LIN Break detection length. */
    415            MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6901             LDR      R1,[R0, #+16]
   \   0000005A   0xF021 0x0120      BIC      R1,R1,#0x20
   \   0000005E   0x430E             ORRS     R6,R6,R1
   \   00000060   0x6106             STR      R6,[R0, #+16]
    416            
    417            /* Enable the peripheral */
    418            __HAL_UART_ENABLE(huart);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x68C1             LDR      R1,[R0, #+12]
   \   00000066   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000006A   0x60C1             STR      R1,[R0, #+12]
    419            
    420            /* Initialize the UART state*/
    421            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x6068             STR      R0,[R5, #+4]
    422            huart->State= HAL_UART_STATE_READY;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x7068             STRB     R0,[R5, #+1]
    423            
    424            return HAL_OK;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return
    425          }
    426          
    427          /**
    428            * @brief  Initializes the Multi-Processor mode according to the specified
    429            *         parameters in the UART_InitTypeDef and create the associated handle.
    430            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    431            *                the configuration information for the specified UART module.
    432            * @param  Address: UART node address
    433            * @param  WakeUpMethod: specifies the UART wakeup method.
    434            *         This parameter can be one of the following values:
    435            *            @arg UART_WAKEUPMETHOD_IDLELINE: Wakeup by an idle line detection
    436            *            @arg UART_WAKEUPMETHOD_ADDRESSMARK: Wakeup by an address mark
    437            * @retval HAL status
    438            */

   \                                 In section .text, align 2, keep-with-next
    439          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    440          {
   \                     HAL_MultiProcessor_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
    441            /* Check the UART handle allocation */
    442            if(huart == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_MultiProcessor_Init_0
    443            {
    444              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBDF2             POP      {R1,R4-R7,PC}
    445            }
    446          
    447            /* Check UART instance capabilities */  
    448            assert_param(IS_UART_MULTIPROCESSOR_INSTANCE(huart->Instance));
    449          
    450            /* Check the Address & wake up method parameters */
    451            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    452            assert_param(IS_UART_ADDRESS(Address));
    453            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    454            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    455          
    456            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_MultiProcessor_Init_0: (+1)
   \   00000010   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000014   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD104             BNE.N    ??HAL_MultiProcessor_Init_1
    457            {   
    458              /* Allocate lock resource and initialize it */
    459              huart->Lock = HAL_UNLOCKED;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x7028             STRB     R0,[R5, #+0]
    460          
    461              /* Init the low level hardware */
    462              HAL_UART_MspInit(huart);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       HAL_UART_MspInit
    463            }
    464          
    465            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessor_Init_1: (+1)
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x7068             STRB     R0,[R5, #+1]
    466          
    467            /* Disable the peripheral */
    468            __HAL_UART_DISABLE(huart);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x68C1             LDR      R1,[R0, #+12]
   \   0000002E   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000032   0x60C1             STR      R1,[R0, #+12]
    469            
    470            /* Set the UART Communication parameters */
    471            UART_SetConfig(huart);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       UART_SetConfig
    472            
    473            /* In Multi-Processor mode, the following bits must be kept cleared: 
    474               - LINEN and CLKEN bits in the USART_CR2 register,
    475               - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
    476            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6901             LDR      R1,[R0, #+16]
   \   0000003E   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   00000042   0x6101             STR      R1,[R0, #+16]
    477            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6941             LDR      R1,[R0, #+20]
   \   00000048   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   0000004C   0x6141             STR      R1,[R0, #+20]
    478            
    479            /* Set the USART address node */
    480            MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6901             LDR      R1,[R0, #+16]
   \   00000052   0x0909             LSRS     R1,R1,#+4
   \   00000054   0xEA56 0x1601      ORRS     R6,R6,R1, LSL #+4
   \   00000058   0x6106             STR      R6,[R0, #+16]
    481            
    482            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    483            MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x68C1             LDR      R1,[R0, #+12]
   \   0000005E   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000062   0x430F             ORRS     R7,R7,R1
   \   00000064   0x60C7             STR      R7,[R0, #+12]
    484            
    485            /* Enable the peripheral */
    486            __HAL_UART_ENABLE(huart);
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x68C1             LDR      R1,[R0, #+12]
   \   0000006A   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000006E   0x60C1             STR      R1,[R0, #+12]
    487            
    488            /* Initialize the UART state */
    489            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x6068             STR      R0,[R5, #+4]
    490            huart->State= HAL_UART_STATE_READY;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x7068             STRB     R0,[R5, #+1]
    491            
    492            return HAL_OK;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    493          }
    494          
    495          /**
    496            * @brief  DeInitializes the UART peripheral. 
    497            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    498            *                the configuration information for the specified UART module.
    499            * @retval HAL status
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    502          {
   \                     HAL_UART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    503            /* Check the UART handle allocation */
    504            if(huart == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_UART_DeInit_0
    505            {
    506              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    507            }
    508            
    509            /* Check the parameters */
    510            assert_param(IS_UART_INSTANCE(huart->Instance));
    511          
    512            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_DeInit_0: (+1)
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xF884 0x0039      STRB     R0,[R4, #+57]
    513            
    514            /* Disable the Peripheral */
    515            __HAL_UART_DISABLE(huart);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x68C1             LDR      R1,[R0, #+12]
   \   00000014   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000018   0x60C1             STR      R1,[R0, #+12]
    516            
    517            huart->Instance->CR1 = 0x0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x60C8             STR      R0,[R1, #+12]
    518            huart->Instance->CR2 = 0x0;
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x6108             STR      R0,[R1, #+16]
    519            huart->Instance->CR3 = 0x0;
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6148             STR      R0,[R1, #+20]
    520            
    521            /* DeInit the low level hardware */
    522            HAL_UART_MspDeInit(huart);
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_UART_MspDeInit
    523          
    524            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x63E0             STR      R0,[R4, #+60]
    525            huart->State = HAL_UART_STATE_RESET;
   \   00000032   0xF884 0x0039      STRB     R0,[R4, #+57]
    526          
    527            /* Process Unlock */
    528            __HAL_UNLOCK(huart);
    529          
    530            return HAL_OK;
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    531          }
    532          
    533          /**
    534            * @brief  UART MSP Init.
    535            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    536            *                the configuration information for the specified UART module.
    537            * @retval None
    538            */

   \                                 In section .text, align 2
    539           __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    540          {
    541            /* Prevent unused argument(s) compilation warning */
    542            UNUSED(huart);
    543            /* NOTE: This function should not be modified, when the callback is needed,
    544                     the HAL_UART_MspInit can be implemented in the user file
    545             */ 
    546          }
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    547          
    548          /**
    549            * @brief  UART MSP DeInit.
    550            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    551            *                the configuration information for the specified UART module.
    552            * @retval None
    553            */

   \                                 In section .text, align 2
    554           __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    555          {
    556            /* Prevent unused argument(s) compilation warning */
    557            UNUSED(huart);
    558            /* NOTE: This function should not be modified, when the callback is needed,
    559                     the HAL_UART_MspDeInit can be implemented in the user file
    560             */ 
    561          }
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    562          
    563          /**
    564            * @}
    565            */
    566          
    567          /** @defgroup UART_Exported_Functions_Group2 IO operation functions 
    568            *  @brief UART Transmit and Receive functions 
    569            *
    570          @verbatim
    571            ==============================================================================
    572                                ##### IO operation functions #####
    573            ==============================================================================  
    574            [..]
    575              This subsection provides a set of functions allowing to manage the UART asynchronous
    576              and Half duplex data transfers.
    577          
    578              (#) There are two modes of transfer:
    579                 (++) Blocking mode: The communication is performed in polling mode. 
    580                      The HAL status of all data processing is returned by the same function 
    581                      after finishing transfer.  
    582                 (++) Non blocking mode: The communication is performed using Interrupts 
    583                      or DMA, these APIs return the HAL status.
    584                      The end of the data processing will be indicated through the 
    585                      dedicated UART IRQ when using Interrupt mode or the DMA IRQ when 
    586                      using DMA mode.
    587                      The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks 
    588                      will be executed respectively at the end of the transmit or receive process.
    589                      The HAL_UART_ErrorCallback() user callback will be executed when 
    590                      a communication error is detected.
    591          
    592              (#) Blocking mode APIs are:
    593                  (++) HAL_UART_Transmit()
    594                  (++) HAL_UART_Receive() 
    595          
    596              (#) Non Blocking mode APIs with Interrupt are:
    597                  (++) HAL_UART_Transmit_IT()
    598                  (++) HAL_UART_Receive_IT()
    599                  (++) HAL_UART_IRQHandler()
    600          
    601              (#) Non Blocking mode functions with DMA are:
    602                  (++) HAL_UART_Transmit_DMA()
    603                  (++) HAL_UART_Receive_DMA()
    604                  (++) HAL_UART_DMAPause()
    605                  (++) HAL_UART_DMAResume()
    606                  (++) HAL_UART_DMAStop()
    607          
    608              (#) A set of Transfer Complete Callbacks are provided in non blocking mode:
    609                  (++) HAL_UART_TxHalfCpltCallback()
    610                  (++) HAL_UART_TxCpltCallback()
    611                  (++) HAL_UART_RxHalfCpltCallback()
    612                  (++) HAL_UART_RxCpltCallback()
    613                  (++) HAL_UART_ErrorCallback()
    614          
    615              [..] 
    616                (@) In the Half duplex communication, it is forbidden to run the transmit 
    617                    and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX 
    618                    can't be useful.
    619                
    620          @endverbatim
    621            * @{
    622            */
    623          
    624          /**
    625            * @brief  Sends an amount of data in blocking mode. 
    626            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    627            *                the configuration information for the specified UART module.
    628            * @param  pData: Pointer to data buffer
    629            * @param  Size: Amount of data to be sent
    630            * @param  Timeout: Timeout duration  
    631            * @retval HAL status
    632            */

   \                                 In section .text, align 2, keep-with-next
    633          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    634          {
   \                     HAL_UART_Transmit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x461E             MOV      R6,R3
    635            uint16_t* tmp;
    636            uint32_t tmp_state = 0;
    637            
    638            tmp_state = huart->State;
   \   00000008   0xF995 0x0039      LDRSB    R0,[R5, #+57]
    639            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Transmit_0
   \   00000010   0x2822             CMP      R0,#+34
   \   00000012   0xD14A             BNE.N    ??HAL_UART_Transmit_1
    640            {
    641              if((pData == NULL) || (Size == 0))
   \                     ??HAL_UART_Transmit_0: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD001             BEQ.N    ??HAL_UART_Transmit_2
   \   00000018   0x0010             MOVS     R0,R2
   \   0000001A   0xD101             BNE.N    ??HAL_UART_Transmit_3
    642              {
    643                return  HAL_ERROR;
   \                     ??HAL_UART_Transmit_2: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xBD70             POP      {R4-R6,PC}
    644              }
    645          
    646              /* Process Locked */
    647            //  __HAL_LOCK(huart);
    648          
    649              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \                     ??HAL_UART_Transmit_3: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x63E8             STR      R0,[R5, #+60]
    650              /* Check if a non-blocking receive process is ongoing or not */
    651              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   00000024   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   00000028   0x2822             CMP      R0,#+34
   \   0000002A   0xD103             BNE.N    ??HAL_UART_Transmit_4
    652              {
    653                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000002C   0x2032             MOVS     R0,#+50
   \   0000002E   0xF885 0x0039      STRB     R0,[R5, #+57]
   \   00000032   0xE002             B.N      ??HAL_UART_Transmit_5
    654              }
    655              else
    656              {
    657                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_4: (+1)
   \   00000034   0x2012             MOVS     R0,#+18
   \   00000036   0xF885 0x0039      STRB     R0,[R5, #+57]
    658              }
    659          
    660              huart->TxXferSize = Size;
   \                     ??HAL_UART_Transmit_5: (+1)
   \   0000003A   0x84AA             STRH     R2,[R5, #+36]
    661              huart->TxXferCount = Size;
   \   0000003C   0x84EA             STRH     R2,[R5, #+38]
   \   0000003E   0xE00A             B.N      ??HAL_UART_Transmit_6
    662              while(huart->TxXferCount > 0)
    663              {
    664                huart->TxXferCount--;
    665                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    666                {
    667                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
    668                  {
    669                    return HAL_TIMEOUT;
    670                  }
    671                  tmp = (uint16_t*) pData;
    672                  huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
    673                  if(huart->Init.Parity == UART_PARITY_NONE)
    674                  {
    675                    pData +=2;
    676                  }
    677                  else
    678                  { 
    679                    pData +=1;
    680                  }
    681                } 
    682                else
    683                {
    684                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_7: (+1)
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x2180             MOVS     R1,#+128
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD137             BNE.N    ??HAL_UART_Transmit_8
    685                  {
    686                    return HAL_TIMEOUT;
    687                  }
    688                  huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
   \   0000004E   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000052   0x6829             LDR      R1,[R5, #+0]
   \   00000054   0x6048             STR      R0,[R1, #+4]
    689                }
   \                     ??HAL_UART_Transmit_6: (+1)
   \   00000056   0x8CE8             LDRH     R0,[R5, #+38]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD028             BEQ.N    ??HAL_UART_Transmit_9
   \   0000005C   0x1E40             SUBS     R0,R0,#+1
   \   0000005E   0x84E8             STRH     R0,[R5, #+38]
   \   00000060   0x68A8             LDR      R0,[R5, #+8]
   \   00000062   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000066   0x4633             MOV      R3,R6
   \   00000068   0xD1EA             BNE.N    ??HAL_UART_Transmit_7
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0x2180             MOVS     R1,#+128
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD122             BNE.N    ??HAL_UART_Transmit_8
   \   00000078   0x8820             LDRH     R0,[R4, #+0]
   \   0000007A   0xF3C0 0x0008      UBFX     R0,R0,#+0,#+9
   \   0000007E   0x6829             LDR      R1,[R5, #+0]
   \   00000080   0x6048             STR      R0,[R1, #+4]
   \   00000082   0x6928             LDR      R0,[R5, #+16]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD101             BNE.N    ??HAL_UART_Transmit_10
   \   00000088   0x1CA4             ADDS     R4,R4,#+2
   \   0000008A   0xE7E4             B.N      ??HAL_UART_Transmit_6
   \                     ??HAL_UART_Transmit_10: (+1)
   \   0000008C   0x1C64             ADDS     R4,R4,#+1
   \   0000008E   0xE7E2             B.N      ??HAL_UART_Transmit_6
    690              }
    691          
    692              if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)
    693              { 
    694                return HAL_TIMEOUT;
    695              }
    696          
    697              /* Check if a non-blocking receive process is ongoing or not */
    698              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Transmit_11: (+1)
   \   00000090   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   00000094   0x2832             CMP      R0,#+50
   \   00000096   0xD103             BNE.N    ??HAL_UART_Transmit_12
    699              {
    700                huart->State = HAL_UART_STATE_BUSY_RX;
   \   00000098   0x2022             MOVS     R0,#+34
   \   0000009A   0xF885 0x0039      STRB     R0,[R5, #+57]
   \   0000009E   0xE002             B.N      ??HAL_UART_Transmit_13
    701              }
    702              else
    703              {
    704                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Transmit_12: (+1)
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xF885 0x0039      STRB     R0,[R5, #+57]
    705              }
    706          
    707              /* Process Unlocked */
    708            //  __HAL_UNLOCK(huart);
    709          
    710              return HAL_OK;
   \                     ??HAL_UART_Transmit_13: (+1)
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xBD70             POP      {R4-R6,PC}
    711            }
    712            else
    713            {
    714              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_1: (+1)
   \   000000AA   0x2002             MOVS     R0,#+2
   \   000000AC   0xBD70             POP      {R4-R6,PC}       ;; return
    715            }
   \                     ??HAL_UART_Transmit_9: (+1)
   \   000000AE   0x4633             MOV      R3,R6
   \   000000B0   0x2200             MOVS     R2,#+0
   \   000000B2   0x2140             MOVS     R1,#+64
   \   000000B4   0x4628             MOV      R0,R5
   \   000000B6   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD0E8             BEQ.N    ??HAL_UART_Transmit_11
   \                     ??HAL_UART_Transmit_8: (+1)
   \   000000BE   0x2003             MOVS     R0,#+3
   \   000000C0   0xBD70             POP      {R4-R6,PC}
    716          }
    717          
    718          /**
    719            * @brief  Receives an amount of data in blocking mode. 
    720            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    721            *                the configuration information for the specified UART module.
    722            * @param  pData: Pointer to data buffer
    723            * @param  Size: Amount of data to be received
    724            * @param  Timeout: Timeout duration
    725            * @retval HAL status
    726            */

   \                                 In section .text, align 2, keep-with-next
    727          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    728          {
   \                     HAL_UART_Receive: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x461E             MOV      R6,R3
    729            uint16_t* tmp;
    730            uint32_t  tmp_state = 0;
    731          
    732            tmp_state = huart->State;
   \   00000008   0xF995 0x0039      LDRSB    R0,[R5, #+57]
    733            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Receive_0
   \   00000010   0x2812             CMP      R0,#+18
   \   00000012   0xD14F             BNE.N    ??HAL_UART_Receive_1
    734            {
    735              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_0: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD001             BEQ.N    ??HAL_UART_Receive_2
   \   00000018   0x0010             MOVS     R0,R2
   \   0000001A   0xD101             BNE.N    ??HAL_UART_Receive_3
    736              {
    737                return  HAL_ERROR;
   \                     ??HAL_UART_Receive_2: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xBD70             POP      {R4-R6,PC}
    738              }
    739          
    740              /* Process Locked */
    741              __HAL_LOCK(huart);
    742          
    743              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \                     ??HAL_UART_Receive_3: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x63E8             STR      R0,[R5, #+60]
    744              /* Check if a non-blocking transmit process is ongoing or not */
    745              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000024   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   00000028   0x2812             CMP      R0,#+18
   \   0000002A   0xD103             BNE.N    ??HAL_UART_Receive_4
    746              {
    747                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000002C   0x2032             MOVS     R0,#+50
   \   0000002E   0xF885 0x0039      STRB     R0,[R5, #+57]
   \   00000032   0xE002             B.N      ??HAL_UART_Receive_5
    748              }
    749              else
    750              {
    751                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_4: (+1)
   \   00000034   0x2022             MOVS     R0,#+34
   \   00000036   0xF885 0x0039      STRB     R0,[R5, #+57]
    752              }
    753          
    754              huart->RxXferSize = Size;
   \                     ??HAL_UART_Receive_5: (+1)
   \   0000003A   0x85AA             STRH     R2,[R5, #+44]
    755              huart->RxXferCount = Size;
   \   0000003C   0x85EA             STRH     R2,[R5, #+46]
   \   0000003E   0xE003             B.N      ??HAL_UART_Receive_6
    756          
    757              /* Check the remain data to be received */
    758              while(huart->RxXferCount > 0)
    759              {
    760                huart->RxXferCount--;
    761                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    762                {
    763                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    764                  {
    765                    return HAL_TIMEOUT;
    766                  }
    767                  tmp = (uint16_t*) pData ;
    768                  if(huart->Init.Parity == UART_PARITY_NONE)
    769                  {
    770                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \                     ??HAL_UART_Receive_7: (+1)
   \   00000040   0xF3C0 0x0008      UBFX     R0,R0,#+0,#+9
   \   00000044   0xF824 0x0B02      STRH     R0,[R4], #+2
    771                    pData +=2;
    772                  }
   \                     ??HAL_UART_Receive_6: (+1)
   \   00000048   0x8DE8             LDRH     R0,[R5, #+46]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD034             BEQ.N    ??HAL_UART_Receive_8
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x85E8             STRH     R0,[R5, #+46]
   \   00000052   0x68A8             LDR      R0,[R5, #+8]
   \   00000054   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000058   0x4633             MOV      R3,R6
   \   0000005A   0xD110             BNE.N    ??HAL_UART_Receive_9
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x2120             MOVS     R1,#+32
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD110             BNE.N    ??HAL_UART_Receive_10
   \   0000006A   0x6829             LDR      R1,[R5, #+0]
   \   0000006C   0x6928             LDR      R0,[R5, #+16]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0x6848             LDR      R0,[R1, #+4]
   \   00000072   0xD0E5             BEQ.N    ??HAL_UART_Receive_7
    773                  else
    774                  {
    775                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \   00000074   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   00000078   0xF824 0x0B01      STRH     R0,[R4], #+1
    776                    pData +=1;
   \   0000007C   0xE7E4             B.N      ??HAL_UART_Receive_6
    777                  }
    778          
    779                }
    780                else
    781                {
    782                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Receive_9: (+1)
   \   0000007E   0x2200             MOVS     R2,#+0
   \   00000080   0x2120             MOVS     R1,#+32
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD001             BEQ.N    ??HAL_UART_Receive_11
    783                  {
    784                    return HAL_TIMEOUT;
   \                     ??HAL_UART_Receive_10: (+1)
   \   0000008C   0x2003             MOVS     R0,#+3
   \   0000008E   0xBD70             POP      {R4-R6,PC}
    785                  }
    786                  if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??HAL_UART_Receive_11: (+1)
   \   00000090   0x6829             LDR      R1,[R5, #+0]
   \   00000092   0x6928             LDR      R0,[R5, #+16]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0x6848             LDR      R0,[R1, #+4]
   \   00000098   0xD102             BNE.N    ??HAL_UART_Receive_12
    787                  {
    788                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \   0000009A   0xF804 0x0B01      STRB     R0,[R4], #+1
   \   0000009E   0xE7D3             B.N      ??HAL_UART_Receive_6
    789                  }
    790                  else
    791                  {
    792                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??HAL_UART_Receive_12: (+1)
   \   000000A0   0xF000 0x007F      AND      R0,R0,#0x7F
   \   000000A4   0xF804 0x0B01      STRB     R0,[R4], #+1
   \   000000A8   0xE7CE             B.N      ??HAL_UART_Receive_6
    793                  }
    794          
    795                }
    796              }
    797          
    798              /* Check if a non-blocking transmit process is ongoing or not */
    799              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
    800              {
    801                huart->State = HAL_UART_STATE_BUSY_TX;
    802              }
    803              else
    804              {
    805                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Receive_13: (+1)
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xF885 0x0039      STRB     R0,[R5, #+57]
    806              }
    807              /* Process Unlocked */
    808              __HAL_UNLOCK(huart);
    809          
    810              return HAL_OK;
   \                     ??HAL_UART_Receive_14: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xBD70             POP      {R4-R6,PC}
    811            }
    812            else
    813            {
    814              return HAL_BUSY;
   \                     ??HAL_UART_Receive_1: (+1)
   \   000000B4   0x2002             MOVS     R0,#+2
   \   000000B6   0xBD70             POP      {R4-R6,PC}       ;; return
    815            }
   \                     ??HAL_UART_Receive_8: (+1)
   \   000000B8   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   000000BC   0x2832             CMP      R0,#+50
   \   000000BE   0xD1F4             BNE.N    ??HAL_UART_Receive_13
   \   000000C0   0x2012             MOVS     R0,#+18
   \   000000C2   0xF885 0x0039      STRB     R0,[R5, #+57]
   \   000000C6   0xE7F3             B.N      ??HAL_UART_Receive_14
    816          }
    817          
    818          /**
    819            * @brief  Sends an amount of data in non blocking mode.
    820            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    821            *                the configuration information for the specified UART module.
    822            * @param  pData: Pointer to data buffer
    823            * @param  Size: Amount of data to be sent
    824            * @retval HAL status
    825            */

   \                                 In section .text, align 2, keep-with-next
    826          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    827          {
    828            uint32_t tmp_state = 0;
    829          
    830            tmp_state = huart->State;
   \                     HAL_UART_Transmit_IT: (+1)
   \   00000000   0xF990 0x3039      LDRSB    R3,[R0, #+57]
    831            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD001             BEQ.N    ??HAL_UART_Transmit_IT_0
   \   00000008   0x2B22             CMP      R3,#+34
   \   0000000A   0xD11C             BNE.N    ??HAL_UART_Transmit_IT_1
    832            {
    833              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Transmit_IT_0: (+1)
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Transmit_IT_2
   \   00000010   0x0013             MOVS     R3,R2
   \   00000012   0xD101             BNE.N    ??HAL_UART_Transmit_IT_3
    834              {
    835                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_IT_2: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR
    836              }
    837              
    838              /* Process Locked */
    839              __HAL_LOCK(huart);
    840              
    841              huart->pTxBuffPtr = pData;
   \                     ??HAL_UART_Transmit_IT_3: (+1)
   \   00000018   0x6201             STR      R1,[R0, #+32]
    842              huart->TxXferSize = Size;
   \   0000001A   0x8482             STRH     R2,[R0, #+36]
    843              huart->TxXferCount = Size;
   \   0000001C   0x84C2             STRH     R2,[R0, #+38]
    844          
    845              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x63C1             STR      R1,[R0, #+60]
    846              /* Check if a receive process is ongoing or not */
    847              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   00000022   0xF990 0x1039      LDRSB    R1,[R0, #+57]
   \   00000026   0x2922             CMP      R1,#+34
   \   00000028   0xD103             BNE.N    ??HAL_UART_Transmit_IT_4
    848              {
    849                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000002A   0x2132             MOVS     R1,#+50
   \   0000002C   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   00000030   0xE002             B.N      ??HAL_UART_Transmit_IT_5
    850              }
    851              else
    852              {
    853                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_IT_4: (+1)
   \   00000032   0x2112             MOVS     R1,#+18
   \   00000034   0xF880 0x1039      STRB     R1,[R0, #+57]
    854              }
    855          
    856              /* Process Unlocked */
    857              __HAL_UNLOCK(huart);
    858          
    859              /* Enable the UART Transmit data register empty Interrupt */
    860              __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
   \                     ??HAL_UART_Transmit_IT_5: (+1)
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x68C1             LDR      R1,[R0, #+12]
   \   0000003C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000040   0x60C1             STR      R1,[R0, #+12]
    861              
    862              return HAL_OK;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x4770             BX       LR
    863            }
    864            else
    865            {
    866              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_IT_1: (+1)
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x4770             BX       LR               ;; return
    867            }
    868          }
    869          
    870          /**
    871            * @brief  Receives an amount of data in non blocking mode 
    872            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    873            *                the configuration information for the specified UART module.
    874            * @param  pData: Pointer to data buffer
    875            * @param  Size: Amount of data to be received
    876            * @retval HAL status
    877            */

   \                                 In section .text, align 2, keep-with-next
    878          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    879          {
    880            uint32_t tmp_state = 0;
    881            
    882            tmp_state = huart->State;
   \                     HAL_UART_Receive_IT: (+1)
   \   00000000   0xF990 0x3039      LDRSB    R3,[R0, #+57]
    883            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD001             BEQ.N    ??HAL_UART_Receive_IT_0
   \   00000008   0x2B12             CMP      R3,#+18
   \   0000000A   0xD126             BNE.N    ??HAL_UART_Receive_IT_1
    884            {
    885              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_IT_0: (+1)
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Receive_IT_2
   \   00000010   0x0013             MOVS     R3,R2
   \   00000012   0xD101             BNE.N    ??HAL_UART_Receive_IT_3
    886              {
    887                return HAL_ERROR;
   \                     ??HAL_UART_Receive_IT_2: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR
    888              }
    889          
    890              /* Process Locked */
    891              __HAL_LOCK(huart);
    892          
    893              huart->pRxBuffPtr = pData;
   \                     ??HAL_UART_Receive_IT_3: (+1)
   \   00000018   0x6281             STR      R1,[R0, #+40]
    894              huart->RxXferSize = Size;
   \   0000001A   0x8582             STRH     R2,[R0, #+44]
    895              huart->RxXferCount = Size;
   \   0000001C   0x85C2             STRH     R2,[R0, #+46]
    896          
    897              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x63C1             STR      R1,[R0, #+60]
    898              /* Check if a transmit process is ongoing or not */
    899              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000022   0xF990 0x1039      LDRSB    R1,[R0, #+57]
   \   00000026   0x2912             CMP      R1,#+18
   \   00000028   0xD103             BNE.N    ??HAL_UART_Receive_IT_4
    900              {
    901                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000002A   0x2132             MOVS     R1,#+50
   \   0000002C   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   00000030   0xE002             B.N      ??HAL_UART_Receive_IT_5
    902              }
    903              else
    904              {
    905                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_IT_4: (+1)
   \   00000032   0x2122             MOVS     R1,#+34
   \   00000034   0xF880 0x1039      STRB     R1,[R0, #+57]
    906              }
    907          
    908              /* Process Unlocked */
    909              __HAL_UNLOCK(huart);
    910          
    911              /* Enable the UART Parity Error Interrupt */
    912              __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
   \                     ??HAL_UART_Receive_IT_5: (+1)
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x68CA             LDR      R2,[R1, #+12]
   \   0000003C   0xF442 0x7280      ORR      R2,R2,#0x100
   \   00000040   0x60CA             STR      R2,[R1, #+12]
    913          
    914              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    915              __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0x694A             LDR      R2,[R1, #+20]
   \   00000046   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000004A   0x614A             STR      R2,[R1, #+20]
    916          
    917              /* Enable the UART Data Register not empty Interrupt */
    918              __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x68C1             LDR      R1,[R0, #+12]
   \   00000050   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000054   0x60C1             STR      R1,[R0, #+12]
    919          
    920              return HAL_OK;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x4770             BX       LR
    921            }
    922            else
    923            {
    924              return HAL_BUSY;
   \                     ??HAL_UART_Receive_IT_1: (+1)
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x4770             BX       LR               ;; return
    925            }
    926          }
    927          
    928          /**
    929            * @brief  Sends an amount of data in non blocking mode. 
    930            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    931            *                the configuration information for the specified UART module.
    932            * @param  pData: Pointer to data buffer
    933            * @param  Size: Amount of data to be sent
    934            * @retval HAL status
    935            */

   \                                 In section .text, align 2, keep-with-next
    936          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    937          {
    938          #if 0
    939            uint32_t *tmp;
    940            uint32_t tmp_state = 0;
    941          
    942            tmp_state = huart->State;
    943            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
    944            {
    945              if((pData == NULL ) || (Size == 0)) 
    946              {
    947                return HAL_ERROR;
    948              }
    949          
    950              /* Process Locked */
    951              __HAL_LOCK(huart);
    952          
    953              huart->pTxBuffPtr = pData;
    954              huart->TxXferSize = Size;
    955              huart->TxXferCount = Size;
    956          
    957              huart->ErrorCode = HAL_UART_ERROR_NONE;
    958              /* Check if a receive process is ongoing or not */
    959              if(huart->State == HAL_UART_STATE_BUSY_RX)
    960              {
    961                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    962              }
    963              else
    964              {
    965                huart->State = HAL_UART_STATE_BUSY_TX;
    966              }
    967          
    968              /* Set the UART DMA transfer complete callback */
    969              huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
    970          
    971              /* Set the UART DMA Half transfer complete callback */
    972              huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
    973          
    974              /* Set the DMA error callback */
    975              huart->hdmatx->XferErrorCallback = UART_DMAError;
    976          
    977              /* Enable the UART transmit DMA channel */
    978              tmp = (uint32_t*)&pData;
    979              HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
    980          
    981              /* Clear the TC flag in the SR register by writing 0 to it */
    982              __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
    983          
    984              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    985                 in the UART CR3 register */
    986              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
    987          
    988              /* Process Unlocked */
    989              __HAL_UNLOCK(huart);
    990          
    991              return HAL_OK;
    992            }
    993            else
    994            {
    995              return HAL_BUSY;
    996            }
    997            #endif
    998          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "HAL_UART_Transmit_DMA"
   \                     HAL_UART_Transmit_DMA: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    999          
   1000          /**
   1001            * @brief  Receives an amount of data in non blocking mode. 
   1002            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1003            *                the configuration information for the specified UART module.
   1004            * @param  pData: Pointer to data buffer
   1005            * @param  Size: Amount of data to be received
   1006            * @note   When the UART parity is enabled (PCE = 1), the received data contain 
   1007            *         the parity bit (MSB position)     
   1008            * @retval HAL status
   1009            */

   \                                 In section .text, align 2, keep-with-next
   1010          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   1011          {
   \                     HAL_UART_Receive_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4613             MOV      R3,R2
   1012            uint32_t *tmp;
   1013            uint32_t tmp_state = 0;
   1014          
   1015            tmp_state = huart->State;
   \   00000006   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   1016            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD001             BEQ.N    ??HAL_UART_Receive_DMA_0
   \   0000000E   0x2812             CMP      R0,#+18
   \   00000010   0xD12D             BNE.N    ??HAL_UART_Receive_DMA_1
   1017            {
   1018              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_DMA_0: (+1)
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD001             BEQ.N    ??HAL_UART_Receive_DMA_2
   \   00000016   0x0018             MOVS     R0,R3
   \   00000018   0xD101             BNE.N    ??HAL_UART_Receive_DMA_3
   1019              {
   1020                return HAL_ERROR;
   \                     ??HAL_UART_Receive_DMA_2: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD10             POP      {R4,PC}
   1021              }
   1022          
   1023              /* Process Locked */
   1024              __HAL_LOCK(huart);
   1025          
   1026              huart->pRxBuffPtr = pData;
   \                     ??HAL_UART_Receive_DMA_3: (+1)
   \   0000001E   0x62A1             STR      R1,[R4, #+40]
   1027              huart->RxXferSize = Size;
   \   00000020   0x85A3             STRH     R3,[R4, #+44]
   1028          
   1029              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x63E0             STR      R0,[R4, #+60]
   1030              /* Check if a transmit process is ongoing or not */
   1031              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000026   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000002A   0x2812             CMP      R0,#+18
   \   0000002C   0xD103             BNE.N    ??HAL_UART_Receive_DMA_4
   1032              {
   1033                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000002E   0x2032             MOVS     R0,#+50
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000034   0xE002             B.N      ??HAL_UART_Receive_DMA_5
   1034              }
   1035              else
   1036              {
   1037                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_DMA_4: (+1)
   \   00000036   0x2022             MOVS     R0,#+34
   \   00000038   0xF884 0x0039      STRB     R0,[R4, #+57]
   1038              }
   1039          
   1040              /* Set the UART DMA transfer complete callback */
   1041              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
   \                     ??HAL_UART_Receive_DMA_5: (+1)
   \   0000003C   0x.... 0x....      ADR.W    R0,UART_DMAReceiveCplt
   \   00000040   0x6B62             LDR      R2,[R4, #+52]
   \   00000042   0x6290             STR      R0,[R2, #+40]
   1042          
   1043              /* Set the UART DMA Half transfer complete callback */
   1044              huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
   \   00000044   0x.... 0x....      ADR.W    R0,UART_DMARxHalfCplt
   \   00000048   0x6B62             LDR      R2,[R4, #+52]
   \   0000004A   0x62D0             STR      R0,[R2, #+44]
   1045          
   1046              /* Set the DMA error callback */
   1047              huart->hdmarx->XferErrorCallback = UART_DMAError;
   \   0000004C   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   00000050   0x6B62             LDR      R2,[R4, #+52]
   \   00000052   0x6310             STR      R0,[R2, #+48]
   1048          
   1049              /* Enable the DMA channel */
   1050              tmp = (uint32_t*)&pData;
   1051              HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
   \   00000054   0x460A             MOV      R2,R1
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x1D01             ADDS     R1,R0,#+4
   \   0000005A   0x6B60             LDR      R0,[R4, #+52]
   \   0000005C   0x.... 0x....      BL       HAL_DMA_Start_IT
   1052          
   1053              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
   1054                 in the UART CR3 register */
   1055              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6941             LDR      R1,[R0, #+20]
   \   00000064   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000068   0x6141             STR      R1,[R0, #+20]
   1056          
   1057              /* Process Unlocked */
   1058              __HAL_UNLOCK(huart);
   1059          
   1060              return HAL_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD10             POP      {R4,PC}
   1061            }
   1062            else
   1063            {
   1064              return HAL_BUSY;
   \                     ??HAL_UART_Receive_DMA_1: (+1)
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0xBD10             POP      {R4,PC}          ;; return
   1065            }
   1066          }
   1067              
   1068          /**
   1069            * @brief Pauses the DMA Transfer.
   1070            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1071            *                the configuration information for the specified UART module.
   1072            * @retval HAL status
   1073            */

   \                                 In section .text, align 2, keep-with-next
   1074          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1075          {
   1076            /* Process Locked */
   1077            __HAL_LOCK(huart);
   1078            
   1079            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \                     HAL_UART_DMAPause: (+1)
   \   00000000   0xF990 0x1039      LDRSB    R1,[R0, #+57]
   \   00000004   0x2912             CMP      R1,#+18
   \   00000006   0xD106             BNE.N    ??HAL_UART_DMAPause_0
   1080            {
   1081              /* Disable the UART DMA Tx request */
   1082              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x6941             LDR      R1,[R0, #+20]
   \   0000000C   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000010   0x6141             STR      R1,[R0, #+20]
   1083            }
   1084            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   1085            {
   1086              /* Disable the UART DMA Rx request */
   1087              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   1088            }
   1089            else if (huart->State == HAL_UART_STATE_BUSY_TX_RX)
   1090            {
   1091              /* Disable the UART DMA Tx & Rx requests */
   1092              CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   1093            }
   1094            else
   1095            {
   1096              /* Process Unlocked */
   1097              __HAL_UNLOCK(huart);
   1098            
   1099              return HAL_ERROR; 
   1100            }
   1101            
   1102            /* Process Unlocked */
   1103            __HAL_UNLOCK(huart);
   1104          
   1105            return HAL_OK; 
   \                     ??HAL_UART_DMAPause_1: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
   \                     ??HAL_UART_DMAPause_0: (+1)
   \   00000016   0xF990 0x1039      LDRSB    R1,[R0, #+57]
   \   0000001A   0x2922             CMP      R1,#+34
   \   0000001C   0xD105             BNE.N    ??HAL_UART_DMAPause_2
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x6941             LDR      R1,[R0, #+20]
   \   00000022   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000026   0x6141             STR      R1,[R0, #+20]
   \   00000028   0xE7F3             B.N      ??HAL_UART_DMAPause_1
   \                     ??HAL_UART_DMAPause_2: (+1)
   \   0000002A   0xF990 0x1039      LDRSB    R1,[R0, #+57]
   \   0000002E   0x2932             CMP      R1,#+50
   \   00000030   0xD105             BNE.N    ??HAL_UART_DMAPause_3
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x6941             LDR      R1,[R0, #+20]
   \   00000036   0xF021 0x01C0      BIC      R1,R1,#0xC0
   \   0000003A   0x6141             STR      R1,[R0, #+20]
   \   0000003C   0xE7E9             B.N      ??HAL_UART_DMAPause_1
   \                     ??HAL_UART_DMAPause_3: (+1)
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x4770             BX       LR
   1106          }
   1107          
   1108          /**
   1109            * @brief Resumes the DMA Transfer.
   1110            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1111            *                the configuration information for the specified UART module.
   1112            * @retval HAL status
   1113            */

   \                                 In section .text, align 2, keep-with-next
   1114          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1115          {
   \                     HAL_UART_DMAResume: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   1116            /* Process Locked */
   1117            __HAL_LOCK(huart);
   1118          
   1119            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000002   0xF990 0x1039      LDRSB    R1,[R0, #+57]
   \   00000006   0x2912             CMP      R1,#+18
   \   00000008   0xD107             BNE.N    ??HAL_UART_DMAResume_0
   1120            {
   1121              /* Enable the UART DMA Tx request */
   1122              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x6941             LDR      R1,[R0, #+20]
   \   0000000E   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000012   0x6141             STR      R1,[R0, #+20]
   1123            }
   1124            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   1125            {
   1126              /* Clear the Overrun flag before resumming the Rx transfer*/
   1127              __HAL_UART_CLEAR_OREFLAG(huart);
   1128              /* Enable the UART DMA Rx request */
   1129              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   1130            }
   1131            else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   1132            {
   1133              /* Clear the Overrun flag before resumming the Rx transfer*/
   1134              __HAL_UART_CLEAR_OREFLAG(huart);
   1135              /* Enable the UART DMA Tx & Rx request */
   1136              SET_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   1137            }
   1138            else
   1139            {
   1140              /* Process Unlocked */
   1141              __HAL_UNLOCK(huart);
   1142          
   1143              return HAL_ERROR; 
   1144            }
   1145          
   1146            /* Process Unlocked */
   1147            __HAL_UNLOCK(huart);
   1148          
   1149            return HAL_OK;
   \                     ??HAL_UART_DMAResume_1: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAResume_2: (+1)
   \   00000016   0xB001             ADD      SP,SP,#+4
   \   00000018   0x4770             BX       LR               ;; return
   \                     ??HAL_UART_DMAResume_0: (+1)
   \   0000001A   0xF990 0x1039      LDRSB    R1,[R0, #+57]
   \   0000001E   0x2922             CMP      R1,#+34
   \   00000020   0xD10A             BNE.N    ??HAL_UART_DMAResume_3
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x9100             STR      R1,[SP, #+0]
   \   00000028   0x6841             LDR      R1,[R0, #+4]
   \   0000002A   0x9100             STR      R1,[SP, #+0]
   \   0000002C   0x9900             LDR      R1,[SP, #+0]
   \   0000002E   0x6941             LDR      R1,[R0, #+20]
   \   00000030   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000034   0x6141             STR      R1,[R0, #+20]
   \   00000036   0xE7ED             B.N      ??HAL_UART_DMAResume_1
   \                     ??HAL_UART_DMAResume_3: (+1)
   \   00000038   0xF990 0x1039      LDRSB    R1,[R0, #+57]
   \   0000003C   0x2932             CMP      R1,#+50
   \   0000003E   0xD10A             BNE.N    ??HAL_UART_DMAResume_4
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0x9100             STR      R1,[SP, #+0]
   \   00000046   0x6841             LDR      R1,[R0, #+4]
   \   00000048   0x9100             STR      R1,[SP, #+0]
   \   0000004A   0x9900             LDR      R1,[SP, #+0]
   \   0000004C   0x6941             LDR      R1,[R0, #+20]
   \   0000004E   0xF041 0x01C0      ORR      R1,R1,#0xC0
   \   00000052   0x6141             STR      R1,[R0, #+20]
   \   00000054   0xE7DE             B.N      ??HAL_UART_DMAResume_1
   \                     ??HAL_UART_DMAResume_4: (+1)
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xE7DD             B.N      ??HAL_UART_DMAResume_2
   1150          }
   1151          
   1152          /**
   1153            * @brief Stops the DMA Transfer.
   1154            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1155            *                the configuration information for the specified UART module.
   1156            * @retval HAL status
   1157            */

   \                                 In section .text, align 2, keep-with-next
   1158          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1159          {
   \                     HAL_UART_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1160            /* The Lock is not implemented on this API to allow the user application
   1161               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
   1162               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1163               and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
   1164               */
   1165            
   1166            /* Disable the UART Tx/Rx DMA requests */
   1167            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6941             LDR      R1,[R0, #+20]
   \   00000008   0xF021 0x01C0      BIC      R1,R1,#0xC0
   \   0000000C   0x6141             STR      R1,[R0, #+20]
   1168            
   1169            /* Abort the UART DMA tx channel */
   1170            if(huart->hdmatx != NULL)
   \   0000000E   0x6B20             LDR      R0,[R4, #+48]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??HAL_UART_DMAStop_0
   1171            {
   1172              HAL_DMA_Abort(huart->hdmatx);
   \   00000014   0x.... 0x....      BL       HAL_DMA_Abort
   1173            }
   1174            /* Abort the UART DMA rx channel */
   1175            if(huart->hdmarx != NULL)
   \                     ??HAL_UART_DMAStop_0: (+1)
   \   00000018   0x6B60             LDR      R0,[R4, #+52]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??HAL_UART_DMAStop_1
   1176            {
   1177              HAL_DMA_Abort(huart->hdmarx);
   \   0000001E   0x.... 0x....      BL       HAL_DMA_Abort
   1178            }
   1179            
   1180            huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_DMAStop_1: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
   1181            
   1182            return HAL_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
   1183          }
   1184          
   1185          /**
   1186            * @brief  This function handles UART interrupt request.
   1187            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1188            *                the configuration information for the specified UART module.
   1189            * @retval None
   1190            */

   \                                 In section .text, align 2, keep-with-next
   1191          void HAL_UART_IRQHandler(BspUartDataType *uDataType)
   1192          {
   \                     HAL_UART_IRQHandler: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1193            UART_HandleTypeDef *huart = &uDataType->handle;
   1194          
   1195            uint32_t tmp_flag = 0, tmp_it_source = 0;  
   1196            
   1197            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
   \   00000004   0x6BA0             LDR      R0,[R4, #+56]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF001 0x0101      AND      R1,R1,#0x1
   1198            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0xF400 0x7080      AND      R0,R0,#0x100
   1199            /* UART parity error interrupt occurred ------------------------------------*/
   1200            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD005             BEQ.N    ??HAL_UART_IRQHandler_0
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD003             BEQ.N    ??HAL_UART_IRQHandler_0
   1201            { 
   1202              huart->ErrorCode |= HAL_UART_ERROR_PE;
   \   0000001A   0x6F60             LDR      R0,[R4, #+116]
   \   0000001C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000020   0x6760             STR      R0,[R4, #+116]
   1203            }
   1204            
   1205            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
   \                     ??HAL_UART_IRQHandler_0: (+1)
   \   00000022   0x6BA0             LDR      R0,[R4, #+56]
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x0849             LSRS     R1,R1,#+1
   \   00000028   0xF001 0x0101      AND      R1,R1,#0x1
   1206            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
   \   0000002C   0x6940             LDR      R0,[R0, #+20]
   \   0000002E   0xF000 0x0001      AND      R0,R0,#0x1
   1207            /* UART frame error interrupt occurred -------------------------------------*/
   1208            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD005             BEQ.N    ??HAL_UART_IRQHandler_1
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD003             BEQ.N    ??HAL_UART_IRQHandler_1
   1209            { 
   1210              huart->ErrorCode |= HAL_UART_ERROR_FE;
   \   0000003A   0x6F61             LDR      R1,[R4, #+116]
   \   0000003C   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000040   0x6761             STR      R1,[R4, #+116]
   1211            }
   1212            
   1213            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_NE);
   \                     ??HAL_UART_IRQHandler_1: (+1)
   \   00000042   0x6BA1             LDR      R1,[R4, #+56]
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0x0889             LSRS     R1,R1,#+2
   \   00000048   0xF011 0x0101      ANDS     R1,R1,#0x1
   1214            /* UART noise error interrupt occurred -------------------------------------*/
   1215            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   0000004C   0xD005             BEQ.N    ??HAL_UART_IRQHandler_2
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD003             BEQ.N    ??HAL_UART_IRQHandler_2
   1216            { 
   1217              huart->ErrorCode |= HAL_UART_ERROR_NE;
   \   00000052   0x6F61             LDR      R1,[R4, #+116]
   \   00000054   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000058   0x6761             STR      R1,[R4, #+116]
   1218            }
   1219            
   1220            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_ORE);
   \                     ??HAL_UART_IRQHandler_2: (+1)
   \   0000005A   0x6BA1             LDR      R1,[R4, #+56]
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x08C9             LSRS     R1,R1,#+3
   \   00000060   0xF011 0x0101      ANDS     R1,R1,#0x1
   1221            /* UART Over-Run interrupt occurred ----------------------------------------*/
   1222            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000064   0xD005             BEQ.N    ??HAL_UART_IRQHandler_3
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD003             BEQ.N    ??HAL_UART_IRQHandler_3
   1223            { 
   1224              huart->ErrorCode |= HAL_UART_ERROR_ORE;
   \   0000006A   0x6F60             LDR      R0,[R4, #+116]
   \   0000006C   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000070   0x6760             STR      R0,[R4, #+116]
   1225            }
   1226            
   1227            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE);
   \                     ??HAL_UART_IRQHandler_3: (+1)
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x0949             LSRS     R1,R1,#+5
   \   00000078   0xF001 0x0101      AND      R1,R1,#0x1
   1228            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE);
   \   0000007C   0x68C0             LDR      R0,[R0, #+12]
   \   0000007E   0xF000 0x0020      AND      R0,R0,#0x20
   1229            /* UART in mode Receiver ---------------------------------------------------*/
   1230            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000082   0x2900             CMP      R1,#+0
   \   00000084   0xD004             BEQ.N    ??HAL_UART_IRQHandler_4
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD002             BEQ.N    ??HAL_UART_IRQHandler_4
   1231            { 
   1232              UART_Receive_IT(uDataType);
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       UART_Receive_IT
   1233            }
   1234            
   1235            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
   \                     ??HAL_UART_IRQHandler_4: (+1)
   \   00000090   0x6BA0             LDR      R0,[R4, #+56]
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0x09C9             LSRS     R1,R1,#+7
   \   00000096   0xF001 0x0101      AND      R1,R1,#0x1
   1236            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE);
   \   0000009A   0x68C0             LDR      R0,[R0, #+12]
   \   0000009C   0xF000 0x0080      AND      R0,R0,#0x80
   1237            /* UART in mode Transmitter ------------------------------------------------*/
   1238            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000A0   0x2900             CMP      R1,#+0
   \   000000A2   0xD005             BEQ.N    ??HAL_UART_IRQHandler_5
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD003             BEQ.N    ??HAL_UART_IRQHandler_5
   1239            {
   1240              UART_Transmit_IT(huart);
   \   000000A8   0xF104 0x0038      ADD      R0,R4,#+56
   \   000000AC   0x.... 0x....      BL       UART_Transmit_IT
   1241            }
   1242          
   1243            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TC);
   \                     ??HAL_UART_IRQHandler_5: (+1)
   \   000000B0   0x6BA0             LDR      R0,[R4, #+56]
   \   000000B2   0x6801             LDR      R1,[R0, #+0]
   \   000000B4   0x0989             LSRS     R1,R1,#+6
   \   000000B6   0xF001 0x0101      AND      R1,R1,#0x1
   1244            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC);
   \   000000BA   0x68C0             LDR      R0,[R0, #+12]
   \   000000BC   0xF000 0x0040      AND      R0,R0,#0x40
   1245            /* UART in mode Transmitter end --------------------------------------------*/
   1246            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000C0   0x2900             CMP      R1,#+0
   \   000000C2   0xD004             BEQ.N    ??HAL_UART_IRQHandler_6
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD002             BEQ.N    ??HAL_UART_IRQHandler_6
   1247            {
   1248              UART_EndTransmit_IT(uDataType);
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0x.... 0x....      BL       UART_EndTransmit_IT
   1249            }  
   1250          
   1251            if(huart->ErrorCode != HAL_UART_ERROR_NONE)
   \                     ??HAL_UART_IRQHandler_6: (+1)
   \   000000CE   0x6F60             LDR      R0,[R4, #+116]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD00E             BEQ.N    ??HAL_UART_IRQHandler_7
   1252            {
   1253              /* Clear all the error flag at once */
   1254              __HAL_UART_CLEAR_PEFLAG(huart);
   \   000000D4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D6   0x6801             LDR      R1,[R0, #+0]
   \   000000D8   0x9100             STR      R1,[SP, #+0]
   \   000000DA   0x6840             LDR      R0,[R0, #+4]
   \   000000DC   0x9000             STR      R0,[SP, #+0]
   \   000000DE   0x9800             LDR      R0,[SP, #+0]
   1255              
   1256              /* Set the UART state ready to be able to start again the process */
   1257              huart->State = HAL_UART_STATE_READY;
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0xF884 0x0071      STRB     R0,[R4, #+113]
   1258              
   1259              HAL_UART_ErrorCallback(huart);
   \   000000E6   0xF104 0x0038      ADD      R0,R4,#+56
   \   000000EA   0xE8BD 0x4016      POP      {R1,R2,R4,LR}
   \   000000EE   0x.... 0x....      B.W      HAL_UART_ErrorCallback
   1260            }  
   1261          }
   \                     ??HAL_UART_IRQHandler_7: (+1)
   \   000000F2   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1262          
   1263          /**
   1264            * @brief  Tx Transfer completed callbacks.
   1265            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1266            *                the configuration information for the specified UART module.
   1267            * @retval None
   1268            */

   \                                 In section .text, align 2
   1269           __weak void HAL_UART_TxCpltCallback(BspUartDataType *puart)
   1270          {
   1271            /* Prevent unused argument(s) compilation warning */
   1272            UNUSED(puart);
   1273            /* NOTE: This function should not be modified, when the callback is needed,
   1274                     the HAL_UART_TxCpltCallback can be implemented in the user file
   1275             */ 
   1276          }
   \                     HAL_UART_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1277          
   1278          /**
   1279            * @brief  Tx Half Transfer completed callbacks.
   1280            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1281            *                the configuration information for the specified UART module.
   1282            * @retval None
   1283            */

   \                                 In section .text, align 2
   1284           __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *puart)
   1285          {
   1286            /* Prevent unused argument(s) compilation warning */
   1287            UNUSED(puart);
   1288            /* NOTE: This function should not be modified, when the callback is needed,
   1289                     the HAL_UART_TxHalfCpltCallback can be implemented in the user file
   1290             */ 
   1291          }
   \                     HAL_UART_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1292          
   1293          /**
   1294            * @brief  Rx Transfer completed callbacks.
   1295            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1296            *                the configuration information for the specified UART module.
   1297            * @retval None
   1298            */

   \                                 In section .text, align 2
   1299          __weak void HAL_UART_RxCpltCallback(BspUartDataType *huart)
   1300          {
   1301            /* Prevent unused argument(s) compilation warning */
   1302            UNUSED(huart);
   1303            /* NOTE: This function should not be modified, when the callback is needed,
   1304                     the HAL_UART_RxCpltCallback can be implemented in the user file
   1305             */
   1306          }
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1307          
   1308          /**
   1309            * @brief  Rx Half Transfer completed callbacks.
   1310            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1311            *                the configuration information for the specified UART module.
   1312            * @retval None
   1313            */

   \                                 In section .text, align 2
   1314          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   1315          {
   1316            /* Prevent unused argument(s) compilation warning */
   1317            UNUSED(huart);
   1318            /* NOTE: This function should not be modified, when the callback is needed,
   1319                     the HAL_UART_RxHalfCpltCallback can be implemented in the user file
   1320             */
   1321          }
   \                     HAL_UART_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1322          
   1323          /**
   1324            * @brief  UART error callbacks.
   1325            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1326            *                the configuration information for the specified UART module.
   1327            * @retval None
   1328            */

   \                                 In section .text, align 2
   1329           __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   1330          {
   1331            /* Prevent unused argument(s) compilation warning */
   1332            UNUSED(huart);
   1333            /* NOTE: This function should not be modified, when the callback is needed,
   1334                     the HAL_UART_ErrorCallback can be implemented in the user file
   1335             */ 
   1336          }
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1337          
   1338          /**
   1339            * @}
   1340            */
   1341          
   1342          /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions 
   1343            *  @brief   UART control functions 
   1344            *
   1345          @verbatim   
   1346            ==============================================================================
   1347                                ##### Peripheral Control functions #####
   1348            ==============================================================================  
   1349            [..]
   1350              This subsection provides a set of functions allowing to control the UART:
   1351              (+) HAL_LIN_SendBreak() API can be helpful to transmit the break character.
   1352              (+) HAL_MultiProcessor_EnterMuteMode() API can be helpful to enter the UART in mute mode. 
   1353              (+) HAL_MultiProcessor_ExitMuteMode() API can be helpful to exit the UART mute mode by software.
   1354              (+) HAL_HalfDuplex_EnableTransmitter() API to enable the UART transmitter and disables the UART receiver in Half Duplex mode
   1355              (+) HAL_HalfDuplex_EnableReceiver() API to enable the UART receiver and disables the UART transmitter in Half Duplex mode
   1356              
   1357          @endverbatim
   1358            * @{
   1359            */
   1360          
   1361          /**
   1362            * @brief  Transmits break characters.
   1363            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1364            *                the configuration information for the specified UART module.
   1365            * @retval HAL status
   1366            */

   \                                 In section .text, align 2, keep-with-next
   1367          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   1368          {
   1369            /* Check the parameters */
   1370            assert_param(IS_UART_INSTANCE(huart->Instance));
   1371            
   1372            /* Process Locked */
   1373            __HAL_LOCK(huart);
   1374            
   1375            huart->State = HAL_UART_STATE_BUSY;
   \                     HAL_LIN_SendBreak: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
   1376            
   1377            /* Send break characters */
   1378            SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x68CA             LDR      R2,[R1, #+12]
   \   0000000A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000000E   0x60CA             STR      R2,[R1, #+12]
   1379           
   1380            huart->State = HAL_UART_STATE_READY;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xF880 0x1039      STRB     R1,[R0, #+57]
   1381            
   1382            /* Process Unlocked */
   1383            __HAL_UNLOCK(huart);
   1384            
   1385            return HAL_OK; 
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
   1386          }
   1387          
   1388          /**
   1389            * @brief  Enters the UART in mute mode. 
   1390            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1391            *                the configuration information for the specified UART module.
   1392            * @retval HAL status
   1393            */

   \                                 In section .text, align 2, keep-with-next
   1394          HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   1395          {
   1396            /* Check the parameters */
   1397            assert_param(IS_UART_INSTANCE(huart->Instance));
   1398            
   1399            /* Process Locked */
   1400            __HAL_LOCK(huart);
   1401            
   1402            huart->State = HAL_UART_STATE_BUSY;
   \                     HAL_MultiProcessor_EnterMuteMode: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
   1403            
   1404            /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
   1405            SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x68CA             LDR      R2,[R1, #+12]
   \   0000000A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000000E   0x60CA             STR      R2,[R1, #+12]
   1406            
   1407            huart->State = HAL_UART_STATE_READY;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xF880 0x1039      STRB     R1,[R0, #+57]
   1408            
   1409            /* Process Unlocked */
   1410            __HAL_UNLOCK(huart);
   1411            
   1412            return HAL_OK; 
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
   1413          }
   1414          
   1415          /**
   1416            * @brief  Exits the UART mute mode: wake up software. 
   1417            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1418            *                the configuration information for the specified UART module.
   1419            * @retval HAL status
   1420            */

   \                                 In section .text, align 2, keep-with-next
   1421          HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
   1422          {
   1423            /* Check the parameters */
   1424            assert_param(IS_UART_INSTANCE(huart->Instance));
   1425            
   1426            /* Process Locked */
   1427            __HAL_LOCK(huart);
   1428            
   1429            huart->State = HAL_UART_STATE_BUSY;
   \                     HAL_MultiProcessor_ExitMuteMode: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
   1430            
   1431            /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
   1432            CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x68CA             LDR      R2,[R1, #+12]
   \   0000000A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000000E   0x60CA             STR      R2,[R1, #+12]
   1433            
   1434            huart->State = HAL_UART_STATE_READY;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xF880 0x1039      STRB     R1,[R0, #+57]
   1435            
   1436            /* Process Unlocked */
   1437            __HAL_UNLOCK(huart);
   1438            
   1439            return HAL_OK; 
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
   1440          }
   1441          
   1442          /**
   1443            * @brief  Enables the UART transmitter and disables the UART receiver.
   1444            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1445            *                the configuration information for the specified UART module.
   1446            * @retval HAL status
   1447            */

   \                                 In section .text, align 2, keep-with-next
   1448          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   1449          {
   1450            /* Process Locked */
   1451            __HAL_LOCK(huart);
   1452            
   1453            huart->State = HAL_UART_STATE_BUSY;
   \                     HAL_HalfDuplex_EnableTransmitter: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
   1454          
   1455            /*-------------------------- USART CR1 Configuration -----------------------*/
   1456            /* Clear TE and RE bits */
   1457            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   1458            MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_TE);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x68CA             LDR      R2,[R1, #+12]
   \   0000000A   0xF022 0x020C      BIC      R2,R2,#0xC
   \   0000000E   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000012   0x60CA             STR      R2,[R1, #+12]
   1459           
   1460            huart->State = HAL_UART_STATE_READY;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF880 0x1039      STRB     R1,[R0, #+57]
   1461            
   1462            /* Process Unlocked */
   1463            __HAL_UNLOCK(huart);
   1464            
   1465            return HAL_OK; 
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   1466          }
   1467          
   1468          /**
   1469            * @brief  Enables the UART receiver and disables the UART transmitter.
   1470            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1471            *                the configuration information for the specified UART module.
   1472            * @retval HAL status
   1473            */

   \                                 In section .text, align 2, keep-with-next
   1474          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   1475          {
   1476            /* Process Locked */
   1477            __HAL_LOCK(huart);
   1478            
   1479            huart->State = HAL_UART_STATE_BUSY;
   \                     HAL_HalfDuplex_EnableReceiver: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
   1480          
   1481            /*-------------------------- USART CR1 Configuration -----------------------*/
   1482            /* Clear TE and RE bits */
   1483            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   1484            MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_RE);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x68CA             LDR      R2,[R1, #+12]
   \   0000000A   0xF022 0x020C      BIC      R2,R2,#0xC
   \   0000000E   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000012   0x60CA             STR      R2,[R1, #+12]
   1485            
   1486            huart->State = HAL_UART_STATE_READY;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF880 0x1039      STRB     R1,[R0, #+57]
   1487            
   1488            /* Process Unlocked */
   1489            __HAL_UNLOCK(huart);
   1490            
   1491            return HAL_OK; 
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   1492          }
   1493          
   1494          /**
   1495            * @}
   1496            */
   1497          
   1498          /** @defgroup UART_Exported_Functions_Group4 Peripheral State and Errors functions 
   1499            *  @brief   UART State and Errors functions 
   1500            *
   1501          @verbatim   
   1502            ==============================================================================
   1503                           ##### Peripheral State and Errors functions #####
   1504            ==============================================================================  
   1505           [..]
   1506             This subsection provides a set of functions allowing to return the State of 
   1507             UART communication process, return Peripheral Errors occurred during communication 
   1508             process
   1509             (+) HAL_UART_GetState() API can be helpful to check in run-time the state of the UART peripheral.
   1510             (+) HAL_UART_GetError() check in run-time errors that could be occurred during communication. 
   1511          
   1512          @endverbatim
   1513            * @{
   1514            */
   1515            
   1516          /**
   1517            * @brief  Returns the UART state.
   1518            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1519            *                the configuration information for the specified UART module.
   1520            * @retval HAL state
   1521            */

   \                                 In section .text, align 2, keep-with-next
   1522          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   1523          {
   1524            return huart->State;
   \                     HAL_UART_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1525          }
   1526          
   1527          /**
   1528          * @brief  Return the UART error code
   1529          * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1530            *              the configuration information for the specified UART.
   1531          * @retval UART Error Code
   1532          */

   \                                 In section .text, align 2, keep-with-next
   1533          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   1534          {
   1535            return huart->ErrorCode;
   \                     HAL_UART_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1536          }
   1537          
   1538          /**
   1539            * @}
   1540            */
   1541          
   1542          /**
   1543            * @}
   1544            */
   1545          
   1546          /** @defgroup UART_Private_Functions   UART Private Functions
   1547            *  @brief   UART Private functions 
   1548            * @{
   1549            */
   1550          /**
   1551            * @brief  DMA UART transmit process complete callback. 
   1552            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1553            *               the configuration information for the specified DMA module.
   1554            * @retval None
   1555            */
   1556          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
                             ^
Warning[Pe177]: function "UART_DMATransmitCplt" was declared but never
          referenced
   1557          {
   1558          #if 0
   1559            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   1560            /* DMA Normal mode*/
   1561            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   1562            {
   1563              huart->TxXferCount = 0;
   1564          
   1565              /* Disable the DMA transfer for transmit request by setting the DMAT bit
   1566                 in the UART CR3 register */
   1567              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   1568          
   1569              /* Enable the UART Transmit Complete Interrupt */    
   1570              __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   1571            }
   1572            /* DMA Circular mode */
   1573            else
   1574            {
   1575              HAL_UART_TxCpltCallback(huart);
   1576            }
   1577            #endif
   1578          }
   1579          
   1580          /**
   1581            * @brief DMA UART transmit process half complete callback 
   1582            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1583            *               the configuration information for the specified DMA module.
   1584            * @retval None
   1585            */
   1586          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
                             ^
Warning[Pe177]: function "UART_DMATxHalfCplt" was declared but never referenced
   1587          {
   1588            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1589          
   1590            HAL_UART_TxHalfCpltCallback(huart);
   1591          }
   1592          
   1593          /**
   1594            * @brief  DMA UART receive process complete callback. 
   1595            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1596            *               the configuration information for the specified DMA module.
   1597            * @retval None
   1598            */

   \                                 In section .text, align 4, keep-with-next
   1599          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
   1600          {
   1601          #if 0
   1602            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   1603            /* DMA Normal mode*/
   1604            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   1605            {
   1606              huart->RxXferCount = 0;
   1607            
   1608              /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
   1609                 in the UART CR3 register */
   1610              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   1611          
   1612              /* Check if a transmit process is ongoing or not */
   1613              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   1614              {
   1615                huart->State = HAL_UART_STATE_BUSY_TX;
   1616              }
   1617              else
   1618              {
   1619                huart->State = HAL_UART_STATE_READY;
   1620              }
   1621            }
   1622            HAL_UART_RxCpltCallback(huart);
   1623            #endif
   1624          }
   \                     UART_DMAReceiveCplt: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1625          
   1626          /**
   1627            * @brief DMA UART receive process half complete callback 
   1628            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1629            *               the configuration information for the specified DMA module.
   1630            * @retval None
   1631            */

   \                                 In section .text, align 4, keep-with-next
   1632          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1633          {
   1634            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1635          
   1636            HAL_UART_RxHalfCpltCallback(huart); 
   \                     UART_DMARxHalfCplt: (+1)
   \   00000000   0x6A40             LDR      R0,[R0, #+36]
   \   00000002   0x.... 0x....      B.W      HAL_UART_RxHalfCpltCallback
   1637          }
   1638          
   1639          /**
   1640            * @brief  DMA UART communication error callback.
   1641            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1642            *               the configuration information for the specified DMA module.
   1643            * @retval None
   1644            */

   \                                 In section .text, align 4, keep-with-next
   1645          static void UART_DMAError(DMA_HandleTypeDef *hdma)   
   1646          {
   1647            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \                     UART_DMAError: (+1)
   \   00000000   0x6A40             LDR      R0,[R0, #+36]
   1648            huart->RxXferCount = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x85C1             STRH     R1,[R0, #+46]
   1649            huart->TxXferCount = 0;
   \   00000006   0x84C1             STRH     R1,[R0, #+38]
   1650            huart->State= HAL_UART_STATE_READY;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xF880 0x1039      STRB     R1,[R0, #+57]
   1651            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   \   0000000E   0x6BC1             LDR      R1,[R0, #+60]
   \   00000010   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000014   0x63C1             STR      R1,[R0, #+60]
   1652            HAL_UART_ErrorCallback(huart);
   \   00000016   0x.... 0x....      B.W      HAL_UART_ErrorCallback
   1653          }
   1654          
   1655          /**
   1656            * @brief  This function handles UART Communication Timeout.
   1657            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1658            *                the configuration information for the specified UART module.
   1659            * @param  Flag: specifies the UART flag to check.
   1660            * @param  Status: The new Flag status (SET or RESET).
   1661            * @param  Timeout: Timeout duration
   1662            * @retval HAL status
   1663            */

   \                                 In section .text, align 2, keep-with-next
   1664          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
   1665          {
   \                     UART_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461C             MOV      R4,R3
   1666            uint32_t tickstart = 0;
   1667          
   1668            /* Get tick */ 
   1669            tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4607             MOV      R7,R0
   1670          
   1671            /* Wait until flag is set */
   1672            if(Status == RESET)
   \   00000012   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000016   0xD14A             BNE.N    ??UART_WaitOnFlagUntilTimeout_0
   1673            {
   1674              while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_1: (+1)
   \   00000018   0x6828             LDR      R0,[R5, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x4030             ANDS     R0,R6,R0
   \   0000001E   0x42B0             CMP      R0,R6
   \   00000020   0xD04A             BEQ.N    ??UART_WaitOnFlagUntilTimeout_2
   1675              {
   1676                /* Check for the Timeout */
   1677                if(Timeout != HAL_MAX_DELAY)
   \   00000022   0xF114 0x0F01      CMN      R4,#+1
   \   00000026   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_1
   1678                {
   1679                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD004             BEQ.N    ??UART_WaitOnFlagUntilTimeout_3
   \   0000002C   0x.... 0x....      BL       HAL_GetTick
   \   00000030   0x1BC0             SUBS     R0,R0,R7
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD2F0             BCS.N    ??UART_WaitOnFlagUntilTimeout_1
   1680                  {
   1681                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1682                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_3: (+1)
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0x68C1             LDR      R1,[R0, #+12]
   \   0000003A   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000003E   0x60C1             STR      R1,[R0, #+12]
   1683                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   00000040   0x6828             LDR      R0,[R5, #+0]
   \   00000042   0x68C1             LDR      R1,[R0, #+12]
   \   00000044   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000048   0x60C1             STR      R1,[R0, #+12]
   1684                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x68C1             LDR      R1,[R0, #+12]
   \   0000004E   0xF421 0x7180      BIC      R1,R1,#0x100
   \   00000052   0x60C1             STR      R1,[R0, #+12]
   1685                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   00000054   0x6828             LDR      R0,[R5, #+0]
   \   00000056   0x6941             LDR      R1,[R0, #+20]
   \   00000058   0x0849             LSRS     R1,R1,#+1
   \   0000005A   0x0049             LSLS     R1,R1,#+1
   \   0000005C   0x6141             STR      R1,[R0, #+20]
   1686          
   1687                    huart->State= HAL_UART_STATE_READY;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xF885 0x0039      STRB     R0,[R5, #+57]
   1688          
   1689                    /* Process Unlocked */
   1690                    __HAL_UNLOCK(huart);
   1691          
   1692                    return HAL_TIMEOUT;
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0xE028             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1693                  }
   1694                }
   1695              }
   1696            }
   1697            else
   1698            {
   1699              while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
   1700              {
   1701                /* Check for the Timeout */
   1702                if(Timeout != HAL_MAX_DELAY)
   \                     ??UART_WaitOnFlagUntilTimeout_5: (+1)
   \   00000068   0xF114 0x0F01      CMN      R4,#+1
   \   0000006C   0xD01F             BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
   1703                {
   1704                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000006E   0x2C00             CMP      R4,#+0
   \   00000070   0xD004             BEQ.N    ??UART_WaitOnFlagUntilTimeout_6
   \   00000072   0x.... 0x....      BL       HAL_GetTick
   \   00000076   0x1BC0             SUBS     R0,R0,R7
   \   00000078   0x4284             CMP      R4,R0
   \   0000007A   0xD218             BCS.N    ??UART_WaitOnFlagUntilTimeout_0
   1705                  {
   1706                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1707                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_6: (+1)
   \   0000007C   0x6828             LDR      R0,[R5, #+0]
   \   0000007E   0x68C1             LDR      R1,[R0, #+12]
   \   00000080   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000084   0x60C1             STR      R1,[R0, #+12]
   1708                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   00000086   0x6828             LDR      R0,[R5, #+0]
   \   00000088   0x68C1             LDR      R1,[R0, #+12]
   \   0000008A   0xF021 0x0120      BIC      R1,R1,#0x20
   \   0000008E   0x60C1             STR      R1,[R0, #+12]
   1709                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   00000090   0x6828             LDR      R0,[R5, #+0]
   \   00000092   0x68C1             LDR      R1,[R0, #+12]
   \   00000094   0xF421 0x7180      BIC      R1,R1,#0x100
   \   00000098   0x60C1             STR      R1,[R0, #+12]
   1710                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   0000009A   0x6828             LDR      R0,[R5, #+0]
   \   0000009C   0x6941             LDR      R1,[R0, #+20]
   \   0000009E   0x0849             LSRS     R1,R1,#+1
   \   000000A0   0x0049             LSLS     R1,R1,#+1
   \   000000A2   0x6141             STR      R1,[R0, #+20]
   1711          
   1712                    huart->State= HAL_UART_STATE_READY;
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xF885 0x0039      STRB     R0,[R5, #+57]
   1713          
   1714                    /* Process Unlocked */
   1715                    __HAL_UNLOCK(huart);
   1716          
   1717                    return HAL_TIMEOUT;
   \   000000AA   0x2003             MOVS     R0,#+3
   \   000000AC   0xE005             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1718                  }
   1719                }
   1720              }
   \                     ??UART_WaitOnFlagUntilTimeout_0: (+1)
   \   000000AE   0x6828             LDR      R0,[R5, #+0]
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x4030             ANDS     R0,R6,R0
   \   000000B4   0x42B0             CMP      R0,R6
   \   000000B6   0xD0D7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_5
   1721            }
   1722            return HAL_OK;
   \                     ??UART_WaitOnFlagUntilTimeout_2: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_4: (+1)
   \   000000BA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1723          }
   1724          
   1725          /**
   1726            * @brief  Sends an amount of data in non blocking mode.
   1727            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1728            *                the configuration information for the specified UART module.
   1729            * @retval HAL status
   1730            */

   \                                 In section .text, align 2, keep-with-next
   1731          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
   1732          {
   1733            uint16_t* tmp;
   1734            uint32_t tmp_state = 0;
   1735            
   1736            tmp_state = huart->State;
   \                     UART_Transmit_IT: (+1)
   \   00000000   0xF990 0x1039      LDRSB    R1,[R0, #+57]
   1737            if((tmp_state == HAL_UART_STATE_BUSY_TX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
   \   00000004   0x2912             CMP      R1,#+18
   \   00000006   0xD001             BEQ.N    ??UART_Transmit_IT_0
   \   00000008   0x2932             CMP      R1,#+50
   \   0000000A   0xD12A             BNE.N    ??UART_Transmit_IT_1
   1738            {
   1739              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \                     ??UART_Transmit_IT_0: (+1)
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0x6882             LDR      R2,[R0, #+8]
   \   00000010   0xF5B2 0x5F80      CMP      R2,#+4096
   \   00000014   0xD10E             BNE.N    ??UART_Transmit_IT_2
   1740              {
   1741                tmp = (uint16_t*) huart->pTxBuffPtr;
   1742                huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
   \   00000016   0x8809             LDRH     R1,[R1, #+0]
   \   00000018   0xF3C1 0x0108      UBFX     R1,R1,#+0,#+9
   \   0000001C   0x6802             LDR      R2,[R0, #+0]
   \   0000001E   0x6051             STR      R1,[R2, #+4]
   1743                if(huart->Init.Parity == UART_PARITY_NONE)
   \   00000020   0x6A02             LDR      R2,[R0, #+32]
   \   00000022   0x6901             LDR      R1,[R0, #+16]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD102             BNE.N    ??UART_Transmit_IT_3
   1744                {
   1745                  huart->pTxBuffPtr += 2;
   \   00000028   0x1C91             ADDS     R1,R2,#+2
   \   0000002A   0x6201             STR      R1,[R0, #+32]
   \   0000002C   0xE007             B.N      ??UART_Transmit_IT_4
   1746                }
   1747                else
   1748                {
   1749                  huart->pTxBuffPtr += 1;
   \                     ??UART_Transmit_IT_3: (+1)
   \   0000002E   0x1C51             ADDS     R1,R2,#+1
   \   00000030   0x6201             STR      R1,[R0, #+32]
   \   00000032   0xE004             B.N      ??UART_Transmit_IT_4
   1750                }
   1751              } 
   1752              else
   1753              {
   1754                huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
   \                     ??UART_Transmit_IT_2: (+1)
   \   00000034   0x1C4A             ADDS     R2,R1,#+1
   \   00000036   0x6202             STR      R2,[R0, #+32]
   \   00000038   0x7809             LDRB     R1,[R1, #+0]
   \   0000003A   0x6802             LDR      R2,[R0, #+0]
   \   0000003C   0x6051             STR      R1,[R2, #+4]
   1755              }
   1756          
   1757              if(--huart->TxXferCount == 0)
   \                     ??UART_Transmit_IT_4: (+1)
   \   0000003E   0x8CC1             LDRH     R1,[R0, #+38]
   \   00000040   0x1E49             SUBS     R1,R1,#+1
   \   00000042   0x84C1             STRH     R1,[R0, #+38]
   \   00000044   0xB289             UXTH     R1,R1
   \   00000046   0x2900             CMP      R1,#+0
   \   00000048   0xD109             BNE.N    ??UART_Transmit_IT_5
   1758              {
   1759                /* Disable the UART Transmit Complete Interrupt */
   1760                __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x68CA             LDR      R2,[R1, #+12]
   \   0000004E   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000052   0x60CA             STR      R2,[R1, #+12]
   1761          
   1762                /* Enable the UART Transmit Complete Interrupt */    
   1763                __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x68C1             LDR      R1,[R0, #+12]
   \   00000058   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000005C   0x60C1             STR      R1,[R0, #+12]
   1764              }
   1765              return HAL_OK;
   \                     ??UART_Transmit_IT_5: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x4770             BX       LR
   1766            }
   1767            else
   1768            {
   1769              return HAL_BUSY;
   \                     ??UART_Transmit_IT_1: (+1)
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x4770             BX       LR               ;; return
   1770            }
   1771          }
   1772          
   1773          
   1774          /**
   1775            * @brief  Wraps up transmission in non blocking mode.
   1776            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1777            *                the configuration information for the specified UART module.
   1778            * @retval HAL status
   1779            */

   \                                 In section .text, align 2, keep-with-next
   1780          static HAL_StatusTypeDef UART_EndTransmit_IT(BspUartDataType *uDataType)
   1781          {
   \                     UART_EndTransmit_IT: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1782            UART_HandleTypeDef *huart = &uDataType->handle;
   1783            /* Disable the UART Transmit Complete Interrupt */    
   1784            __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
   \   00000002   0x6B81             LDR      R1,[R0, #+56]
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000000A   0x60CA             STR      R2,[R1, #+12]
   1785            
   1786            /* Check if a receive process is ongoing or not */
   1787            if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   0000000C   0xF990 0x1071      LDRSB    R1,[R0, #+113]
   \   00000010   0x2932             CMP      R1,#+50
   \   00000012   0xD103             BNE.N    ??UART_EndTransmit_IT_0
   1788            {
   1789              huart->State = HAL_UART_STATE_BUSY_RX;
   \   00000014   0x2122             MOVS     R1,#+34
   \   00000016   0xF880 0x1071      STRB     R1,[R0, #+113]
   \   0000001A   0xE002             B.N      ??UART_EndTransmit_IT_1
   1790            }
   1791            else
   1792            {
   1793              huart->State = HAL_UART_STATE_READY;
   \                     ??UART_EndTransmit_IT_0: (+1)
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0xF880 0x1071      STRB     R1,[R0, #+113]
   1794            }
   1795            
   1796            HAL_UART_TxCpltCallback(uDataType);
   \                     ??UART_EndTransmit_IT_1: (+1)
   \   00000022   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1797            
   1798            return HAL_OK;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
   1799          }
   1800          
   1801          /**
   1802            * @brief  Receives an amount of data in non blocking mode 
   1803            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1804            *                the configuration information for the specified UART module.
   1805            * @retval HAL status
   1806            */

   \                                 In section .text, align 2, keep-with-next
   1807          static HAL_StatusTypeDef UART_Receive_IT(BspUartDataType *uDataType)
   1808          {
   \                     UART_Receive_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4601             MOV      R1,R0
   1809            uint16_t* tmp;
   1810            uint32_t tmp_state = 0;
   1811          
   1812            UART_HandleTypeDef *huart = &uDataType->handle;
   1813            
   1814            tmp_state = huart->State; 
   \   00000004   0xF101 0x0266      ADD      R2,R1,#+102
   \   00000008   0xF992 0x000B      LDRSB    R0,[R2, #+11]
   1815            if((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
   \   0000000C   0x2822             CMP      R0,#+34
   \   0000000E   0xD001             BEQ.N    ??UART_Receive_IT_0
   \   00000010   0x2832             CMP      R0,#+50
   \   00000012   0xD14B             BNE.N    ??UART_Receive_IT_1
   1816            {
   1817              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \                     ??UART_Receive_IT_0: (+1)
   \   00000014   0x6C88             LDR      R0,[R1, #+72]
   \   00000016   0x6E0B             LDR      R3,[R1, #+96]
   \   00000018   0x6C0C             LDR      R4,[R1, #+64]
   \   0000001A   0xF5B4 0x5F80      CMP      R4,#+4096
   \   0000001E   0xD111             BNE.N    ??UART_Receive_IT_2
   1818              {
   1819                tmp = (uint16_t*) huart->pRxBuffPtr;
   1820                if(huart->Init.Parity == UART_PARITY_NONE)
   \   00000020   0x6B8C             LDR      R4,[R1, #+56]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0x6860             LDR      R0,[R4, #+4]
   \   00000026   0xD106             BNE.N    ??UART_Receive_IT_3
   1821                {
   1822                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \   00000028   0xF3C0 0x0008      UBFX     R0,R0,#+0,#+9
   \   0000002C   0x8018             STRH     R0,[R3, #+0]
   1823                  huart->pRxBuffPtr += 2;
   \   0000002E   0x6E08             LDR      R0,[R1, #+96]
   \   00000030   0x1C80             ADDS     R0,R0,#+2
   \   00000032   0x6608             STR      R0,[R1, #+96]
   \   00000034   0xE015             B.N      ??UART_Receive_IT_4
   1824                }
   1825                else
   1826                {
   1827                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \                     ??UART_Receive_IT_3: (+1)
   \   00000036   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   0000003A   0x8018             STRH     R0,[R3, #+0]
   1828                  huart->pRxBuffPtr += 1;
   \   0000003C   0x6E08             LDR      R0,[R1, #+96]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x6608             STR      R0,[R1, #+96]
   \   00000042   0xE00E             B.N      ??UART_Receive_IT_4
   1829                }
   1830              }
   1831              else
   1832              {
   1833                if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??UART_Receive_IT_2: (+1)
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD105             BNE.N    ??UART_Receive_IT_5
   1834                {
   1835                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \   00000048   0x1C58             ADDS     R0,R3,#+1
   \   0000004A   0x6608             STR      R0,[R1, #+96]
   \   0000004C   0x6B88             LDR      R0,[R1, #+56]
   \   0000004E   0x6840             LDR      R0,[R0, #+4]
   \   00000050   0x7018             STRB     R0,[R3, #+0]
   \   00000052   0xE006             B.N      ??UART_Receive_IT_4
   1836                }
   1837                else
   1838                {
   1839                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??UART_Receive_IT_5: (+1)
   \   00000054   0x1C58             ADDS     R0,R3,#+1
   \   00000056   0x6608             STR      R0,[R1, #+96]
   \   00000058   0x6B88             LDR      R0,[R1, #+56]
   \   0000005A   0x6840             LDR      R0,[R0, #+4]
   \   0000005C   0xF000 0x007F      AND      R0,R0,#0x7F
   \   00000060   0x7018             STRB     R0,[R3, #+0]
   1840                }
   1841              }
   1842          
   1843              if(--huart->RxXferCount == 0)
   \                     ??UART_Receive_IT_4: (+1)
   \   00000062   0x8810             LDRH     R0,[R2, #+0]
   \   00000064   0x1E40             SUBS     R0,R0,#+1
   \   00000066   0x8010             STRH     R0,[R2, #+0]
   \   00000068   0xB280             UXTH     R0,R0
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD11C             BNE.N    ??UART_Receive_IT_6
   1844              {
   1845                __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   0000006E   0x6B88             LDR      R0,[R1, #+56]
   \   00000070   0x68C3             LDR      R3,[R0, #+12]
   \   00000072   0xF023 0x0320      BIC      R3,R3,#0x20
   \   00000076   0x60C3             STR      R3,[R0, #+12]
   1846          
   1847                /* Check if a transmit process is ongoing or not */
   1848                if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   00000078   0xF992 0x000B      LDRSB    R0,[R2, #+11]
   \   0000007C   0x2832             CMP      R0,#+50
   \   0000007E   0xD102             BNE.N    ??UART_Receive_IT_7
   1849                {
   1850                  huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000080   0x2012             MOVS     R0,#+18
   \   00000082   0x72D0             STRB     R0,[R2, #+11]
   \   00000084   0xE00B             B.N      ??UART_Receive_IT_8
   1851                }
   1852                else
   1853                {
   1854                  /* Disable the UART Parity Error Interrupt */
   1855                  __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \                     ??UART_Receive_IT_7: (+1)
   \   00000086   0x6B88             LDR      R0,[R1, #+56]
   \   00000088   0x68C3             LDR      R3,[R0, #+12]
   \   0000008A   0xF423 0x7380      BIC      R3,R3,#0x100
   \   0000008E   0x60C3             STR      R3,[R0, #+12]
   1856          
   1857                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1858                  __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   00000090   0x6B88             LDR      R0,[R1, #+56]
   \   00000092   0x6943             LDR      R3,[R0, #+20]
   \   00000094   0x085B             LSRS     R3,R3,#+1
   \   00000096   0x005B             LSLS     R3,R3,#+1
   \   00000098   0x6143             STR      R3,[R0, #+20]
   1859          
   1860                  huart->State = HAL_UART_STATE_READY;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x72D0             STRB     R0,[R2, #+11]
   1861                }
   1862                HAL_UART_RxCpltCallback(uDataType);
   \                     ??UART_Receive_IT_8: (+1)
   \   0000009E   0x4608             MOV      R0,R1
   \   000000A0   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1863          
   1864                return HAL_OK;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xBD10             POP      {R4,PC}
   1865              }
   1866              return HAL_OK;
   \                     ??UART_Receive_IT_6: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xBD10             POP      {R4,PC}
   1867            }
   1868            else
   1869            {
   1870              return HAL_BUSY; 
   \                     ??UART_Receive_IT_1: (+1)
   \   000000AC   0x2002             MOVS     R0,#+2
   \   000000AE   0xBD10             POP      {R4,PC}          ;; return
   1871            }
   1872          }
   1873          
   1874          /**
   1875            * @brief  Configures the UART peripheral. 
   1876            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1877            *                the configuration information for the specified UART module.
   1878            * @retval None
   1879            */

   \                                 In section .text, align 2, keep-with-next
   1880          static void UART_SetConfig(UART_HandleTypeDef *huart)
   1881          {
   \                     UART_SetConfig: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   1882            uint32_t tmpreg = 0x00;
   1883            
   1884            /* Check the parameters */
   1885            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));  
   1886            assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   1887            assert_param(IS_UART_PARITY(huart->Init.Parity));
   1888            assert_param(IS_UART_MODE(huart->Init.Mode));
   1889          
   1890            /*------- UART-associated USART registers setting : CR2 Configuration ------*/
   1891            /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   1892             * to huart->Init.StopBits value */
   1893            MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
   \   00000006   0x6821             LDR      R1,[R4, #+0]
   \   00000008   0x690A             LDR      R2,[R1, #+16]
   \   0000000A   0xF422 0x5240      BIC      R2,R2,#0x3000
   \   0000000E   0x68E0             LDR      R0,[R4, #+12]
   \   00000010   0x4302             ORRS     R2,R0,R2
   \   00000012   0x610A             STR      R2,[R1, #+16]
   1894          
   1895            /*------- UART-associated USART registers setting : CR1 Configuration ------*/
   1896            /* Configure the UART Word Length, Parity and mode: 
   1897               Set the M bits according to huart->Init.WordLength value 
   1898               Set PCE and PS bits according to huart->Init.Parity value
   1899               Set TE and RE bits according to huart->Init.Mode value */
   1900            tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode ;
   1901            MODIFY_REG(huart->Instance->CR1, 
   1902                       (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE), 
   1903                       tmpreg);
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x68CA             LDR      R2,[R1, #+12]
   \   00000018   0x....             LDR.N    R0,??DataTable1  ;; 0xffffe9f3
   \   0000001A   0x4002             ANDS     R2,R0,R2
   \   0000001C   0x68A0             LDR      R0,[R4, #+8]
   \   0000001E   0x4302             ORRS     R2,R0,R2
   \   00000020   0x6920             LDR      R0,[R4, #+16]
   \   00000022   0x4302             ORRS     R2,R0,R2
   \   00000024   0x6960             LDR      R0,[R4, #+20]
   \   00000026   0x4302             ORRS     R2,R0,R2
   \   00000028   0x60CA             STR      R2,[R1, #+12]
   1904            
   1905            /*------- UART-associated USART registers setting : CR3 Configuration ------*/
   1906            /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
   1907            MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x694A             LDR      R2,[R1, #+20]
   \   0000002E   0xF422 0x7240      BIC      R2,R2,#0x300
   \   00000032   0x69A0             LDR      R0,[R4, #+24]
   \   00000034   0x4302             ORRS     R2,R0,R2
   \   00000036   0x614A             STR      R2,[R1, #+20]
   1908            
   1909            /*------- UART-associated USART registers setting : BRR Configuration ------*/
   1910            if((huart->Instance == USART1))
   \   00000038   0x2564             MOVS     R5,#+100
   \   0000003A   0x2619             MOVS     R6,#+25
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x....             LDR.N    R1,??DataTable1_1  ;; 0x40013800
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD142             BNE.N    ??UART_SetConfig_0
   1911            {
   1912              huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \   00000044   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000048   0x4607             MOV      R7,R0
   \   0000004A   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000004E   0x4680             MOV      R8,R0
   \   00000050   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000054   0x4681             MOV      R9,R0
   \   00000056   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000005A   0x4682             MOV      R10,R0
   \   0000005C   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000060   0x6861             LDR      R1,[R4, #+4]
   \   00000062   0x0089             LSLS     R1,R1,#+2
   \   00000064   0x4377             MULS     R7,R6,R7
   \   00000066   0xFBB7 0xF2F1      UDIV     R2,R7,R1
   \   0000006A   0x462B             MOV      R3,R5
   \   0000006C   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000070   0xFB06 0xF808      MUL      R8,R6,R8
   \   00000074   0xFBB8 0xF3F1      UDIV     R3,R8,R1
   \   00000078   0xFB06 0xF909      MUL      R9,R6,R9
   \   0000007C   0xFBB9 0xF7F1      UDIV     R7,R9,R1
   \   00000080   0x46AC             MOV      R12,R5
   \   00000082   0xFBB7 0xF7FC      UDIV     R7,R7,R12
   \   00000086   0xFB05 0x3317      MLS      R3,R5,R7,R3
   \   0000008A   0x011B             LSLS     R3,R3,#+4
   \   0000008C   0x3332             ADDS     R3,R3,#+50
   \   0000008E   0x462F             MOV      R7,R5
   \   00000090   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   00000094   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   00000098   0xEB03 0x1302      ADD      R3,R3,R2, LSL #+4
   \   0000009C   0xFB06 0xFA0A      MUL      R10,R6,R10
   \   000000A0   0xFBBA 0xF2F1      UDIV     R2,R10,R1
   \   000000A4   0x4346             MULS     R6,R6,R0
   \   000000A6   0xFBB6 0xF0F1      UDIV     R0,R6,R1
   \   000000AA   0x4629             MOV      R1,R5
   \   000000AC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000B0   0xFB05 0x2510      MLS      R5,R5,R0,R2
   \   000000B4   0x012D             LSLS     R5,R5,#+4
   \   000000B6   0x3532             ADDS     R5,R5,#+50
   \   000000B8   0x4608             MOV      R0,R1
   \   000000BA   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   000000BE   0xF000 0x000F      AND      R0,R0,#0xF
   \   000000C2   0x18C3             ADDS     R3,R0,R3
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6083             STR      R3,[R0, #+8]
   \   000000C8   0xE041             B.N      ??UART_SetConfig_1
   1913            }
   1914            else
   1915            {
   1916              huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_0: (+1)
   \   000000CA   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000CE   0x4607             MOV      R7,R0
   \   000000D0   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000D4   0x4680             MOV      R8,R0
   \   000000D6   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000DA   0x4681             MOV      R9,R0
   \   000000DC   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000E0   0x4682             MOV      R10,R0
   \   000000E2   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000E6   0x6861             LDR      R1,[R4, #+4]
   \   000000E8   0x0089             LSLS     R1,R1,#+2
   \   000000EA   0x4377             MULS     R7,R6,R7
   \   000000EC   0xFBB7 0xF2F1      UDIV     R2,R7,R1
   \   000000F0   0x462B             MOV      R3,R5
   \   000000F2   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000000F6   0xFB06 0xF808      MUL      R8,R6,R8
   \   000000FA   0xFBB8 0xF3F1      UDIV     R3,R8,R1
   \   000000FE   0xFB06 0xF909      MUL      R9,R6,R9
   \   00000102   0xFBB9 0xF7F1      UDIV     R7,R9,R1
   \   00000106   0x46AC             MOV      R12,R5
   \   00000108   0xFBB7 0xF7FC      UDIV     R7,R7,R12
   \   0000010C   0xFB05 0x3317      MLS      R3,R5,R7,R3
   \   00000110   0x011B             LSLS     R3,R3,#+4
   \   00000112   0x3332             ADDS     R3,R3,#+50
   \   00000114   0x462F             MOV      R7,R5
   \   00000116   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   0000011A   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   0000011E   0xEB03 0x1302      ADD      R3,R3,R2, LSL #+4
   \   00000122   0xFB06 0xFA0A      MUL      R10,R6,R10
   \   00000126   0xFBBA 0xF2F1      UDIV     R2,R10,R1
   \   0000012A   0x4346             MULS     R6,R6,R0
   \   0000012C   0xFBB6 0xF0F1      UDIV     R0,R6,R1
   \   00000130   0x4629             MOV      R1,R5
   \   00000132   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000136   0xFB05 0x2510      MLS      R5,R5,R0,R2
   \   0000013A   0x012D             LSLS     R5,R5,#+4
   \   0000013C   0x3532             ADDS     R5,R5,#+50
   \   0000013E   0x4608             MOV      R0,R1
   \   00000140   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   00000144   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000148   0x18C3             ADDS     R3,R0,R3
   \   0000014A   0x6820             LDR      R0,[R4, #+0]
   \   0000014C   0x6083             STR      R3,[R0, #+8]
   1917            }
   1918          }
   \                     ??UART_SetConfig_1: (+1)
   \   0000014E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0xFFFFE9F3         DC32     0xffffe9f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40013800         DC32     0x40013800
   1919          /**
   1920            * @}
   1921            */
   1922          
   1923          #endif /* HAL_UART_MODULE_ENABLED */
   1924          /**
   1925            * @}
   1926            */
   1927          
   1928          /**
   1929            * @}
   1930            */
   1931          
   1932          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HalfDuplex_EnableReceiver
       0   HAL_HalfDuplex_EnableTransmitter
      16   HAL_HalfDuplex_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_LIN_SendBreak
       0   HAL_MultiProcessor_EnterMuteMode
       0   HAL_MultiProcessor_ExitMuteMode
      24   HAL_MultiProcessor_Init
        24   -> HAL_UART_MspInit
        24   -> UART_SetConfig
       0   HAL_UART_DMAPause
       4   HAL_UART_DMAResume
       8   HAL_UART_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_UART_DeInit
         8   -> HAL_UART_MspDeInit
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       0   HAL_UART_GetState
      16   HAL_UART_IRQHandler
         0   -> HAL_UART_ErrorCallback
        16   -> UART_EndTransmit_IT
        16   -> UART_Receive_IT
        16   -> UART_Transmit_IT
      16   HAL_UART_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_UART_MspDeInit
       0   HAL_UART_MspInit
      16   HAL_UART_Receive
        16   -> UART_WaitOnFlagUntilTimeout
       8   HAL_UART_Receive_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_UART_Receive_IT
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      16   HAL_UART_Transmit
        16   -> UART_WaitOnFlagUntilTimeout
       0   HAL_UART_Transmit_DMA
       0   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
       0   UART_DMAError
         0   -> HAL_UART_ErrorCallback
       0   UART_DMAReceiveCplt
       0   UART_DMARxHalfCplt
         0   -> HAL_UART_RxHalfCpltCallback
       8   UART_EndTransmit_IT
         8   -> HAL_UART_TxCpltCallback
       8   UART_Receive_IT
         8   -> HAL_UART_RxCpltCallback
      32   UART_SetConfig
        32   -> HAL_RCC_GetPCLK1Freq
        32   -> HAL_RCC_GetPCLK2Freq
       0   UART_Transmit_IT
      24   UART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      30  HAL_HalfDuplex_EnableReceiver
      30  HAL_HalfDuplex_EnableTransmitter
     104  HAL_HalfDuplex_Init
     120  HAL_LIN_Init
      26  HAL_LIN_SendBreak
      26  HAL_MultiProcessor_EnterMuteMode
      26  HAL_MultiProcessor_ExitMuteMode
     124  HAL_MultiProcessor_Init
      66  HAL_UART_DMAPause
      90  HAL_UART_DMAResume
      44  HAL_UART_DMAStop
      56  HAL_UART_DeInit
       2  HAL_UART_ErrorCallback
       4  HAL_UART_GetError
       6  HAL_UART_GetState
     244  HAL_UART_IRQHandler
      94  HAL_UART_Init
       2  HAL_UART_MspDeInit
       2  HAL_UART_MspInit
     200  HAL_UART_Receive
     114  HAL_UART_Receive_DMA
      94  HAL_UART_Receive_IT
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     194  HAL_UART_Transmit
       2  HAL_UART_Transmit_DMA
      74  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
      26  UART_DMAError
       2  UART_DMAReceiveCplt
       6  UART_DMARxHalfCplt
      42  UART_EndTransmit_IT
     176  UART_Receive_IT
     338  UART_SetConfig
     102  UART_Transmit_IT
     190  UART_WaitOnFlagUntilTimeout

 
 2 672 bytes in section .text
 
 2 658 bytes of CODE memory (+ 14 bytes shared)

Errors: none
Warnings: 3
