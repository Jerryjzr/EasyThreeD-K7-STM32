###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  22:13:53
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWEEE7.tmp
#        (F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal.c -D
#        USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\stm32f1xx_hal.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\stm32f1xx_hal.o
#
###############################################################################

F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   HAL module driver.
      8            *          This is the common part of the HAL initialization
      9            *
     10            @verbatim
     11            ==============================================================================
     12                               ##### How to use this driver #####
     13            ==============================================================================
     14              [..]
     15              The common HAL driver contains a set of generic and common APIs that can be
     16              used by the PPP peripheral drivers and the user to start using the HAL. 
     17              [..]
     18              The HAL contains two APIs' categories: 
     19                   (+) Common HAL APIs
     20                   (+) Services HAL APIs
     21          
     22            @endverbatim
     23            ******************************************************************************
     24            * @attention
     25            *
     26            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     27            *
     28            * Redistribution and use in source and binary forms, with or without modification,
     29            * are permitted provided that the following conditions are met:
     30            *   1. Redistributions of source code must retain the above copyright notice,
     31            *      this list of conditions and the following disclaimer.
     32            *   2. Redistributions in binary form must reproduce the above copyright notice,
     33            *      this list of conditions and the following disclaimer in the documentation
     34            *      and/or other materials provided with the distribution.
     35            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     36            *      may be used to endorse or promote products derived from this software
     37            *      without specific prior written permission.
     38            *
     39            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     40            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     41            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     42            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     43            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     44            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     45            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     46            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     47            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     48            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     49            *
     50            ******************************************************************************
     51            */
     52          
     53          /* Includes ------------------------------------------------------------------*/
     54          #include "stm32f1xx_hal.h"
     55          
     56          /** @addtogroup STM32F1xx_HAL_Driver
     57            * @{
     58            */
     59          
     60          /** @defgroup HAL HAL
     61            * @brief HAL module driver.
     62            * @{
     63            */
     64          
     65          #ifdef HAL_MODULE_ENABLED
     66          
     67          /* Private typedef -----------------------------------------------------------*/
     68          /* Private define ------------------------------------------------------------*/
     69          
     70          /** @defgroup HAL_Private_Constants HAL Private Constants
     71            * @{
     72            */
     73          
     74          /**
     75           * @brief STM32F1xx HAL Driver version number
     76             */
     77          #define __STM32F1xx_HAL_VERSION_MAIN   (0x01) /*!< [31:24] main version */
     78          #define __STM32F1xx_HAL_VERSION_SUB1   (0x00) /*!< [23:16] sub1 version */
     79          #define __STM32F1xx_HAL_VERSION_SUB2   (0x04) /*!< [15:8]  sub2 version */
     80          #define __STM32F1xx_HAL_VERSION_RC     (0x00) /*!< [7:0]  release candidate */
     81          #define __STM32F1xx_HAL_VERSION         ((__STM32F1xx_HAL_VERSION_MAIN << 24)\
     82                                                  |(__STM32F1xx_HAL_VERSION_SUB1 << 16)\
     83                                                  |(__STM32F1xx_HAL_VERSION_SUB2 << 8 )\
     84                                                  |(__STM32F1xx_HAL_VERSION_RC))
     85          
     86          #define IDCODE_DEVID_MASK    ((uint32_t)0x00000FFF)
     87          
     88          /**
     89            * @}
     90            */
     91          
     92          /* Private macro -------------------------------------------------------------*/
     93          /* Private variables ---------------------------------------------------------*/
     94          
     95          /** @defgroup HAL_Private_Variables HAL Private Variables
     96            * @{
     97            */
     98          

   \                                 In section .bss, align 4
     99          static __IO uint32_t uwTick;
   \                     uwTick:
   \   00000000                      DS8 4
    100          
    101          /**
    102            * @}
    103            */
    104          
    105          /* Private function prototypes -----------------------------------------------*/
    106          /* Exported functions ---------------------------------------------------------*/
    107          
    108          /** @defgroup HAL_Exported_Functions HAL Exported Functions
    109            * @{
    110            */
    111          
    112          /** @defgroup HAL_Exported_Functions_Group1 Initialization and de-initialization Functions 
    113           *  @brief    Initialization and de-initialization functions
    114           *
    115          @verbatim
    116           ===============================================================================
    117                        ##### Initialization and de-initialization functions #####
    118           ===============================================================================
    119             [..]  This section provides functions allowing to:
    120                (+) Initializes the Flash interface, the NVIC allocation and initial clock 
    121                    configuration. It initializes the source of time base also when timeout 
    122                    is needed and the backup domain when enabled.
    123                (+) de-Initializes common part of the HAL.
    124                (+) Configure The time base source to have 1ms time base with a dedicated 
    125                    Tick interrupt priority. 
    126                  (++) Systick timer is used by default as source of time base, but user 
    127                       can eventually implement his proper time base source (a general purpose 
    128                       timer for example or other time source), keeping in mind that Time base 
    129                       duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
    130                       handled in milliseconds basis.
    131                  (++) Time base configuration function (HAL_InitTick ()) is called automatically 
    132                       at the beginning of the program after reset by HAL_Init() or at any time 
    133                       when clock is configured, by HAL_RCC_ClockConfig(). 
    134                  (++) Source of time base is configured  to generate interrupts at regular 
    135                       time intervals. Care must be taken if HAL_Delay() is called from a 
    136                       peripheral ISR process, the Tick interrupt line must have higher priority 
    137                      (numerically lower) than the peripheral interrupt. Otherwise the caller 
    138                      ISR process will be blocked. 
    139                 (++) functions affecting time base configurations are declared as __Weak  
    140                       to make  override possible  in case of other  implementations in user file.
    141           
    142          @endverbatim
    143            * @{
    144            */
    145          
    146          /**
    147            * @brief This function configures the Flash prefetch, 
    148            *        Configures time base source, NVIC and Low level hardware
    149            * @note This function is called at the beginning of program after reset and before 
    150            *       the clock configuration
    151            * @note The time base configuration is based on MSI clock when exiting from Reset.
    152            *       Once done, time base tick start incrementing.
    153            *        In the default implementation,Systick is used as source of time base.
    154            *       The tick variable is incremented each 1ms in its ISR.
    155            * @retval HAL status
    156            */

   \                                 In section .text, align 2, keep-with-next
    157          HAL_StatusTypeDef HAL_Init(void)
    158          {
   \                     HAL_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    159            /* Configure Flash prefetch */
    160          #if (PREFETCH_ENABLE != 0)
    161          #if defined(STM32F101x6) || defined(STM32F101xB) || defined(STM32F101xE) || defined(STM32F101xG) || \
    162              defined(STM32F102x6) || defined(STM32F102xB) || \
    163              defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    164              defined(STM32F105xC) || defined(STM32F107xC)
    165          
    166            /* Prefetch buffer is not available on value line devices */
    167            __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
   \   00000002   0x....             LDR.N    R0,??DataTable11  ;; 0x40022000
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    168          #endif
    169          #endif /* PREFETCH_ENABLE */
    170          
    171            /* Set Interrupt Group Priority */
    172            HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0x.... 0x....      BL       HAL_NVIC_SetPriorityGrouping
    173          
    174            /* Use systick as time base source and configure 1ms tick (default clock after Reset is MSI) */
    175            HAL_InitTick(TICK_INT_PRIORITY);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       HAL_InitTick
    176          
    177            /* Init the low level hardware */
    178            HAL_MspInit();
   \   00000018   0x.... 0x....      BL       HAL_MspInit
    179          
    180            /* Return function status */
    181            return HAL_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
    182          }
    183          
    184          /**
    185            * @brief This function de-Initializes common part of the HAL and stops the source
    186            *        of time base.
    187            * @note This function is optional.
    188            * @retval HAL status
    189            */

   \                                 In section .text, align 2, keep-with-next
    190          HAL_StatusTypeDef HAL_DeInit(void)
    191          {
   \                     HAL_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    192            /* Reset of all peripherals */
    193            __HAL_RCC_APB1_FORCE_RESET();
   \   00000002   0x....             LDR.N    R0,??DataTable11_1  ;; 0x4002100c
   \   00000004   0xF04F 0x31FF      MOV      R1,#-1
   \   00000008   0x6001             STR      R1,[R0, #+0]
    194            __HAL_RCC_APB1_RELEASE_RESET();
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x6042             STR      R2,[R0, #+4]
    195          
    196            __HAL_RCC_APB2_FORCE_RESET();
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    197            __HAL_RCC_APB2_RELEASE_RESET();
   \   00000010   0x4611             MOV      R1,R2
   \   00000012   0x6001             STR      R1,[R0, #+0]
    198          
    199          #if defined(STM32F105xC) || defined(STM32F107xC)
    200            __HAL_RCC_AHB_FORCE_RESET();
    201            __HAL_RCC_AHB_RELEASE_RESET();
    202          #endif
    203            
    204            /* De-Init the low level hardware */
    205            HAL_MspDeInit();
   \   00000014   0x.... 0x....      BL       HAL_MspDeInit
    206              
    207            /* Return function status */
    208            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
    209          }
    210          
    211          /**
    212            * @brief  Initializes the MSP.
    213            * @retval None
    214            */

   \                                 In section .text, align 2
    215          __weak void HAL_MspInit(void)
    216          {
    217            /* NOTE : This function Should not be modified, when the callback is needed,
    218                      the HAL_MspInit could be implemented in the user file
    219             */
    220          }
   \                     HAL_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    221          
    222          /**
    223            * @brief  DeInitializes the MSP.
    224            * @retval None
    225            */

   \                                 In section .text, align 2
    226          __weak void HAL_MspDeInit(void)
    227          {
    228            /* NOTE : This function Should not be modified, when the callback is needed,
    229                      the HAL_MspDeInit could be implemented in the user file
    230             */
    231          }
   \                     HAL_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    232          
    233          /**
    234            * @brief This function configures the source of the time base. 
    235            *        The time source is configured  to have 1ms time base with a dedicated 
    236            *        Tick interrupt priority.
    237            * @note This function is called  automatically at the beginning of program after
    238            *       reset by HAL_Init() or at any time when clock is reconfigured  by HAL_RCC_ClockConfig(). 
    239            * @note In the default implementation, SysTick timer is the source of time base. 
    240            *       It is used to generate interrupts at regular time intervals. 
    241            *       Care must be taken if HAL_Delay() is called from a peripheral ISR process, 
    242            *       The the SysTick interrupt must have higher priority (numerically lower) 
    243            *       than the peripheral interrupt. Otherwise the caller ISR process will be blocked.
    244            *       The function is declared as __Weak  to be overwritten  in case of other
    245            *       implementation  in user file.
    246            * @param TickPriority: Tick interrupt priority.
    247            * @retval HAL status
    248            */

   \                                 In section .text, align 2
    249          __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
    250          {
   \                     HAL_InitTick: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    251            /*Configure the SysTick to have interrupt in 1ms time basis*/
    252            HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
   \   00000004   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000008   0xF44F 0x717A      MOV      R1,#+1000
   \   0000000C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000010   0x.... 0x....      BL       HAL_SYSTICK_Config
    253          
    254            /*Configure the SysTick IRQ priority */
    255            HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001C   0x.... 0x....      BL       HAL_NVIC_SetPriority
    256          
    257             /* Return function status */
    258            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    259          }
    260          
    261          /**
    262            * @}
    263            */
    264          
    265          /** @defgroup HAL_Exported_Functions_Group2 HAL Control functions 
    266           *  @brief    HAL Control functions
    267           *
    268          @verbatim
    269           ===============================================================================
    270                                ##### HAL Control functions #####
    271           ===============================================================================
    272              [..]  This section provides functions allowing to:
    273                (+) Provide a tick value in millisecond
    274                (+) Provide a blocking delay in millisecond
    275                (+) Suspend the time base source interrupt
    276                (+) Resume the time base source interrupt
    277                (+) Get the HAL API driver version
    278                (+) Get the device identifier
    279                (+) Get the device revision identifier
    280                (+) Enable/Disable Debug module during Sleep mode
    281                (+) Enable/Disable Debug module during STOP mode
    282                (+) Enable/Disable Debug module during STANDBY mode
    283                
    284          @endverbatim
    285            * @{
    286            */
    287          
    288          /**
    289            * @brief This function is called to increment  a global variable "uwTick"
    290            *        used as application time base.
    291            * @note In the default implementation, this variable is incremented each 1ms
    292            *       in Systick ISR.
    293            * @note This function is declared as __weak to be overwritten in case of other 
    294            *      implementations in user file.
    295            * @retval None
    296            */

   \                                 In section .text, align 4
    297          __weak void HAL_IncTick(void)
    298          {
    299            uwTick++;
   \                     HAL_IncTick: (+1)
   \   00000000   0x4802             LDR.N    R0,??HAL_IncTick_0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0x6001             STR      R1,[R0, #+0]
    300          }
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??HAL_IncTick_0:
   \   0000000C   0x........         DC32     uwTick
    301          
    302          /**
    303            * @brief Provides a tick value in millisecond.
    304            * @note   This function is declared as __weak  to be overwritten  in case of other 
    305            *       implementations in user file.
    306            * @retval tick value
    307            */

   \                                 In section .text, align 4
    308          __weak uint32_t HAL_GetTick(void)
    309          {
    310            return uwTick;
   \                     HAL_GetTick: (+1)
   \   00000000   0x4801             LDR.N    R0,??HAL_GetTick_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??HAL_GetTick_0:
   \   00000008   0x........         DC32     uwTick
    311          }
    312          

   \                                 In section .text, align 4
    313          __weak void HAL_SetTick(uint32_t setTick)
    314          {
    315             uwTick = setTick;
   \                     HAL_SetTick: (+1)
   \   00000000   0x4901             LDR.N    R1,??HAL_SetTick_0
   \   00000002   0x6008             STR      R0,[R1, #+0]
    316          }
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??HAL_SetTick_0:
   \   00000008   0x........         DC32     uwTick
    317          
    318          /**
    319            * @brief This function provides accurate delay (in milliseconds) based 
    320            *        on variable incremented.
    321            * @note In the default implementation , SysTick timer is the source of time base.
    322            *       It is used to generate interrupts at regular time intervals where uwTick
    323            *       is incremented.
    324            * @note ThiS function is declared as __weak to be overwritten in case of other
    325            *       implementations in user file.
    326            * @param Delay: specifies the delay time length, in milliseconds.
    327            * @retval None
    328            */

   \                                 In section .text, align 2
    329          __weak void HAL_Delay(__IO uint32_t Delay)
    330          {
   \                     HAL_Delay: (+1)
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    331            uint32_t tickstart = 0;
    332            tickstart = HAL_GetTick();
   \   00000004   0x.... 0x....      BL       HAL_GetTick
   \   00000008   0x4604             MOV      R4,R0
    333            while((HAL_GetTick() - tickstart) < Delay)
   \                     ??HAL_Delay_0: (+1)
   \   0000000A   0x.... 0x....      BL       HAL_GetTick
   \   0000000E   0x1B00             SUBS     R0,R0,R4
   \   00000010   0x9901             LDR      R1,[SP, #+4]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD3F9             BCC.N    ??HAL_Delay_0
    334            {
    335            }
    336          }
   \   00000016   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    337          
    338          
    339          #define CPU_FREQUENCY_MHZ    72
    340          
    341          //static __IO uint32_t TimingDelay;
    342          
    343          /* Private function prototypes -----------------------------------------------*/
    344          
    345          

   \                                 In section .text, align 2, keep-with-next
    346          void HAL_Delay_us(__IO uint32_t nTime)
    347          {
   \                     HAL_Delay_us: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    348              volatile int old_val,new_val,val;
    349          
    350              if(nTime > 900)
   \   00000004   0x9804             LDR      R0,[SP, #+16]
   \   00000006   0xF5B0 0x7F61      CMP      R0,#+900
   \   0000000A   0xD917             BLS.N    ??HAL_Delay_us_0
    351              {
    352                  for(old_val = 0; old_val < nTime/900; old_val++)
                                          ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0xE005             B.N      ??HAL_Delay_us_1
    353                  {
    354                      HAL_Delay_us(900);
   \                     ??HAL_Delay_us_2: (+1)
   \   00000012   0x4610             MOV      R0,R2
   \   00000014   0xF7FF 0xFFF4      BL       HAL_Delay_us
    355                  }
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   \                     ??HAL_Delay_us_1: (+1)
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x9904             LDR      R1,[SP, #+16]
   \   00000022   0xF44F 0x7261      MOV      R2,#+900
   \   00000026   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD3F1             BCC.N    ??HAL_Delay_us_2
    356                  nTime = nTime%900;
   \   0000002E   0x9904             LDR      R1,[SP, #+16]
   \   00000030   0x4610             MOV      R0,R2
   \   00000032   0xFBB1 0xF2F0      UDIV     R2,R1,R0
   \   00000036   0xFB00 0x1112      MLS      R1,R0,R2,R1
   \   0000003A   0x9104             STR      R1,[SP, #+16]
    357              }
    358          
    359              old_val = SysTick->VAL;
   \                     ??HAL_Delay_us_0: (+1)
   \   0000003C   0x....             LDR.N    R1,??DataTable11_2  ;; 0xe000e018
   \   0000003E   0x6808             LDR      R0,[R1, #+0]
   \   00000040   0x9000             STR      R0,[SP, #+0]
    360              new_val = old_val - CPU_FREQUENCY_MHZ*nTime;
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   00000042   0x9800             LDR      R0,[SP, #+0]
   \   00000044   0x9A04             LDR      R2,[SP, #+16]
   \   00000046   0xEB02 0x03C2      ADD      R3,R2,R2, LSL #+3
   \   0000004A   0xEBA0 0x00C3      SUB      R0,R0,R3, LSL #+3
   \   0000004E   0x9001             STR      R0,[SP, #+4]
    361              if(new_val >= 0)
   \   00000050   0x9801             LDR      R0,[SP, #+4]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD40B             BMI.N    ??HAL_Delay_us_3
    362              {
    363                  do
    364                  {
    365                      val = SysTick->VAL;
   \                     ??HAL_Delay_us_4: (+1)
   \   00000056   0x6808             LDR      R0,[R1, #+0]
   \   00000058   0x9002             STR      R0,[SP, #+8]
    366                  }
    367                  while((val < old_val)&&(val >= new_val));
                              ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   0000005A   0x9802             LDR      R0,[SP, #+8]
   \   0000005C   0x9A00             LDR      R2,[SP, #+0]
   \   0000005E   0x4290             CMP      R0,R2
   \   00000060   0xDA03             BGE.N    ??HAL_Delay_us_5
   \   00000062   0x9802             LDR      R0,[SP, #+8]
   \   00000064   0x9A01             LDR      R2,[SP, #+4]
   \   00000066   0x4290             CMP      R0,R2
   \   00000068   0xDAF5             BGE.N    ??HAL_Delay_us_4
    368              }
    369              else
    370              {
    371                  new_val +=CPU_FREQUENCY_MHZ*1000;
    372                  do
    373                  {
    374                      val = SysTick->VAL;
    375                  }
    376                  while((val <= old_val)||(val > new_val));
                              ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
    377          
    378              }
    379          }
   \                     ??HAL_Delay_us_5: (+1)
   \   0000006A   0xB005             ADD      SP,SP,#+20
   \   0000006C   0xBD00             POP      {PC}             ;; return
   \                     ??HAL_Delay_us_3: (+1)
   \   0000006E   0x9A01             LDR      R2,[SP, #+4]
   \   00000070   0x....             LDR.N    R0,??DataTable11_3  ;; 0x11940
   \   00000072   0x1882             ADDS     R2,R0,R2
   \   00000074   0x9201             STR      R2,[SP, #+4]
   \                     ??HAL_Delay_us_6: (+1)
   \   00000076   0x6808             LDR      R0,[R1, #+0]
   \   00000078   0x9002             STR      R0,[SP, #+8]
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x9A02             LDR      R2,[SP, #+8]
   \   0000007E   0x4290             CMP      R0,R2
   \   00000080   0xDAF9             BGE.N    ??HAL_Delay_us_6
   \   00000082   0x9801             LDR      R0,[SP, #+4]
   \   00000084   0x9A02             LDR      R2,[SP, #+8]
   \   00000086   0x4290             CMP      R0,R2
   \   00000088   0xDBF5             BLT.N    ??HAL_Delay_us_6
   \   0000008A   0xE7EE             B.N      ??HAL_Delay_us_5
    380          
    381          
    382          
    383          /**
    384            * @brief Suspend Tick increment.
    385            * @note In the default implementation , SysTick timer is the source of time base. It is
    386            *       used to generate interrupts at regular time intervals. Once HAL_SuspendTick()
    387            *       is called, the the SysTick interrupt will be disabled and so Tick increment 
    388            *       is suspended.
    389            * @note This function is declared as __weak to be overwritten in case of other
    390            *       implementations in user file.
    391            * @retval None
    392            */

   \                                 In section .text, align 4
    393          __weak void HAL_SuspendTick(void)
    394          {
    395            /* Disable SysTick Interrupt */
    396            CLEAR_BIT(SysTick->CTRL,SysTick_CTRL_TICKINT_Msk);
   \                     HAL_SuspendTick: (+1)
   \   00000000   0x4802             LDR.N    R0,??HAL_SuspendTick_0  ;; 0xe000e010
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000008   0x6001             STR      R1,[R0, #+0]
    397          }
   \   0000000A   0x4770             BX       LR               ;; return
   \                     ??HAL_SuspendTick_0:
   \   0000000C   0xE000E010         DC32     0xe000e010
    398          
    399          /**
    400            * @brief Resume Tick increment.
    401            * @note In the default implementation , SysTick timer is the source of time base. It is
    402            *       used to generate interrupts at regular time intervals. Once HAL_ResumeTick()
    403            *       is called, the the SysTick interrupt will be enabled and so Tick increment 
    404            *       is resumed.
    405            * @note This function is declared as __weak  to be overwritten  in case of other
    406            *       implementations in user file.
    407            * @retval None
    408            */

   \                                 In section .text, align 4
    409          __weak void HAL_ResumeTick(void)
    410          {
    411            /* Enable SysTick Interrupt */
    412            SET_BIT(SysTick->CTRL,SysTick_CTRL_TICKINT_Msk);
   \                     HAL_ResumeTick: (+1)
   \   00000000   0x4802             LDR.N    R0,??HAL_ResumeTick_0  ;; 0xe000e010
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000008   0x6001             STR      R1,[R0, #+0]
    413          }
   \   0000000A   0x4770             BX       LR               ;; return
   \                     ??HAL_ResumeTick_0:
   \   0000000C   0xE000E010         DC32     0xe000e010
    414          
    415          /**
    416            * @brief  This method returns the HAL revision
    417            * @retval version: 0xXYZR (8bits for each decimal, R for RC)
    418            */

   \                                 In section .text, align 2, keep-with-next
    419          uint32_t HAL_GetHalVersion(void)
    420          {
    421           return __STM32F1xx_HAL_VERSION;
   \                     HAL_GetHalVersion: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_4  ;; 0x1000400
   \   00000002   0x4770             BX       LR               ;; return
    422          }
    423          
    424          /**
    425            * @brief Returns the device revision identifier.
    426            * Note: On devices STM32F10xx8 and STM32F10xxB,
    427            *                  STM32F101xC/D/E and STM32F103xC/D/E,
    428            *                  STM32F101xF/G and STM32F103xF/G
    429            *                  STM32F10xx4 and STM32F10xx6
    430            *       Debug registers DBGMCU_IDCODE and DBGMCU_CR are accessible only in 
    431            *       debug mode (not accessible by the user software in normal mode).
    432            *       Refer to errata sheet of these devices for more details.
    433            * @retval Device revision identifier
    434            */

   \                                 In section .text, align 2, keep-with-next
    435          uint32_t HAL_GetREVID(void)
    436          {
    437            return((DBGMCU->IDCODE) >> POSITION_VAL(DBGMCU_IDCODE_REV_ID));
   \                     HAL_GetREVID: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_5  ;; 0xe0042000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0C00             LSRS     R0,R0,#+16
   \   00000006   0x4770             BX       LR               ;; return
    438          }
    439          
    440          /**
    441            * @brief  Returns the device identifier.
    442            * Note: On devices STM32F10xx8 and STM32F10xxB,
    443            *                  STM32F101xC/D/E and STM32F103xC/D/E,
    444            *                  STM32F101xF/G and STM32F103xF/G
    445            *                  STM32F10xx4 and STM32F10xx6
    446            *       Debug registers DBGMCU_IDCODE and DBGMCU_CR are accessible only in 
    447            *       debug mode (not accessible by the user software in normal mode).
    448            *       Refer to errata sheet of these devices for more details.
    449            * @retval Device identifier
    450            */

   \                                 In section .text, align 2, keep-with-next
    451          uint32_t HAL_GetDEVID(void)
    452          {
    453             return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
   \                     HAL_GetDEVID: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_5  ;; 0xe0042000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF3C0 0x000B      UBFX     R0,R0,#+0,#+12
   \   00000008   0x4770             BX       LR               ;; return
    454          }
    455          
    456          /**
    457            * @brief  Enable the Debug Module during SLEEP mode
    458            * @retval None
    459            */

   \                                 In section .text, align 2, keep-with-next
    460          void HAL_DBGMCU_EnableDBGSleepMode(void)
    461          {
    462            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
   \                     HAL_DBGMCU_EnableDBGSleepMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_6  ;; 0xe0042004
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x6001             STR      R1,[R0, #+0]
    463          }
   \   0000000A   0x4770             BX       LR               ;; return
    464          
    465          /**
    466            * @brief  Disable the Debug Module during SLEEP mode
    467            * Note: On devices STM32F10xx8 and STM32F10xxB,
    468            *                  STM32F101xC/D/E and STM32F103xC/D/E,
    469            *                  STM32F101xF/G and STM32F103xF/G
    470            *                  STM32F10xx4 and STM32F10xx6
    471            *       Debug registers DBGMCU_IDCODE and DBGMCU_CR are accessible only in 
    472            *       debug mode (not accessible by the user software in normal mode).
    473            *       Refer to errata sheet of these devices for more details.
    474            * @retval None
    475            */

   \                                 In section .text, align 2, keep-with-next
    476          void HAL_DBGMCU_DisableDBGSleepMode(void)
    477          {
    478            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
   \                     HAL_DBGMCU_DisableDBGSleepMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_6  ;; 0xe0042004
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x0849             LSRS     R1,R1,#+1
   \   00000006   0x0049             LSLS     R1,R1,#+1
   \   00000008   0x6001             STR      R1,[R0, #+0]
    479          }
   \   0000000A   0x4770             BX       LR               ;; return
    480          
    481          /**
    482            * @brief  Enable the Debug Module during STOP mode
    483            * Note: On devices STM32F10xx8 and STM32F10xxB,
    484            *                  STM32F101xC/D/E and STM32F103xC/D/E,
    485            *                  STM32F101xF/G and STM32F103xF/G
    486            *                  STM32F10xx4 and STM32F10xx6
    487            *       Debug registers DBGMCU_IDCODE and DBGMCU_CR are accessible only in 
    488            *       debug mode (not accessible by the user software in normal mode).
    489            *       Refer to errata sheet of these devices for more details.
    490            * Note: On all STM32F1 devices:
    491            *       If the system tick timer interrupt is enabled during the Stop mode 
    492            *       debug (DBG_STOP bit set in the DBGMCU_CR register ), it will wakeup
    493            *       the system from Stop mode.
    494            *       Workaround: To debug the Stop mode, disable the system tick timer 
    495            *       interrupt.
    496            *       Refer to errata sheet of these devices for more details.
    497            * Note: On all STM32F1 devices:
    498            *       If the system tick timer interrupt is enabled during the Stop mode  
    499            *       debug (DBG_STOP bit set in the DBGMCU_CR register ), it will wakeup
    500            *       the system from Stop mode.
    501            *       Workaround: To debug the Stop mode, disable the system tick timer
    502            *       interrupt.
    503            *       Refer to errata sheet of these devices for more details.
    504            * @retval None
    505            */

   \                                 In section .text, align 2, keep-with-next
    506          void HAL_DBGMCU_EnableDBGStopMode(void)
    507          {
    508            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
   \                     HAL_DBGMCU_EnableDBGStopMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_6  ;; 0xe0042004
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000008   0x6001             STR      R1,[R0, #+0]
    509          }
   \   0000000A   0x4770             BX       LR               ;; return
    510          
    511          /**
    512            * @brief  Disable the Debug Module during STOP mode
    513            * Note: On devices STM32F10xx8 and STM32F10xxB,
    514            *                  STM32F101xC/D/E and STM32F103xC/D/E,
    515            *                  STM32F101xF/G and STM32F103xF/G
    516            *                  STM32F10xx4 and STM32F10xx6
    517            *       Debug registers DBGMCU_IDCODE and DBGMCU_CR are accessible only in 
    518            *       debug mode (not accessible by the user software in normal mode).
    519            *       Refer to errata sheet of these devices for more details.
    520            * @retval None
    521            */

   \                                 In section .text, align 2, keep-with-next
    522          void HAL_DBGMCU_DisableDBGStopMode(void)
    523          {
    524            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
   \                     HAL_DBGMCU_DisableDBGStopMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_6  ;; 0xe0042004
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000008   0x6001             STR      R1,[R0, #+0]
    525          }
   \   0000000A   0x4770             BX       LR               ;; return
    526          
    527          /**
    528            * @brief  Enable the Debug Module during STANDBY mode
    529            * Note: On devices STM32F10xx8 and STM32F10xxB,
    530            *                  STM32F101xC/D/E and STM32F103xC/D/E,
    531            *                  STM32F101xF/G and STM32F103xF/G
    532            *                  STM32F10xx4 and STM32F10xx6
    533            *       Debug registers DBGMCU_IDCODE and DBGMCU_CR are accessible only in 
    534            *       debug mode (not accessible by the user software in normal mode).
    535            *       Refer to errata sheet of these devices for more details.
    536            * @retval None
    537            */

   \                                 In section .text, align 2, keep-with-next
    538          void HAL_DBGMCU_EnableDBGStandbyMode(void)
    539          {
    540            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_EnableDBGStandbyMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_6  ;; 0xe0042004
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000008   0x6001             STR      R1,[R0, #+0]
    541          }
   \   0000000A   0x4770             BX       LR               ;; return
    542          
    543          /**
    544            * @brief  Disable the Debug Module during STANDBY mode
    545            * Note: On devices STM32F10xx8 and STM32F10xxB,
    546            *                  STM32F101xC/D/E and STM32F103xC/D/E,
    547            *                  STM32F101xF/G and STM32F103xF/G
    548            *                  STM32F10xx4 and STM32F10xx6
    549            *       Debug registers DBGMCU_IDCODE and DBGMCU_CR are accessible only in 
    550            *       debug mode (not accessible by the user software in normal mode).
    551            *       Refer to errata sheet of these devices for more details.
    552            * @retval None
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          void HAL_DBGMCU_DisableDBGStandbyMode(void)
    555          {
    556            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_DisableDBGStandbyMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_6  ;; 0xe0042004
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000008   0x6001             STR      R1,[R0, #+0]
    557          }
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x4002100C         DC32     0x4002100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0xE000E018         DC32     0xe000e018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x00011940         DC32     0x11940

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x01000400         DC32     0x1000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0xE0042000         DC32     0xe0042000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0xE0042004         DC32     0xe0042004
    558          
    559          /**
    560            * @}
    561            */
    562          
    563          /**
    564            * @}
    565            */
    566          
    567          #endif /* HAL_MODULE_ENABLED */
    568          /**
    569            * @}
    570            */
    571          
    572          /**
    573            * @}
    574            */
    575          
    576          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_DBGMCU_DisableDBGSleepMode
       0   HAL_DBGMCU_DisableDBGStandbyMode
       0   HAL_DBGMCU_DisableDBGStopMode
       0   HAL_DBGMCU_EnableDBGSleepMode
       0   HAL_DBGMCU_EnableDBGStandbyMode
       0   HAL_DBGMCU_EnableDBGStopMode
       8   HAL_DeInit
         8   -> HAL_MspDeInit
      16   HAL_Delay
        16   -> HAL_GetTick
      24   HAL_Delay_us
        24   -> HAL_Delay_us
       0   HAL_GetDEVID
       0   HAL_GetHalVersion
       0   HAL_GetREVID
       0   HAL_GetTick
       0   HAL_IncTick
       8   HAL_Init
         8   -> HAL_InitTick
         8   -> HAL_MspInit
         8   -> HAL_NVIC_SetPriorityGrouping
       8   HAL_InitTick
         8   -> HAL_NVIC_SetPriority
         8   -> HAL_RCC_GetHCLKFreq
         8   -> HAL_SYSTICK_Config
       0   HAL_MspDeInit
       0   HAL_MspInit
       0   HAL_ResumeTick
       0   HAL_SetTick
       0   HAL_SuspendTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
      12  HAL_DBGMCU_DisableDBGSleepMode
      12  HAL_DBGMCU_DisableDBGStandbyMode
      12  HAL_DBGMCU_DisableDBGStopMode
      12  HAL_DBGMCU_EnableDBGSleepMode
      12  HAL_DBGMCU_EnableDBGStandbyMode
      12  HAL_DBGMCU_EnableDBGStopMode
      28  HAL_DeInit
      24  HAL_Delay
     140  HAL_Delay_us
      10  HAL_GetDEVID
       4  HAL_GetHalVersion
       8  HAL_GetREVID
      12  HAL_GetTick
      16  HAL_IncTick
      32  HAL_Init
      36  HAL_InitTick
       2  HAL_MspDeInit
       2  HAL_MspInit
      16  HAL_ResumeTick
      12  HAL_SetTick
      16  HAL_SuspendTick
       4  uwTick

 
   4 bytes in section .bss
 458 bytes in section .text
 
 322 bytes of CODE memory (+ 136 bytes shared)
   4 bytes of DATA memory

Errors: none
Warnings: 4
