###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  21:37:06
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_com_api_16gr.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EW4084.tmp
#        (F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_com_api_16gr.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\u8g_com_api_16gr.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\u8g_com_api_16gr.o
#
###############################################################################

F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_com_api_16gr.c
      1          /*
      2          
      3            u8g_com_api_16gr.c
      4            
      5            Extension of the com api for devices with 16 graylevels (4 bit per pixel).
      6            This should fit to the 8h and 16h architectures (pb8v1, pb8v2, pb16v1, pb16v2), 
      7            mainly intended for SSD OLEDs
      8          
      9            Universal 8bit Graphics Library
     10            
     11            Copyright (c) 2011, olikraus@gmail.com
     12            All rights reserved.
     13          
     14            Redistribution and use in source and binary forms, with or without modification, 
     15            are permitted provided that the following conditions are met:
     16          
     17            * Redistributions of source code must retain the above copyright notice, this list 
     18              of conditions and the following disclaimer.
     19              
     20            * Redistributions in binary form must reproduce the above copyright notice, this 
     21              list of conditions and the following disclaimer in the documentation and/or other 
     22              materials provided with the distribution.
     23          
     24            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
     25            CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
     26            INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
     27            MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
     28            DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
     29            CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     30            SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
     31            NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
     32            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
     33            CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     34            STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
     35            ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
     36            ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
     37            
     38            
     39          */
     40          
     41          #include "u8g.h"
     42          
     43          /* interpret b as a monochrome bit pattern, write value 15 for high bit and value 0 for a low bit */
     44          /* topbit (msb) is sent last */
     45          /* example: b = 0x083 will send 0xff, 0x00, 0x00, 0xf0 */

   \                                 In section .text, align 2, keep-with-next
     46          uint8_t u8g_WriteByteBWTo16GrDevice(u8g_t *u8g, u8g_dev_t *dev, uint8_t b)
     47          {
   \                     u8g_WriteByteBWTo16GrDevice: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
     48            static uint8_t buf[4];
     49            static uint8_t map[4] = { 0, 0x00f, 0x0f0, 0x0ff };
     50            buf [3] = map[b & 3];
   \   00000004   0x....             LDR.N    R3,??DataTable1
   \   00000006   0x1D19             ADDS     R1,R3,#+4
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0xF005 0x0503      AND      R5,R5,#0x3
   \   0000000E   0x5D49             LDRB     R1,[R1, R5]
   \   00000010   0x70D9             STRB     R1,[R3, #+3]
     51            b>>=2;
   \   00000012   0x0892             LSRS     R2,R2,#+2
     52            buf [2] = map[b & 3];
   \   00000014   0x1D19             ADDS     R1,R3,#+4
   \   00000016   0x4615             MOV      R5,R2
   \   00000018   0xF005 0x0503      AND      R5,R5,#0x3
   \   0000001C   0x5D49             LDRB     R1,[R1, R5]
   \   0000001E   0x7099             STRB     R1,[R3, #+2]
     53            b>>=2;
   \   00000020   0x0892             LSRS     R2,R2,#+2
     54            buf [1] = map[b & 3];
   \   00000022   0x1D19             ADDS     R1,R3,#+4
   \   00000024   0x4615             MOV      R5,R2
   \   00000026   0xF005 0x0503      AND      R5,R5,#0x3
   \   0000002A   0x5D49             LDRB     R1,[R1, R5]
   \   0000002C   0x7059             STRB     R1,[R3, #+1]
     55            b>>=2;
     56            buf [0] = map[b & 3];
   \   0000002E   0xF3C2 0x0181      UBFX     R1,R2,#+2,#+2
   \   00000032   0x4419             ADD      R1,R3,R1
   \   00000034   0x7909             LDRB     R1,[R1, #+4]
   \   00000036   0x7019             STRB     R1,[R3, #+0]
     57            return dev->com_fn(u8g, U8G_COM_MSG_WRITE_SEQ, 4, buf);
   \   00000038   0x2204             MOVS     R2,#+4
   \   0000003A   0x2106             MOVS     R1,#+6
   \   0000003C   0x68A4             LDR      R4,[R4, #+8]
   \   0000003E   0x47A0             BLX      R4
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     58          }

   \                                 In section .data, align 4
   \                     `u8g_WriteByteBWTo16GrDevice::buf`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x00 0x0F          DC8 0, 15, 240, 255
   \              0xF0 0xFF    
     59          

   \                                 In section .text, align 2, keep-with-next
     60          uint8_t u8g_WriteSequenceBWTo16GrDevice(u8g_t *u8g, u8g_dev_t *dev, uint8_t cnt, uint8_t *ptr)
     61          {
   \                     u8g_WriteSequenceBWTo16GrDevice: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
     62            do
     63            {
     64              if ( u8g_WriteByteBWTo16GrDevice(u8g, dev, *ptr++) == 0 )
   \                     ??u8g_WriteSequenceBWTo16GrDevice_0: (+1)
   \   0000000A   0xF817 0x2B01      LDRB     R2,[R7], #+1
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       u8g_WriteByteBWTo16GrDevice
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD006             BEQ.N    ??u8g_WriteSequenceBWTo16GrDevice_1
     65                return 0;
     66              cnt--;
   \   0000001A   0x1E76             SUBS     R6,R6,#+1
     67            } while( cnt != 0 );
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1F2             BNE.N    ??u8g_WriteSequenceBWTo16GrDevice_0
     68            return 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??u8g_WriteSequenceBWTo16GrDevice_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}
     69          }
     70          
     71          /* interpret b as a 4L bit pattern, write values 0x000, 0x004, 0x008, 0x00c */

   \                                 In section .text, align 2, keep-with-next
     72          uint8_t u8g_WriteByte4LTo16GrDevice(u8g_t *u8g, u8g_dev_t *dev, uint8_t b)
     73          {
   \                     u8g_WriteByte4LTo16GrDevice: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
     74            //static uint8_t map[16] = { 0x000, 0x004, 0x008, 0x00c, 0x040, 0x044, 0x048, 0x04c, 0x080, 0x084, 0x088, 0x08c, 0x0c0, 0x0c4, 0x0c8, 0x0cc};
     75            //static uint8_t map[16] = { 0x000, 0x004, 0x00a, 0x00f, 0x040, 0x044, 0x04a, 0x04f, 0x0a0, 0x0a4, 0x0aa, 0x0af, 0x0f0, 0x0f4, 0x0fa, 0x0ff};
     76            static uint8_t map[16] = { 0x000, 0x040, 0x0a0, 0x0f0, 0x004, 0x044, 0x0a4, 0x0f4, 0x00a, 0x04a, 0x0aa, 0x0fa, 0x00f, 0x04f, 0x0af, 0x0ff};
     77            uint8_t bb;
     78            bb = b;
     79            bb &= 15;
     80            b>>=4;
     81            dev->com_fn(u8g, U8G_COM_MSG_WRITE_BYTE, map[bb], NULL);
   \   00000008   0x....             LDR.N    R7,??DataTable1_1
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0xF006 0x000F      AND      R0,R6,#0xF
   \   00000010   0x5C3A             LDRB     R2,[R7, R0]
   \   00000012   0x2105             MOVS     R1,#+5
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xF8D5 0xC008      LDR      R12,[R5, #+8]
   \   0000001A   0x47E0             BLX      R12
     82            return dev->com_fn(u8g, U8G_COM_MSG_WRITE_BYTE, map[b], NULL);
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x0936             LSRS     R6,R6,#+4
   \   00000020   0x5DBA             LDRB     R2,[R7, R6]
   \   00000022   0x2105             MOVS     R1,#+5
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x68AC             LDR      R4,[R5, #+8]
   \   00000028   0x47A0             BLX      R4
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     83          }

   \                                 In section .data, align 4
   \                     `u8g_WriteByte4LTo16GrDevice::map`:
   \   00000000   0x00 0x40          DC8 0, 64, 160, 240, 4, 68, 164, 244, 10, 74, 170, 250, 15, 79, 175
   \              0xA0 0xF0    
   \              0x04 0x44    
   \              0xA4 0xF4    
   \              0x0A 0x4A    
   \              0xAA 0xFA    
   \              0x0F 0x4F    
   \              0xAF         
   \   0000000F   0xFF               DC8 255
     84          

   \                                 In section .text, align 2, keep-with-next
     85          uint8_t u8g_WriteSequence4LTo16GrDevice(u8g_t *u8g, u8g_dev_t *dev, uint8_t cnt, uint8_t *ptr)
     86          {
   \                     u8g_WriteSequence4LTo16GrDevice: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
     87            do
     88            {
     89              if ( u8g_WriteByte4LTo16GrDevice(u8g, dev, *ptr++) == 0 )
   \                     ??u8g_WriteSequence4LTo16GrDevice_0: (+1)
   \   0000000A   0xF817 0x2B01      LDRB     R2,[R7], #+1
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       u8g_WriteByte4LTo16GrDevice
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD006             BEQ.N    ??u8g_WriteSequence4LTo16GrDevice_1
     90                return 0;
     91              cnt--;
   \   0000001A   0x1E76             SUBS     R6,R6,#+1
     92            } while( cnt != 0 );
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1F2             BNE.N    ??u8g_WriteSequence4LTo16GrDevice_0
     93            return 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??u8g_WriteSequence4LTo16GrDevice_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}
     94          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     `u8g_WriteByteBWTo16GrDevice::buf`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     `u8g_WriteByte4LTo16GrDevice::map`

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   u8g_WriteByte4LTo16GrDevice
        24   -- Indirect call
      16   u8g_WriteByteBWTo16GrDevice
        16   -- Indirect call
      24   u8g_WriteSequence4LTo16GrDevice
        24   -> u8g_WriteByte4LTo16GrDevice
      24   u8g_WriteSequenceBWTo16GrDevice
        24   -> u8g_WriteByteBWTo16GrDevice


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       8  buf
          map
      16  map
      44  u8g_WriteByte4LTo16GrDevice
      66  u8g_WriteByteBWTo16GrDevice
      44  u8g_WriteSequence4LTo16GrDevice
      44  u8g_WriteSequenceBWTo16GrDevice

 
  24 bytes in section .data
 206 bytes in section .text
 
 206 bytes of CODE memory
  24 bytes of DATA memory

Errors: none
Warnings: none
