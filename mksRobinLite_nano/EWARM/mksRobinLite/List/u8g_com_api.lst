###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  21:37:06
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_com_api.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EW4035.tmp
#        (F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_com_api.c -D
#        USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\u8g_com_api.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\u8g_com_api.o
#
###############################################################################

F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_com_api.c
      1          /*
      2          
      3            u8g_com_api.c
      4          
      5            Universal 8bit Graphics Library
      6            
      7            Copyright (c) 2011, olikraus@gmail.com
      8            All rights reserved.
      9          
     10            Redistribution and use in source and binary forms, with or without modification, 
     11            are permitted provided that the following conditions are met:
     12          
     13            * Redistributions of source code must retain the above copyright notice, this list 
     14              of conditions and the following disclaimer.
     15              
     16            * Redistributions in binary form must reproduce the above copyright notice, this 
     17              list of conditions and the following disclaimer in the documentation and/or other 
     18              materials provided with the distribution.
     19          
     20            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
     21            CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
     22            INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
     23            MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
     24            DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
     25            CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     26            SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
     27            NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
     28            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
     29            CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     30            STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
     31            ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
     32            ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
     33            
     34            
     35          */
     36          
     37          #include "u8g.h"
     38          

   \                                 In section .text, align 2, keep-with-next
     39          uint8_t u8g_InitCom(u8g_t *u8g, u8g_dev_t *dev, uint8_t clk_cycle_time)
     40          {
   \                     u8g_InitCom: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
     41            return dev->com_fn(u8g, U8G_COM_MSG_INIT, clk_cycle_time, NULL);
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x68A4             LDR      R4,[R4, #+8]
   \   0000000A   0x47A0             BLX      R4
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
     42          }
     43          

   \                                 In section .text, align 2, keep-with-next
     44          void u8g_StopCom(u8g_t *u8g, u8g_dev_t *dev)
     45          {
   \                     u8g_StopCom: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
     46            dev->com_fn(u8g, U8G_COM_MSG_STOP, 0, NULL);
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x461A             MOV      R2,R3
   \   00000008   0x4611             MOV      R1,R2
   \   0000000A   0x68A4             LDR      R4,[R4, #+8]
   \   0000000C   0x47A0             BLX      R4
     47          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
     48          
     49          /* cs contains the chip number, which should be enabled */

   \                                 In section .text, align 2, keep-with-next
     50          void u8g_SetChipSelect(u8g_t *u8g, u8g_dev_t *dev, uint8_t cs)
     51          {
   \                     u8g_SetChipSelect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
     52            dev->com_fn(u8g, U8G_COM_MSG_CHIP_SELECT, cs, NULL);
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2103             MOVS     R1,#+3
   \   00000008   0x68A4             LDR      R4,[R4, #+8]
   \   0000000A   0x47A0             BLX      R4
     53          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
     54          

   \                                 In section .text, align 2, keep-with-next
     55          void u8g_SetResetLow(u8g_t *u8g, u8g_dev_t *dev)
     56          {
   \                     u8g_SetResetLow: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
     57            dev->com_fn(u8g, U8G_COM_MSG_RESET, 0, NULL);
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x461A             MOV      R2,R3
   \   00000008   0x2104             MOVS     R1,#+4
   \   0000000A   0x68A4             LDR      R4,[R4, #+8]
   \   0000000C   0x47A0             BLX      R4
     58          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
     59          

   \                                 In section .text, align 2, keep-with-next
     60          void u8g_SetResetHigh(u8g_t *u8g, u8g_dev_t *dev)
     61          {
   \                     u8g_SetResetHigh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
     62            dev->com_fn(u8g, U8G_COM_MSG_RESET, 1, NULL);
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x2104             MOVS     R1,#+4
   \   0000000A   0x68A4             LDR      R4,[R4, #+8]
   \   0000000C   0x47A0             BLX      R4
     63          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
     64          
     65          

   \                                 In section .text, align 2, keep-with-next
     66          void u8g_SetAddress(u8g_t *u8g, u8g_dev_t *dev, uint8_t address)
     67          {
   \                     u8g_SetAddress: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
     68            dev->com_fn(u8g, U8G_COM_MSG_ADDRESS, address, NULL);
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x68A4             LDR      R4,[R4, #+8]
   \   0000000A   0x47A0             BLX      R4
     69          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
     70          

   \                                 In section .text, align 2, keep-with-next
     71          uint8_t u8g_WriteByte(u8g_t *u8g, u8g_dev_t *dev, uint8_t val)
     72          {
   \                     u8g_WriteByte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
     73            return dev->com_fn(u8g, U8G_COM_MSG_WRITE_BYTE, val, NULL);
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2105             MOVS     R1,#+5
   \   00000008   0x68A4             LDR      R4,[R4, #+8]
   \   0000000A   0x47A0             BLX      R4
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
     74          }
     75          

   \                                 In section .text, align 2, keep-with-next
     76          uint8_t u8g_WriteSequence(u8g_t *u8g, u8g_dev_t *dev, uint8_t cnt, uint8_t *seq)
     77          {
   \                     u8g_WriteSequence: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
     78            return dev->com_fn(u8g, U8G_COM_MSG_WRITE_SEQ, cnt, seq);
   \   00000004   0x2106             MOVS     R1,#+6
   \   00000006   0x68A4             LDR      R4,[R4, #+8]
   \   00000008   0x47A0             BLX      R4
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
     79          }
     80          

   \                                 In section .text, align 2, keep-with-next
     81          uint8_t u8g_WriteSequenceP(u8g_t *u8g, u8g_dev_t *dev, uint8_t cnt, const uint8_t *seq)
     82          {
   \                     u8g_WriteSequenceP: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
     83            return dev->com_fn(u8g, U8G_COM_MSG_WRITE_SEQ_P, cnt, (void *)seq);
   \   00000004   0x2107             MOVS     R1,#+7
   \   00000006   0x68A4             LDR      R4,[R4, #+8]
   \   00000008   0x47A0             BLX      R4
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
     84          }
     85          
     86          /*
     87            sequence := { direct_value | escape_sequence }
     88            direct_value := 0..254
     89            escape_sequence := value_255 | sequence_end | delay | adr | cs | not_used 
     90            value_255 := 255 255
     91            sequence_end = 255 254
     92            delay := 255 0..127
     93            adr := 255 0x0e0 .. 0x0ef 
     94            cs := 255 0x0d0 .. 0x0df 
     95            not_used := 255 101..254
     96          
     97          #define U8G_ESC_DLY(x) 255, ((x) & 0x7f)
     98          #define U8G_ESC_CS(x) 255, (0xd0 | ((x)&0x0f))
     99          #define U8G_ESC_ADR(x) 255, (0xe0 | ((x)&0x0f))
    100          #define U8G_ESC_VCC(x) 255, (0xbe | ((x)&0x01))
    101          #define U8G_ESC_END 255, 254
    102          #define U8G_ESC_255 255, 255
    103          #define U8G_ESC_RST(x) 255, (0xc0 | ((x)&0x0f))
    104          
    105          */

   \                                 In section .text, align 2, keep-with-next
    106          uint8_t u8g_WriteEscSeqP(u8g_t *u8g, u8g_dev_t *dev, const uint8_t *esc_seq)
    107          {
   \                     u8g_WriteEscSeqP: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    108            uint8_t is_escape = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xE020             B.N      ??u8g_WriteEscSeqP_0
    109            uint8_t value;
    110            for(;;)
    111            {
    112              value = u8g_pgm_read(esc_seq);
    113              if ( is_escape == 0 )
    114              {
    115                if ( value != 255 )
    116                {
    117                  if ( u8g_WriteByte(u8g, dev, value) == 0 )
    118                    return 0;
    119                }
    120                else
    121                {
    122                  is_escape = 1;
    123                }
    124              }
    125              else
    126              {
    127                if ( value == 255 )
    128                {
    129                  if ( u8g_WriteByte(u8g, dev, value) == 0 )
    130                    return 0;
    131                }
    132                else if ( value == 254 )
    133                {
    134                  break;
    135                }
    136                else if ( value >= 0x0f0 )
    137                {
    138                  /* not yet used, do nothing */
    139                }
    140                else if ( value >= 0xe0  )
    141                {
    142                  u8g_SetAddress(u8g, dev, value & 0x0f);
    143                }
    144                else if ( value >= 0xd0 )
    145                {
    146                  u8g_SetChipSelect(u8g, dev, value & 0x0f);
    147                }
    148                else if ( value >= 0xc0 )
    149                {
    150                  u8g_SetResetLow(u8g, dev);
    151                  value &= 0x0f;
    152                  value <<= 4;
    153                  value+=2;
    154                  u8g_Delay(value);
    155                  u8g_SetResetHigh(u8g, dev);
    156                  u8g_Delay(value);
    157                }
    158                else if ( value >= 0xbe )
   \                     ??u8g_WriteEscSeqP_1: (+1)
   \   0000000E   0xF1B8 0x0FBE      CMP      R8,#+190
   \   00000012   0xDA1B             BGE.N    ??u8g_WriteEscSeqP_2
    159                {
    160          	/* not yet implemented */
    161                  /* u8g_SetVCC(u8g, dev, value & 0x01); */
    162                }
    163                else if ( value <= 127 )
   \   00000014   0xF1B8 0x0F80      CMP      R8,#+128
   \   00000018   0xDA18             BGE.N    ??u8g_WriteEscSeqP_2
    164                {
    165                  u8g_Delay(value);
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x.... 0x....      BL       u8g_Delay
   \   00000020   0xE014             B.N      ??u8g_WriteEscSeqP_2
    166                }
   \                     ??u8g_WriteEscSeqP_3: (+1)
   \   00000022   0xF1B8 0x0FC0      CMP      R8,#+192
   \   00000026   0xDBF2             BLT.N    ??u8g_WriteEscSeqP_1
   \   00000028   0x4629             MOV      R1,R5
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       u8g_SetResetLow
   \   00000030   0xEA4F 0x1708      LSL      R7,R8,#+4
   \   00000034   0x1CBF             ADDS     R7,R7,#+2
   \   00000036   0xB2FF             UXTB     R7,R7
   \   00000038   0x4638             MOV      R0,R7
   \   0000003A   0x.... 0x....      BL       u8g_Delay
   \   0000003E   0x4629             MOV      R1,R5
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       u8g_SetResetHigh
   \   00000046   0x4638             MOV      R0,R7
   \   00000048   0x.... 0x....      BL       u8g_Delay
    167                is_escape = 0;
   \                     ??u8g_WriteEscSeqP_2: (+1)
   \   0000004C   0x2700             MOVS     R7,#+0
    168              }
    169              esc_seq++;
   \                     ??u8g_WriteEscSeqP_4: (+1)
   \   0000004E   0x1C76             ADDS     R6,R6,#+1
   \                     ??u8g_WriteEscSeqP_0: (+1)
   \   00000050   0xF896 0x8000      LDRB     R8,[R6, #+0]
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0xD10E             BNE.N    ??u8g_WriteEscSeqP_5
   \   00000058   0xF1B8 0x0FFF      CMP      R8,#+255
   \   0000005C   0xD009             BEQ.N    ??u8g_WriteEscSeqP_6
   \   0000005E   0x4642             MOV      R2,R8
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       u8g_WriteByte
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD1F0             BNE.N    ??u8g_WriteEscSeqP_4
   \                     ??u8g_WriteEscSeqP_7: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \                     ??u8g_WriteEscSeqP_8: (+1)
   \   0000006E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??u8g_WriteEscSeqP_6: (+1)
   \   00000072   0x2701             MOVS     R7,#+1
   \   00000074   0xE7EB             B.N      ??u8g_WriteEscSeqP_4
   \                     ??u8g_WriteEscSeqP_5: (+1)
   \   00000076   0xF1B8 0x0FFF      CMP      R8,#+255
   \   0000007A   0xD107             BNE.N    ??u8g_WriteEscSeqP_9
   \   0000007C   0x4642             MOV      R2,R8
   \   0000007E   0x4629             MOV      R1,R5
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       u8g_WriteByte
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD1E0             BNE.N    ??u8g_WriteEscSeqP_2
   \   0000008A   0xE7EF             B.N      ??u8g_WriteEscSeqP_7
   \                     ??u8g_WriteEscSeqP_9: (+1)
   \   0000008C   0xF1B8 0x0FFE      CMP      R8,#+254
   \   00000090   0xD00D             BEQ.N    ??u8g_WriteEscSeqP_10
   \   00000092   0xF1B8 0x0FF0      CMP      R8,#+240
   \   00000096   0xDAD9             BGE.N    ??u8g_WriteEscSeqP_2
   \   00000098   0xF1B8 0x0FE0      CMP      R8,#+224
   \   0000009C   0xDB09             BLT.N    ??u8g_WriteEscSeqP_11
   \   0000009E   0xF008 0x080F      AND      R8,R8,#0xF
   \   000000A2   0x4642             MOV      R2,R8
   \   000000A4   0x4629             MOV      R1,R5
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       u8g_SetAddress
   \   000000AC   0xE7CE             B.N      ??u8g_WriteEscSeqP_2
    170            }
    171            return 1;
   \                     ??u8g_WriteEscSeqP_10: (+1)
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xE7DD             B.N      ??u8g_WriteEscSeqP_8
   \                     ??u8g_WriteEscSeqP_11: (+1)
   \   000000B2   0xF1B8 0x0FD0      CMP      R8,#+208
   \   000000B6   0xDBB4             BLT.N    ??u8g_WriteEscSeqP_3
   \   000000B8   0xF008 0x080F      AND      R8,R8,#0xF
   \   000000BC   0x4642             MOV      R2,R8
   \   000000BE   0x4629             MOV      R1,R5
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       u8g_SetChipSelect
   \   000000C6   0xE7C1             B.N      ??u8g_WriteEscSeqP_2
    172          }
    173          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   u8g_InitCom
         8   -- Indirect call
       8   u8g_SetAddress
         8   -- Indirect call
       8   u8g_SetChipSelect
         8   -- Indirect call
       8   u8g_SetResetHigh
         8   -- Indirect call
       8   u8g_SetResetLow
         8   -- Indirect call
       8   u8g_StopCom
         8   -- Indirect call
       8   u8g_WriteByte
         8   -- Indirect call
      24   u8g_WriteEscSeqP
        24   -> u8g_Delay
        24   -> u8g_SetAddress
        24   -> u8g_SetChipSelect
        24   -> u8g_SetResetHigh
        24   -> u8g_SetResetLow
        24   -> u8g_WriteByte
       8   u8g_WriteSequence
         8   -- Indirect call
       8   u8g_WriteSequenceP
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      14  u8g_InitCom
      14  u8g_SetAddress
      14  u8g_SetChipSelect
      16  u8g_SetResetHigh
      16  u8g_SetResetLow
      16  u8g_StopCom
      14  u8g_WriteByte
     200  u8g_WriteEscSeqP
      12  u8g_WriteSequence
      12  u8g_WriteSequenceP

 
 328 bytes in section .text
 
 328 bytes of CODE memory

Errors: none
Warnings: none
