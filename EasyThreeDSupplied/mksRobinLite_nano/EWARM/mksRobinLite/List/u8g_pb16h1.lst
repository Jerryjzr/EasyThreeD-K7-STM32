###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  21:37:10
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_pb16h1.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EW51E4.tmp
#        (F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_pb16h1.c -D
#        USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\u8g_pb16h1.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\u8g_pb16h1.o
#
###############################################################################

F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_pb16h1.c
      1          /*
      2          
      3            u8g_pb16h1.c
      4            
      5            2x 8bit height monochrom (1 bit) page buffer
      6            byte has horizontal orientation
      7          
      8            Universal 8bit Graphics Library
      9            
     10            Copyright (c) 2012, olikraus@gmail.com
     11            All rights reserved.
     12          
     13            Redistribution and use in source and binary forms, with or without modification, 
     14            are permitted provided that the following conditions are met:
     15          
     16            * Redistributions of source code must retain the above copyright notice, this list 
     17              of conditions and the following disclaimer.
     18              
     19            * Redistributions in binary form must reproduce the above copyright notice, this 
     20              list of conditions and the following disclaimer in the documentation and/or other 
     21              materials provided with the distribution.
     22          
     23            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
     24            CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
     25            INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
     26            MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
     27            DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
     28            CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     29            SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
     30            NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
     31            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
     32            CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     33            STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
     34            ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
     35            ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
     36          
     37          
     38            total buffer size is limited to 2*256 bytes because of the calculation inside the set pixel procedure
     39          
     40          
     41          */
     42          
     43          #include "u8g.h"
     44          #include <string.h>
     45          
     46          
     47          void u8g_pb16h1_Init(u8g_pb_t *b, void *buf, u8g_uint_t width) U8G_NOINLINE;
     48          void u8g_pb16h1_set_pixel(u8g_pb_t *b, u8g_uint_t x, u8g_uint_t y, uint8_t color_index) U8G_NOINLINE;
     49          void u8g_pb16h1_SetPixel(u8g_pb_t *b, const u8g_dev_arg_pixel_t * const arg_pixel) U8G_NOINLINE ;
     50          void u8g_pb16h1_Set8PixelStd(u8g_pb_t *b, u8g_dev_arg_pixel_t *arg_pixel) U8G_NOINLINE;
     51          uint8_t u8g_dev_pb8h1_base_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg);
     52          

   \                                 In section .text, align 2, keep-with-next
     53          void u8g_pb16h1_Clear(u8g_pb_t *b)
     54          {
     55            uint8_t *ptr = (uint8_t *)b->buf;
   \                     u8g_pb16h1_Clear: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
     56            uint8_t *end_ptr = ptr;
     57            end_ptr += b->width*2;
   \   00000002   0x7940             LDRB     R0,[R0, #+5]
   \   00000004   0xEB01 0x0040      ADD      R0,R1,R0, LSL #+1
   \   00000008   0x2200             MOVS     R2,#+0
     58            do
     59            {
     60              *ptr++ = 0;
   \                     ??u8g_pb16h1_Clear_0: (+1)
   \   0000000A   0xF801 0x2B01      STRB     R2,[R1], #+1
     61            } while( ptr != end_ptr );
   \   0000000E   0x4281             CMP      R1,R0
   \   00000010   0xD1FB             BNE.N    ??u8g_pb16h1_Clear_0
     62          }
   \   00000012   0x4770             BX       LR               ;; return
     63          
     64          
     65          

   \                                 In section .text, align 2, keep-with-next
     66          void u8g_pb16h1_Init(u8g_pb_t *b, void *buf, u8g_uint_t width)
     67          {
     68            b->buf = buf;
   \                     u8g_pb16h1_Init: (+1)
   \   00000000   0x6081             STR      R1,[R0, #+8]
     69            b->width = width;
   \   00000002   0x7142             STRB     R2,[R0, #+5]
     70            u8g_pb16h1_Clear(b);
   \   00000004   0x....             B.N      u8g_pb16h1_Clear
     71          }
     72          
     73          
     74          /* limitation: total buffer must not exceed 2*256 bytes */

   \                                 In section .text, align 2, keep-with-next
     75          void u8g_pb16h1_set_pixel(u8g_pb_t *b, u8g_uint_t x, u8g_uint_t y, uint8_t color_index)
     76          {
   \                     u8g_pb16h1_set_pixel: (+1)
   \   00000000   0xB478             PUSH     {R3-R6}
     77            register uint8_t mask;
     78            u8g_uint_t tmp;
     79            uint8_t *ptr = b->buf;
   \   00000002   0x6885             LDR      R5,[R0, #+8]
     80            
     81            y -= b->p.page_y0;
   \   00000004   0x7884             LDRB     R4,[R0, #+2]
   \   00000006   0x1B12             SUBS     R2,R2,R4
     82            if ( y >= 8 )
   \   00000008   0x7940             LDRB     R0,[R0, #+5]
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0xB2E4             UXTB     R4,R4
   \   0000000E   0x2C08             CMP      R4,#+8
   \   00000010   0xDB03             BLT.N    ??u8g_pb16h1_set_pixel_0
     83            {
     84              ptr += b->width;
   \   00000012   0x4604             MOV      R4,R0
   \   00000014   0x4425             ADD      R5,R5,R4
     85              y &= 0x07;
   \   00000016   0xF002 0x0207      AND      R2,R2,#0x7
     86            }
     87            tmp = b->width;
     88            tmp >>= 3;
     89            tmp *= (uint8_t)y;
     90            ptr += tmp;
     91            
     92            mask = 0x080;
     93            mask >>= x & 7;
   \                     ??u8g_pb16h1_set_pixel_0: (+1)
   \   0000001A   0x2480             MOVS     R4,#+128
   \   0000001C   0xF001 0x0607      AND      R6,R1,#0x7
   \   00000020   0x40F4             LSRS     R4,R4,R6
     94            x >>= 3;
     95            ptr += x;
   \   00000022   0x08C0             LSRS     R0,R0,#+3
   \   00000024   0xB2D2             UXTB     R2,R2
   \   00000026   0x4342             MULS     R2,R2,R0
   \   00000028   0xB2D2             UXTB     R2,R2
   \   0000002A   0x18A8             ADDS     R0,R5,R2
   \   0000002C   0xEB00 0x00D1      ADD      R0,R0,R1, LSR #+3
     96            if ( color_index )
   \   00000030   0x7801             LDRB     R1,[R0, #+0]
   \   00000032   0x2B00             CMP      R3,#+0
   \   00000034   0xD002             BEQ.N    ??u8g_pb16h1_set_pixel_1
     97            {
     98              *ptr |= mask;
   \   00000036   0x430C             ORRS     R4,R4,R1
   \   00000038   0x7004             STRB     R4,[R0, #+0]
   \   0000003A   0xE003             B.N      ??u8g_pb16h1_set_pixel_2
     99            }
    100            else
    101            {
    102              mask ^=0xff;
    103              *ptr &= mask;
   \                     ??u8g_pb16h1_set_pixel_1: (+1)
   \   0000003C   0xF084 0x04FF      EOR      R4,R4,#0xFF
   \   00000040   0x400C             ANDS     R4,R4,R1
   \   00000042   0x7004             STRB     R4,[R0, #+0]
    104            }
    105            
    106          }
   \                     ??u8g_pb16h1_set_pixel_2: (+1)
   \   00000044   0xBC71             POP      {R0,R4-R6}
   \   00000046   0x4770             BX       LR               ;; return
    107          
    108          

   \                                 In section .text, align 2, keep-with-next
    109          void u8g_pb16h1_SetPixel(u8g_pb_t *b, const u8g_dev_arg_pixel_t * const arg_pixel)
    110          {
   \                     u8g_pb16h1_SetPixel: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
    111            if ( arg_pixel->y < b->p.page_y0 )
   \   00000002   0x784A             LDRB     R2,[R1, #+1]
   \   00000004   0x7883             LDRB     R3,[R0, #+2]
   \   00000006   0x429A             CMP      R2,R3
   \   00000008   0xD30B             BCC.N    ??u8g_pb16h1_SetPixel_0
    112              return;
    113            if ( arg_pixel->y > b->p.page_y1 )
   \   0000000A   0x78C3             LDRB     R3,[R0, #+3]
   \   0000000C   0x4293             CMP      R3,R2
   \   0000000E   0xD308             BCC.N    ??u8g_pb16h1_SetPixel_0
    114              return;
    115            if ( arg_pixel->x >= b->width )
   \   00000010   0x780C             LDRB     R4,[R1, #+0]
   \   00000012   0x7943             LDRB     R3,[R0, #+5]
   \   00000014   0x429C             CMP      R4,R3
   \   00000016   0xD204             BCS.N    ??u8g_pb16h1_SetPixel_0
    116              return;
    117            u8g_pb16h1_set_pixel(b, arg_pixel->x, arg_pixel->y, arg_pixel->color);
   \   00000018   0x790B             LDRB     R3,[R1, #+4]
   \   0000001A   0x4621             MOV      R1,R4
   \   0000001C   0xB001             ADD      SP,SP,#+4
   \   0000001E   0xBC10             POP      {R4}
   \   00000020   0x....             B.N      u8g_pb16h1_set_pixel
   \                     ??u8g_pb16h1_SetPixel_0: (+1)
   \   00000022   0xBC11             POP      {R0,R4}
   \   00000024   0x4770             BX       LR               ;; return
    118          }
    119          

   \                                 In section .text, align 4, keep-with-next
    120          void u8g_pb16h1_Set8PixelStd(u8g_pb_t *b, u8g_dev_arg_pixel_t *arg_pixel)
    121          {
   \                     u8g_pb16h1_Set8PixelStd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    122            register uint8_t pixel = arg_pixel->pixel;
   \   00000006   0x78AE             LDRB     R6,[R5, #+2]
    123            do
    124            {
    125              if ( pixel & 128 )
   \                     ??u8g_pb16h1_Set8PixelStd_1: (+1)
   \   00000008   0x0630             LSLS     R0,R6,#+24
   \   0000000A   0xD503             BPL.N    ??u8g_pb16h1_Set8PixelStd_2
    126              {
    127                u8g_pb16h1_SetPixel(b, arg_pixel);
   \   0000000C   0x4629             MOV      R1,R5
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       u8g_pb16h1_SetPixel
    128              }
    129              switch( arg_pixel->dir )
   \                     ??u8g_pb16h1_Set8PixelStd_2: (+1)
   \   00000014   0x78E8             LDRB     R0,[R5, #+3]
   \   00000016   0x2803             CMP      R0,#+3
   \   00000018   0xD812             BHI.N    ??u8g_pb16h1_Set8PixelStd_3
   \   0000001A   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??u8g_pb16h1_Set8PixelStd_0:
   \   0000001E   0x02 0x06          DC8      0x2,0x6,0xA,0xE
   \              0x0A 0x0E    
    130              {
    131                case 0: arg_pixel->x++; break;
   \                     ??u8g_pb16h1_Set8PixelStd_4: (+1)
   \   00000022   0x7828             LDRB     R0,[R5, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x7028             STRB     R0,[R5, #+0]
   \   00000028   0xE00A             B.N      ??u8g_pb16h1_Set8PixelStd_3
    132                case 1: arg_pixel->y++; break;
   \                     ??u8g_pb16h1_Set8PixelStd_5: (+1)
   \   0000002A   0x7868             LDRB     R0,[R5, #+1]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x7068             STRB     R0,[R5, #+1]
   \   00000030   0xE006             B.N      ??u8g_pb16h1_Set8PixelStd_3
    133                case 2: arg_pixel->x--; break;
   \                     ??u8g_pb16h1_Set8PixelStd_6: (+1)
   \   00000032   0x7828             LDRB     R0,[R5, #+0]
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x7028             STRB     R0,[R5, #+0]
   \   00000038   0xE002             B.N      ??u8g_pb16h1_Set8PixelStd_3
    134                case 3: arg_pixel->y--; break;
   \                     ??u8g_pb16h1_Set8PixelStd_7: (+1)
   \   0000003A   0x7868             LDRB     R0,[R5, #+1]
   \   0000003C   0x1E40             SUBS     R0,R0,#+1
   \   0000003E   0x7068             STRB     R0,[R5, #+1]
    135              }
    136              pixel <<= 1;
   \                     ??u8g_pb16h1_Set8PixelStd_3: (+1)
   \   00000040   0x0076             LSLS     R6,R6,#+1
    137            } while( pixel != 0  );
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0xB2C0             UXTB     R0,R0
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD1DE             BNE.N    ??u8g_pb16h1_Set8PixelStd_1
    138          }
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    139          

   \                                 In section .text, align 4, keep-with-next
    140          void u8g_pb16h1_Set8PixelOpt2(u8g_pb_t *b, u8g_dev_arg_pixel_t *arg_pixel)
    141          {
   \                     u8g_pb16h1_Set8PixelOpt2: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460F             MOV      R7,R1
    142            register uint8_t pixel = arg_pixel->pixel;
   \   00000008   0xF897 0x8002      LDRB     R8,[R7, #+2]
    143            u8g_uint_t dx = 0;
   \   0000000C   0x2400             MOVS     R4,#+0
    144            u8g_uint_t dy = 0;
   \   0000000E   0x4625             MOV      R5,R4
    145            
    146            switch( arg_pixel->dir )
   \   00000010   0x78F8             LDRB     R0,[R7, #+3]
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xD804             BHI.N    ??u8g_pb16h1_Set8PixelOpt2_1
   \   00000016   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??u8g_pb16h1_Set8PixelOpt2_0:
   \   0000001A   0x02 0x18          DC8      0x2,0x18,0x1A,0x1C
   \              0x1A 0x1C    
    147            {
    148              case 0: dx++; break;
   \                     ??u8g_pb16h1_Set8PixelOpt2_2: (+1)
   \   0000001E   0x2401             MOVS     R4,#+1
    149              case 1: dy++; break;
    150              case 2: dx--; break;
    151              case 3: dy--; break;
    152            }
    153            
    154            do
    155            {
    156              if ( pixel & 128 )
   \                     ??u8g_pb16h1_Set8PixelOpt2_1: (+1)
   \   00000020   0xEA5F 0x6008      LSLS     R0,R8,#+24
   \   00000024   0xD503             BPL.N    ??u8g_pb16h1_Set8PixelOpt2_3
    157                u8g_pb16h1_SetPixel(b, arg_pixel);
   \   00000026   0x4639             MOV      R1,R7
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       u8g_pb16h1_SetPixel
    158              arg_pixel->x += dx;
   \                     ??u8g_pb16h1_Set8PixelOpt2_3: (+1)
   \   0000002E   0x7838             LDRB     R0,[R7, #+0]
   \   00000030   0x1820             ADDS     R0,R4,R0
   \   00000032   0x7038             STRB     R0,[R7, #+0]
    159              arg_pixel->y += dy;
   \   00000034   0x7878             LDRB     R0,[R7, #+1]
   \   00000036   0x1828             ADDS     R0,R5,R0
   \   00000038   0x7078             STRB     R0,[R7, #+1]
    160              pixel <<= 1;
   \   0000003A   0xEA4F 0x0848      LSL      R8,R8,#+1
    161            } while( pixel != 0  );  
   \   0000003E   0x4640             MOV      R0,R8
   \   00000040   0xB2C0             UXTB     R0,R0
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD1EC             BNE.N    ??u8g_pb16h1_Set8PixelOpt2_1
    162          }
   \   00000046   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??u8g_pb16h1_Set8PixelOpt2_4: (+1)
   \   0000004A   0x2501             MOVS     R5,#+1
   \   0000004C   0xE7E8             B.N      ??u8g_pb16h1_Set8PixelOpt2_1
   \                     ??u8g_pb16h1_Set8PixelOpt2_5: (+1)
   \   0000004E   0x24FF             MOVS     R4,#+255
   \   00000050   0xE7E6             B.N      ??u8g_pb16h1_Set8PixelOpt2_1
   \                     ??u8g_pb16h1_Set8PixelOpt2_6: (+1)
   \   00000052   0x25FF             MOVS     R5,#+255
   \   00000054   0xE7E4             B.N      ??u8g_pb16h1_Set8PixelOpt2_1
    163          
    164          

   \                                 In section .text, align 2, keep-with-next
    165          uint8_t u8g_dev_pb16h1_base_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)
    166          {
   \                     u8g_dev_pb16h1_base_fn: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x461C             MOV      R4,R3
    167            u8g_pb_t *pb = (u8g_pb_t *)(dev->dev_mem);
   \   00000004   0x684D             LDR      R5,[R1, #+4]
    168            switch(msg)
   \   00000006   0x2A14             CMP      R2,#+20
   \   00000008   0xD01C             BEQ.N    ??u8g_dev_pb16h1_base_fn_0
   \   0000000A   0x2A15             CMP      R2,#+21
   \   0000000C   0xD021             BEQ.N    ??u8g_dev_pb16h1_base_fn_1
   \   0000000E   0x2A17             CMP      R2,#+23
   \   00000010   0xD02A             BEQ.N    ??u8g_dev_pb16h1_base_fn_2
   \   00000012   0x2A32             CMP      R2,#+50
   \   00000014   0xD011             BEQ.N    ??u8g_dev_pb16h1_base_fn_3
   \   00000016   0x2A3B             CMP      R2,#+59
   \   00000018   0xD004             BEQ.N    ??u8g_dev_pb16h1_base_fn_4
   \   0000001A   0x2A46             CMP      R2,#+70
   \   0000001C   0xD029             BEQ.N    ??u8g_dev_pb16h1_base_fn_5
   \   0000001E   0x2A47             CMP      R2,#+71
   \   00000020   0xD02A             BEQ.N    ??u8g_dev_pb16h1_base_fn_6
   \   00000022   0xE02B             B.N      ??u8g_dev_pb16h1_base_fn_7
    169            {
    170              case U8G_DEV_MSG_SET_8PIXEL:
    171                if ( u8g_pb_Is8PixelVisible(pb, (u8g_dev_arg_pixel_t *)arg) )
   \                     ??u8g_dev_pb16h1_base_fn_4: (+1)
   \   00000024   0x4621             MOV      R1,R4
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       u8g_pb_Is8PixelVisible
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD025             BEQ.N    ??u8g_dev_pb16h1_base_fn_7
    172                  u8g_pb16h1_Set8PixelOpt2(pb, (u8g_dev_arg_pixel_t *)arg);
   \   00000030   0x4621             MOV      R1,R4
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       u8g_pb16h1_Set8PixelOpt2
   \   00000038   0xE020             B.N      ??u8g_dev_pb16h1_base_fn_7
    173                break;
    174              case U8G_DEV_MSG_SET_PIXEL:
    175                u8g_pb16h1_SetPixel(pb, (u8g_dev_arg_pixel_t *)arg);
   \                     ??u8g_dev_pb16h1_base_fn_3: (+1)
   \   0000003A   0x4621             MOV      R1,R4
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x.... 0x....      BL       u8g_pb16h1_SetPixel
    176                break;
   \   00000042   0xE01B             B.N      ??u8g_dev_pb16h1_base_fn_7
    177              case U8G_DEV_MSG_INIT:
    178                break;
    179              case U8G_DEV_MSG_STOP:
    180                break;
    181              case U8G_DEV_MSG_PAGE_FIRST:
    182                u8g_pb16h1_Clear(pb);
   \                     ??u8g_dev_pb16h1_base_fn_0: (+1)
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       u8g_pb16h1_Clear
    183                u8g_page_First(&(pb->p));
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       u8g_page_First
    184                break;
   \   00000050   0xE014             B.N      ??u8g_dev_pb16h1_base_fn_7
    185              case U8G_DEV_MSG_PAGE_NEXT:
    186                if ( u8g_page_Next(&(pb->p)) == 0 )
   \                     ??u8g_dev_pb16h1_base_fn_1: (+1)
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       u8g_page_Next
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD101             BNE.N    ??u8g_dev_pb16h1_base_fn_8
    187                  return 0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xBD32             POP      {R1,R4,R5,PC}
    188                u8g_pb16h1_Clear(pb);
   \                     ??u8g_dev_pb16h1_base_fn_8: (+1)
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0x.... 0x....      BL       u8g_pb16h1_Clear
    189                break;
   \   00000066   0xE009             B.N      ??u8g_dev_pb16h1_base_fn_7
    190          #ifdef U8G_DEV_MSG_IS_BBX_INTERSECTION
    191              case U8G_DEV_MSG_IS_BBX_INTERSECTION:
    192                return u8g_pb_IsIntersection(pb, (u8g_dev_arg_bbx_t *)arg);
    193          #endif
    194              case U8G_DEV_MSG_GET_PAGE_BOX:
    195                u8g_pb_GetPageBox(pb, (u8g_box_t *)arg);
   \                     ??u8g_dev_pb16h1_base_fn_2: (+1)
   \   00000068   0x4621             MOV      R1,R4
   \   0000006A   0x4628             MOV      R0,R5
   \   0000006C   0x.... 0x....      BL       u8g_pb_GetPageBox
    196                break;
   \   00000070   0xE004             B.N      ??u8g_dev_pb16h1_base_fn_7
    197              case U8G_DEV_MSG_GET_WIDTH:
    198                *((u8g_uint_t *)arg) = pb->width;
   \                     ??u8g_dev_pb16h1_base_fn_5: (+1)
   \   00000072   0x7968             LDRB     R0,[R5, #+5]
   \   00000074   0x7020             STRB     R0,[R4, #+0]
    199                break;
   \   00000076   0xE001             B.N      ??u8g_dev_pb16h1_base_fn_7
    200              case U8G_DEV_MSG_GET_HEIGHT:
    201                *((u8g_uint_t *)arg) = pb->p.total_height;
   \                     ??u8g_dev_pb16h1_base_fn_6: (+1)
   \   00000078   0x7868             LDRB     R0,[R5, #+1]
   \   0000007A   0x7020             STRB     R0,[R4, #+0]
    202                break;
    203              case U8G_DEV_MSG_SET_COLOR_ENTRY:
    204                break;
    205              case U8G_DEV_MSG_SET_XY_CB:
    206                break;
    207              case U8G_DEV_MSG_GET_MODE:
    208                return U8G_MODE_BW;
    209            }
    210            return 1;
   \                     ??u8g_dev_pb16h1_base_fn_7: (+1)
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    211          }
    212           
    213            

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   u8g_dev_pb16h1_base_fn
        16   -> u8g_page_First
        16   -> u8g_page_Next
        16   -> u8g_pb16h1_Clear
        16   -> u8g_pb16h1_Set8PixelOpt2
        16   -> u8g_pb16h1_SetPixel
        16   -> u8g_pb_GetPageBox
        16   -> u8g_pb_Is8PixelVisible
       0   u8g_pb16h1_Clear
       0   u8g_pb16h1_Init
         0   -> u8g_pb16h1_Clear
      24   u8g_pb16h1_Set8PixelOpt2
        24   -> u8g_pb16h1_SetPixel
      16   u8g_pb16h1_Set8PixelStd
        16   -> u8g_pb16h1_SetPixel
       8   u8g_pb16h1_SetPixel
         0   -> u8g_pb16h1_set_pixel
      16   u8g_pb16h1_set_pixel


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     128  u8g_dev_pb16h1_base_fn
      20  u8g_pb16h1_Clear
       6  u8g_pb16h1_Init
      86  u8g_pb16h1_Set8PixelOpt2
      76  u8g_pb16h1_Set8PixelStd
      38  u8g_pb16h1_SetPixel
      72  u8g_pb16h1_set_pixel

 
 426 bytes in section .text
 
 426 bytes of CODE memory

Errors: none
Warnings: none
