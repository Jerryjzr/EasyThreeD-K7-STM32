###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  22:13:51
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\nano\Drivers\BSP\Components\w25qxx\spi_flash.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWE7CE.tmp
#        (F:\nano\Drivers\BSP\Components\w25qxx\spi_flash.c -D USE_HAL_DRIVER
#        -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D USE_MKS_WIFI
#        --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\spi_flash.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\spi_flash.o
#
###############################################################################

F:\nano\Drivers\BSP\Components\w25qxx\spi_flash.c
      1          /******************** (C) COPYRIGHT 2010 www.armjishu.com ********************
      2          * File Name          : spi_flash.c
      3          * Author             : www.armjishu.com
      4          * Version            : V1.0
      5          * Library            : Using STM32F2XX_STDPERIPH_VERSION V3.3.0
      6          * Date               : 10/16/2010
      7          * Description        : This file provides a set of functions needed to manage the
      8          *                      communication between SPI peripheral and SPI W25X16 FLASH.
      9          *******************************************************************************/
     10          
     11          /* Includes ------------------------------------------------------------------*/
     12          #include "spi.h"
     13          #include "spi_flash.h"

  #define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
          ^
"F:\nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",132  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_DIRECTION_MODE" (declared
          at line 466 of
          "F:\nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
          ^
"F:\nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",146  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_MODE" (declared at line
          459 of
          "F:\nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
          ^
"F:\nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",158  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_DATASIZE" (declared at
          line 488 of
          "F:\nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
          ^
"F:\nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",170  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_CPOL" (declared at line
          496 of
          "F:\nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
          ^
"F:\nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",182  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_CPHA" (declared at line
          504 of
          "F:\nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
          ^
"F:\nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",194  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_NSS" (declared at line 512
          of "F:\nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
          ^
"F:\nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",212  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_BAUDRATE_PRESCALER"
          (declared at line 521 of
          "F:\nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
          ^
"F:\nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",230  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_FIRST_BIT" (declared at
          line 535 of
          "F:\nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
          ^
"F:\nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",408  Warning[Pa181]: 
          incompatible redefinition of macro "SPI_FLAG_CRCERR" (declared at
          line 308 of
          "F:\nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_MODF                   ((uint16_t)0x0020)
          ^
"F:\nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",409  Warning[Pa181]: 
          incompatible redefinition of macro "SPI_FLAG_MODF" (declared at line
          309 of
          "F:\nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
          ^
"F:\nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",425  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_CRC_POLYNOMIAL" (declared
          at line 558 of
          "F:\nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")
     14          #include <stdio.h>
     15          /* Private typedef -----------------------------------------------------------*/
     16          /*********************************************************************************/
     17          #define SPI_FLASH_SPI                   SPI2
     18          #define SPI_FLASH_SPI_CLK               RCC_APB1Periph_SPI2
     19          #define SPI_FLASH_SPI_SCK_PIN           GPIO_Pin_13              /* PA.05 */
     20          #define SPI_FLASH_SPI_SCK_GPIO_PORT     GPIOB
     21          #define SPI_FLASH_SPI_SCK_GPIO_CLK      RCC_APB2Periph_GPIOB
     22          #define SPI_FLASH_SPI_MISO_PIN          GPIO_Pin_14              /* PA.06 */
     23          #define SPI_FLASH_SPI_MISO_GPIO_PORT    GPIOB
     24          #define SPI_FLASH_SPI_MISO_GPIO_CLK     RCC_APB2Periph_GPIOB
     25          #define SPI_FLASH_SPI_MOSI_PIN          GPIO_Pin_15              /* PA.07 */
     26          #define SPI_FLASH_SPI_MOSI_GPIO_PORT    GPIOB
     27          #define SPI_FLASH_SPI_MOSI_GPIO_CLK     RCC_APB2Periph_GPIOB
     28          #define SPI_FLASH_CS_PIN_NUM            9                       /* PB.09 */
     29          #define SPI_FLASH_CS_PIN                GPIO_Pin_9  
     30          #define SPI_FLASH_CS_GPIO_PORT          GPIOG
     31          #define SPI_FLASH_CS_GPIO_CLK           RCC_APB2Periph_GPIOG
     32          
     33          /* Private define ------------------------------------------------------------*/
     34          #define W25X_WriteEnable		0x06 
     35          #define W25X_WriteDisable		0x04 
     36          #define W25X_ReadStatusReg		0x05 
     37          #define W25X_WriteStatusReg		0x01 
     38          #define W25X_ReadData			0x03 
     39          #define W25X_FastReadData		0x0B 
     40          #define W25X_FastReadDual		0x3B 
     41          #define W25X_PageProgram		0x02 
     42          #define W25X_BlockErase			0xD8 
     43          #define W25X_SectorErase		0x20 
     44          #define W25X_ChipErase			0xC7 
     45          #define W25X_PowerDown			0xB9 
     46          #define W25X_ReleasePowerDown	        0xAB 
     47          #define W25X_DeviceID			0xAB 
     48          #define W25X_ManufactDeviceID	        0x90 
     49          #define W25X_JedecDeviceID		0x9F 
     50          
     51          #define WIP_Flag                0x01  /* Write In Progress (WIP) flag */
     52          
     53          #define Dummy_Byte              0xA5
     54          
     55          
     56          #define SPI_FLASH_CS_LOW()        GPIO_ResetBits(GPIOB, GPIO_Pin_12)	//@@@@/CS@@
     57          #define SPI_FLASH_CS_HIGH()       GPIO_SetBits(GPIOB, GPIO_Pin_12)  //@@@@/CS@@
     58          
     59          

   \                                 In section .bss, align 1
     60          uint8_t DMA_ERRO_FLAG = 0;
   \                     DMA_ERRO_FLAG:
   \   00000000                      DS8 1
     61          extern unsigned char bmp_public_buf[16 * 1024];
     62          static uint32_t dummynum = 100000;
                                 ^
Warning[Pe177]: variable "dummynum" was declared but never referenced
     63          static unsigned char tx_buf= 0xff;
                                      ^
Warning[Pe177]: variable "tx_buf" was declared but never referenced
Warning[Ms014]: some characters could not be correctly encoded in
          "F:\nano\EWARM\mksRobinLite\List\spi_flash.s", and have been replaced
          with '@'. The first such character has unicode code point 0x7247
          ("@")
     64          /* Private macro -------------------------------------------------------------*/
     65          /* Private variables ---------------------------------------------------------*/
     66          /* Private function prototypes -----------------------------------------------*/
     67          /* Private functions ---------------------------------------------------------*/
     68          
     69          
     70          
     71          
     72          
     73          //@@@@ID
     74          //@@@@@:				   
     75          //0XEF13,@@@@@@@W25Q80  
     76          //0XEF14,@@@@@@@W25Q16    
     77          //0XEF15,@@@@@@@W25Q32  
     78          //0XEF16,@@@@@@@W25Q64 
     79          //0XEF17,@@@@@@@W25Q128 	  

   \                                 In section .text, align 2, keep-with-next
     80          u16 W25QXX_ReadID(void)
     81          {
   \                     W25QXX_ReadID: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     82          	u16 Temp = 0;	  
     83          	W25QXX_CS=0;				    
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable14  ;; 0x422181b0
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6020             STR      R0,[R4, #+0]
     84          	SPI2_ReadWriteByte(0x90);//@@@@ID@@	    
   \   0000000A   0x2090             MOVS     R0,#+144
   \   0000000C   0x.... 0x....      BL       SPI2_ReadWriteByte
     85          	SPI2_ReadWriteByte(0x00); 	    
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       SPI2_ReadWriteByte
     86          	SPI2_ReadWriteByte(0x00); 	    
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       SPI2_ReadWriteByte
     87          	SPI2_ReadWriteByte(0x00); 	 			   
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       SPI2_ReadWriteByte
     88          	Temp|=SPI2_ReadWriteByte(0xFF)<<8;  
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0x.... 0x....      BL       SPI2_ReadWriteByte
   \   00000028   0x4605             MOV      R5,R0
     89          	Temp|=SPI2_ReadWriteByte(0xFF);	 
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0x.... 0x....      BL       SPI2_ReadWriteByte
   \   00000030   0xEA50 0x2505      ORRS     R5,R0,R5, LSL #+8
     90          	W25QXX_CS=1;				    
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x6020             STR      R0,[R4, #+0]
     91          	return Temp;
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     92          }   		    
     93          
     94          /*******************************************************************************
     95          * Function Name  : SPI_FLASH_SectorErase
     96          * Description    : Erases the specified FLASH sector.
     97          * Input          : SectorAddr: address of the sector to erase.
     98          * Output         : None
     99          * Return         : None
    100          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    101          void SPI_FLASH_SectorErase(u32 SectorAddr)
    102          {
   \                     SPI_FLASH_SectorErase: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    103            /* Send write enable instruction */
    104            SPI_FLASH_WriteEnable();
   \   00000004   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    105          
    106            /* Sector Erase */
    107            /* Select the FLASH: Chip Select low */
    108          	W25QXX_CS=0;
   \   00000008   0x....             LDR.N    R5,??DataTable14  ;; 0x422181b0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x6028             STR      R0,[R5, #+0]
    109            /* Send Sector Erase instruction */
    110            SPI_FLASH_SendByte(W25X_SectorErase);
   \   0000000E   0x2020             MOVS     R0,#+32
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
    111            /* Send SectorAddr high nibble address byte */
    112            SPI_FLASH_SendByte((SectorAddr & 0xFF0000) >> 16);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x0C00             LSRS     R0,R0,#+16
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0x.... 0x....      BL       SPI_FLASH_SendByte
    113            /* Send SectorAddr medium nibble address byte */
    114            SPI_FLASH_SendByte((SectorAddr & 0xFF00) >> 8);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x0A00             LSRS     R0,R0,#+8
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x.... 0x....      BL       SPI_FLASH_SendByte
    115            /* Send SectorAddr low nibble address byte */
    116            SPI_FLASH_SendByte(SectorAddr & 0xFF);
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x.... 0x....      BL       SPI_FLASH_SendByte
    117            /* Deselect the FLASH: Chip Select high */
    118          
    119            W25QXX_CS=1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x6028             STR      R0,[R5, #+0]
    120            /* Wait the end of Flash writing */
    121            SPI_FLASH_WaitForWriteEnd();
   \   00000034   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000038   0x....             B.N      SPI_FLASH_WaitForWriteEnd
    122          }
    123          /**-----------------------------------------------------------------
    124            * @@@@ SPI_FLASH_SectorErase
    125            * @@@   @@SPI FLASH@@@@@@@@@
    126            *         Erases the specified FLASH sector.
    127            * @@@   SectorAddr: @@@@ address of the sector to erase.
    128            * @@@@ @
    129          ***----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    130          void SPI_FLASH_BlockErase(u32 BlockAddr)
    131          {
   \                     SPI_FLASH_BlockErase: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    132              SPI_FLASH_WriteEnable();
   \   00000004   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    133          
    134              /* @@@@@@*/
    135              //SPI_FLASH_CS_LOW();
    136              W25QXX_CS=0;
   \   00000008   0x....             LDR.N    R5,??DataTable14  ;; 0x422181b0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x6028             STR      R0,[R5, #+0]
    137              /* Send Sector Erase instruction */
    138              SPI_FLASH_SendByte(W25X_BlockErase);
   \   0000000E   0x20D8             MOVS     R0,#+216
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
    139              /* Send SectorAddr high nibble address byte */
    140              SPI_FLASH_SendByte((BlockAddr & 0xFF0000) >> 16);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x0C00             LSRS     R0,R0,#+16
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0x.... 0x....      BL       SPI_FLASH_SendByte
    141              /* Send SectorAddr medium nibble address byte */
    142              SPI_FLASH_SendByte((BlockAddr & 0xFF00) >> 8);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x0A00             LSRS     R0,R0,#+8
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x.... 0x....      BL       SPI_FLASH_SendByte
    143              /* Send SectorAddr low nibble address byte */
    144              SPI_FLASH_SendByte(BlockAddr & 0xFF);
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x.... 0x....      BL       SPI_FLASH_SendByte
    145          
    146              /* @@@@@@ */
    147              //SPI_FLASH_CS_HIGH();
    148              W25QXX_CS=1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x6028             STR      R0,[R5, #+0]
    149              /* @@@@SPI@@@@@*/
    150              SPI_FLASH_WaitForWriteEnd();
   \   00000034   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000038   0x....             B.N      SPI_FLASH_WaitForWriteEnd
    151          }
    152          
    153          /*******************************************************************************
    154          * Function Name  : SPI_FLASH_BulkErase
    155          * Description    : Erases the entire FLASH.
    156          * Input          : None
    157          * Output         : None
    158          * Return         : None
    159          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    160          void SPI_FLASH_BulkErase(void)
    161          {
   \                     SPI_FLASH_BulkErase: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    162            /* Send write enable instruction */
    163            SPI_FLASH_WriteEnable();
   \   00000002   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    164          
    165            /* Bulk Erase */
    166            /* Select the FLASH: Chip Select low */
    167          
    168          	W25QXX_CS=0;//SPI_FLASH_CS_LOW();-1
   \   00000006   0x....             LDR.N    R4,??DataTable14  ;; 0x422181b0
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6020             STR      R0,[R4, #+0]
    169            
    170            /* Send Bulk Erase instruction  */
    171            SPI_FLASH_SendByte(W25X_ChipErase);
   \   0000000C   0x20C7             MOVS     R0,#+199
   \   0000000E   0x.... 0x....      BL       SPI_FLASH_SendByte
    172            /* Deselect the FLASH: Chip Select high */
    173          
    174          	W25QXX_CS=1;//SPI_FLASH_CS_HIGH();
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x6020             STR      R0,[R4, #+0]
    175          
    176          
    177            /* Wait the end of Flash writing */
    178            SPI_FLASH_WaitForWriteEnd();
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x....             B.N      SPI_FLASH_WaitForWriteEnd
    179          }
    180          
    181          /*******************************************************************************
    182          * Function Name  : SPI_FLASH_PageWrite
    183          * Description    : Writes more than one byte to the FLASH with a single WRITE
    184          *                  cycle(Page WRITE sequence). The number of byte can't exceed
    185          *                  the FLASH page size.
    186          * Input          : - pBuffer : pointer to the buffer  containing the data to be
    187          *                    written to the FLASH.
    188          *                  - WriteAddr : FLASH's internal address to write to.
    189          *                  - NumByteToWrite : number of bytes to write to the FLASH,
    190          *                    must be equal or less than "SPI_FLASH_PageSize" value.
    191          * Output         : None
    192          * Return         : None
    193          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    194          void SPI_FLASH_PageWrite(u8* pBuffer, u32 WriteAddr, u16 NumByteToWrite)
    195          {
   \                     SPI_FLASH_PageWrite: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
    196            /* Enable the write access to the FLASH */
    197            SPI_FLASH_WriteEnable();
   \   00000008   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    198          
    199            /* Select the FLASH: Chip Select low */
    200            W25QXX_CS=0;
   \   0000000C   0x....             LDR.N    R4,??DataTable14  ;; 0x422181b0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x6020             STR      R0,[R4, #+0]
    201            /* Send "Write to Memory " instruction */
    202            SPI_FLASH_SendByte(W25X_PageProgram);
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x.... 0x....      BL       SPI_FLASH_SendByte
    203            /* Send WriteAddr high nibble address byte to write to */
    204            SPI_FLASH_SendByte((WriteAddr & 0xFF0000) >> 16);
   \   00000018   0x4630             MOV      R0,R6
   \   0000001A   0x0C00             LSRS     R0,R0,#+16
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x.... 0x....      BL       SPI_FLASH_SendByte
    205            /* Send WriteAddr medium nibble address byte to write to */
    206            SPI_FLASH_SendByte((WriteAddr & 0xFF00) >> 8);
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x0A00             LSRS     R0,R0,#+8
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x.... 0x....      BL       SPI_FLASH_SendByte
    207            /* Send WriteAddr low nibble address byte to write to */
    208            SPI_FLASH_SendByte(WriteAddr & 0xFF);
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0xB2C0             UXTB     R0,R0
   \   00000030   0x.... 0x....      BL       SPI_FLASH_SendByte
    209          
    210            if(NumByteToWrite > SPI_FLASH_PerWritePageSize)
   \   00000034   0x4638             MOV      R0,R7
   \   00000036   0xF240 0x1101      MOVW     R1,#+257
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xDB06             BLT.N    ??SPI_FLASH_PageWrite_0
    211            {
    212               NumByteToWrite = SPI_FLASH_PerWritePageSize;
   \   0000003E   0xF44F 0x7780      MOV      R7,#+256
   \   00000042   0xE003             B.N      ??SPI_FLASH_PageWrite_0
    213              // printf("\n\r Err: SPI_FLASH_PageWrite too large!");
    214            }
    215          
    216            /* while there is data to be written on the FLASH */
    217            while (NumByteToWrite--)
    218            {
    219              /* Send the current byte */
    220              SPI_FLASH_SendByte(*pBuffer);
   \                     ??SPI_FLASH_PageWrite_1: (+1)
   \   00000044   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   00000048   0x.... 0x....      BL       SPI_FLASH_SendByte
    221              /* Point on the next byte to be written */
    222              pBuffer++;
    223            }
   \                     ??SPI_FLASH_PageWrite_0: (+1)
   \   0000004C   0x4638             MOV      R0,R7
   \   0000004E   0x1E47             SUBS     R7,R0,#+1
   \   00000050   0xB280             UXTH     R0,R0
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD1F6             BNE.N    ??SPI_FLASH_PageWrite_1
    224          
    225            /* Deselect the FLASH: Chip Select high */
    226            W25QXX_CS=1;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x6020             STR      R0,[R4, #+0]
    227          
    228            /* Wait the end of Flash writing */
    229            SPI_FLASH_WaitForWriteEnd();
   \   0000005A   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   0000005E   0x....             B.N      SPI_FLASH_WaitForWriteEnd
    230          }
    231          
    232          /*******************************************************************************
    233          * Function Name  : SPI_FLASH_BufferWrite
    234          * Description    : Writes block of data to the FLASH. In this function, the
    235          *                  number of WRITE cycles are reduced, using Page WRITE sequence.
    236          * Input          : - pBuffer : pointer to the buffer  containing the data to be
    237          *                    written to the FLASH.
    238          *                  - WriteAddr : FLASH's internal address to write to.
    239          *                  - NumByteToWrite : number of bytes to write to the FLASH.
    240          * Output         : None
    241          * Return         : None
    242          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    243          void SPI_FLASH_BufferWrite(u8* pBuffer, u32 WriteAddr, u16 NumByteToWrite)
    244          {
   \                     SPI_FLASH_BufferWrite: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
    245            u8 NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
    246          
    247            Addr = WriteAddr % SPI_FLASH_PageSize;
   \   00000008   0x4630             MOV      R0,R6
   \   0000000A   0xB2C0             UXTB     R0,R0
    248            count = SPI_FLASH_PageSize - Addr;
   \   0000000C   0x4680             MOV      R8,R0
   \   0000000E   0xF1C8 0x0800      RSB      R8,R8,#+0
   \   00000012   0xFA5F 0xF888      UXTB     R8,R8
    249            NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
   \   00000016   0x4617             MOV      R7,R2
   \   00000018   0x0A3F             LSRS     R7,R7,#+8
    250            NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
   \   0000001A   0x4614             MOV      R4,R2
   \   0000001C   0xB2E4             UXTB     R4,R4
    251          
    252            if (Addr == 0) /* WriteAddr is SPI_FLASH_PageSize aligned  */
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD111             BNE.N    ??SPI_FLASH_BufferWrite_0
    253            {
    254              if (NumOfPage == 0) /* NumByteToWrite < SPI_FLASH_PageSize */
   \   00000022   0x0038             MOVS     R0,R7
   \   00000024   0xD022             BEQ.N    ??SPI_FLASH_BufferWrite_1
    255              {
    256                SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
    257              }
    258              else /* NumByteToWrite > SPI_FLASH_PageSize */
    259              {
    260                while (NumOfPage--)
   \                     ??SPI_FLASH_BufferWrite_2: (+1)
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0x1E47             SUBS     R7,R0,#+1
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD040             BEQ.N    ??SPI_FLASH_BufferWrite_3
    261                {
    262                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
   \   00000030   0xF44F 0x7280      MOV      R2,#+256
   \   00000034   0x4631             MOV      R1,R6
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       SPI_FLASH_PageWrite
    263                  WriteAddr +=  SPI_FLASH_PageSize;
   \   0000003C   0xF506 0x7680      ADD      R6,R6,#+256
    264                  pBuffer += SPI_FLASH_PageSize;
   \   00000040   0xF505 0x7580      ADD      R5,R5,#+256
   \   00000044   0xE7EF             B.N      ??SPI_FLASH_BufferWrite_2
    265                }
    266          
    267                SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
    268              }
    269            }
    270            else /* WriteAddr is not SPI_FLASH_PageSize aligned  */
    271            {
    272              if (NumOfPage == 0) /* NumByteToWrite < SPI_FLASH_PageSize */
   \                     ??SPI_FLASH_BufferWrite_0: (+1)
   \   00000046   0x2F00             CMP      R7,#+0
   \   00000048   0xD114             BNE.N    ??SPI_FLASH_BufferWrite_4
    273              {
    274                if (NumOfSingle > count) /* (NumByteToWrite + WriteAddr) > SPI_FLASH_PageSize */
   \   0000004A   0x45A0             CMP      R8,R4
   \   0000004C   0xDA0E             BGE.N    ??SPI_FLASH_BufferWrite_1
    275                {
    276                  temp = NumOfSingle - count;
    277          
    278                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
   \   0000004E   0x4642             MOV      R2,R8
   \   00000050   0x4628             MOV      R0,R5
   \   00000052   0x.... 0x....      BL       SPI_FLASH_PageWrite
    279                  WriteAddr +=  count;
    280                  pBuffer += count;
    281          
    282                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
   \   00000056   0xEBA4 0x0408      SUB      R4,R4,R8
   \   0000005A   0xB2E4             UXTB     R4,R4
   \   0000005C   0x4622             MOV      R2,R4
   \   0000005E   0x4446             ADD      R6,R8,R6
   \   00000060   0x4631             MOV      R1,R6
   \   00000062   0xEB05 0x0008      ADD      R0,R5,R8
   \   00000066   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000006A   0x....             B.N      SPI_FLASH_PageWrite
    283                }
    284                else
    285                {
    286                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
   \                     ??SPI_FLASH_BufferWrite_1: (+1)
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000072   0x....             B.N      SPI_FLASH_PageWrite
    287                }
    288              }
    289              else /* NumByteToWrite > SPI_FLASH_PageSize */
    290              {
    291                NumByteToWrite -= count;
   \                     ??SPI_FLASH_BufferWrite_4: (+1)
   \   00000074   0xEBA2 0x0208      SUB      R2,R2,R8
    292                NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
   \   00000078   0x4617             MOV      R7,R2
   \   0000007A   0xB2BF             UXTH     R7,R7
   \   0000007C   0x0A3F             LSRS     R7,R7,#+8
    293                NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
   \   0000007E   0xB2D2             UXTB     R2,R2
   \   00000080   0x4614             MOV      R4,R2
    294          
    295                SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
   \   00000082   0x4642             MOV      R2,R8
   \   00000084   0x4628             MOV      R0,R5
   \   00000086   0x.... 0x....      BL       SPI_FLASH_PageWrite
    296                WriteAddr +=  count;
   \   0000008A   0x4446             ADD      R6,R8,R6
    297                pBuffer += count;
   \   0000008C   0x4445             ADD      R5,R5,R8
   \   0000008E   0xE009             B.N      ??SPI_FLASH_BufferWrite_5
    298          
    299                while (NumOfPage--)
    300                {
    301                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
   \                     ??SPI_FLASH_BufferWrite_6: (+1)
   \   00000090   0xF44F 0x7280      MOV      R2,#+256
   \   00000094   0x4631             MOV      R1,R6
   \   00000096   0x4628             MOV      R0,R5
   \   00000098   0x.... 0x....      BL       SPI_FLASH_PageWrite
    302                  WriteAddr +=  SPI_FLASH_PageSize;
   \   0000009C   0xF506 0x7680      ADD      R6,R6,#+256
    303                  pBuffer += SPI_FLASH_PageSize;
   \   000000A0   0xF505 0x7580      ADD      R5,R5,#+256
    304                }
   \                     ??SPI_FLASH_BufferWrite_5: (+1)
   \   000000A4   0x4638             MOV      R0,R7
   \   000000A6   0x1E47             SUBS     R7,R0,#+1
   \   000000A8   0xB2C0             UXTB     R0,R0
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD1F0             BNE.N    ??SPI_FLASH_BufferWrite_6
    305          
    306                if (NumOfSingle != 0)
   \   000000AE   0x2C00             CMP      R4,#+0
   \   000000B0   0xD005             BEQ.N    ??SPI_FLASH_BufferWrite_7
    307                {
    308                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
   \                     ??SPI_FLASH_BufferWrite_3: (+1)
   \   000000B2   0x4622             MOV      R2,R4
   \   000000B4   0x4631             MOV      R1,R6
   \   000000B6   0x4628             MOV      R0,R5
   \   000000B8   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000BC   0x....             B.N      SPI_FLASH_PageWrite
    309                }
    310              }
    311            }
    312          }
   \                     ??SPI_FLASH_BufferWrite_7: (+1)
   \   000000BE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    313          
    314          /*******************************************************************************
    315          * Function Name  : SPI_FLASH_BufferRead
    316          * Description    : Reads a block of data from the FLASH.
    317          * Input          : - pBuffer : pointer to the buffer that receives the data read
    318          *                    from the FLASH.
    319          *                  - ReadAddr : FLASH's internal address to read from.
    320          *                  - NumByteToRead : number of bytes to read from the FLASH.
    321          * Output         : None
    322          * Return         : None
    323          *******************************************************************************/
    324          
    325          /*
    326          STM32F103
    327          SPI2_RX DMA1_Channel 4
    328          SPI2_TX DAM1_Channel 5
    329          STM32F407
    330          SPI1_RX DMA2_Stream0
    331          SPI1_TX DMA2_Stream3
    332          */
    333          extern DMA_HandleTypeDef hdma_spi2_rx;

   \                                 In section .text, align 2, keep-with-next
    334          void SPI_FLASH_BufferRead(u8* pBuffer, u32 ReadAddr, u16 NumByteToRead)
    335          {
   \                     SPI_FLASH_BufferRead: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    336            /* Select the FLASH: Chip Select low */
    337            W25QXX_CS=0;
   \   00000008   0x....             LDR.N    R7,??DataTable14  ;; 0x422181b0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x6038             STR      R0,[R7, #+0]
    338          
    339            /* Send "Read from Memory " instruction */
    340            SPI_FLASH_SendByte(W25X_ReadData);
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
    341          
    342            /* Send ReadAddr high nibble address byte to read from */
    343            SPI_FLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x0C00             LSRS     R0,R0,#+16
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0x.... 0x....      BL       SPI_FLASH_SendByte
    344            /* Send ReadAddr medium nibble address byte to read from */
    345            SPI_FLASH_SendByte((ReadAddr& 0xFF00) >> 8);
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x0A00             LSRS     R0,R0,#+8
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x.... 0x....      BL       SPI_FLASH_SendByte
    346            /* Send ReadAddr low nibble address byte to read from */
    347            SPI_FLASH_SendByte(ReadAddr & 0xFF);
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x.... 0x....      BL       SPI_FLASH_SendByte
    348          
    349          #if defined(MKS_ROBIN)	//F103@@DMA@@@@@@@@@@@@
    350            if(1)	                //F407@@DMA@@@@@@@@@@@
   \   00000030   0xE004             B.N      ??SPI_FLASH_BufferRead_0
    351          #else
    352            if(NumByteToRead<33)	
    353          #endif  
    354            {
    355              while (NumByteToRead--) /* while there is data to be read */
    356              {
    357                /* Read a byte from the FLASH */
    358                *pBuffer = SPI_FLASH_SendByte(Dummy_Byte);
   \                     ??SPI_FLASH_BufferRead_1: (+1)
   \   00000032   0x20A5             MOVS     R0,#+165
   \   00000034   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   00000038   0xF804 0x0B01      STRB     R0,[R4], #+1
    359                /* Point to the next location where the byte read will be saved */
    360                pBuffer++;
    361              }
   \                     ??SPI_FLASH_BufferRead_0: (+1)
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0x1E46             SUBS     R6,R0,#+1
   \   00000040   0xB280             UXTH     R0,R0
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD1F5             BNE.N    ??SPI_FLASH_BufferRead_1
    362            }
    363            else
    364            {
    365                HAL_SPI_Receive_DMA(&hspi2, pBuffer, NumByteToRead);      //@@DMA@@
    366                while(hdma_spi2_rx.State ==HAL_DMA_STATE_BUSY);          //@@DMA@@@@
    367                
    368                //@@@@@@@  void DMA2_Stream2_IRQHandler(void)
    369             }
    370            W25QXX_CS=1;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x6038             STR      R0,[R7, #+0]
    371          }
   \   0000004A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    372          
    373          /*******************************************************************************
    374          * Function Name  : SPI_FLASH_ReadID
    375          * Description    : Reads FLASH identification.
    376          * Input          : None
    377          * Output         : None
    378          * Return         : FLASH identification
    379          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    380          u32 SPI_FLASH_ReadID(void)
    381          {
   \                     SPI_FLASH_ReadID: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    382            u32 Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0;
    383          
    384            /* Select the FLASH: Chip Select low */
    385           
    386          	W25QXX_CS=0;//SPI_FLASH_CS_LOW();-2
   \   00000002   0x....             LDR.N    R4,??DataTable14  ;; 0x422181b0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    387          
    388          
    389            /* Send "RDID " instruction */
    390            SPI_FLASH_SendByte(W25X_JedecDeviceID);
   \   00000008   0x209F             MOVS     R0,#+159
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_SendByte
    391          
    392            /* Read a byte from the FLASH */
    393            Temp0 = SPI_FLASH_SendByte(Dummy_Byte);
   \   0000000E   0x20A5             MOVS     R0,#+165
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   00000014   0x4605             MOV      R5,R0
    394          
    395            /* Read a byte from the FLASH */
    396            Temp1 = SPI_FLASH_SendByte(Dummy_Byte);
   \   00000016   0x20A5             MOVS     R0,#+165
   \   00000018   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   0000001C   0x4606             MOV      R6,R0
   \   0000001E   0x0236             LSLS     R6,R6,#+8
   \   00000020   0xEA46 0x4605      ORR      R6,R6,R5, LSL #+16
    397          
    398            /* Read a byte from the FLASH */
    399            Temp2 = SPI_FLASH_SendByte(Dummy_Byte);
   \   00000024   0x20A5             MOVS     R0,#+165
   \   00000026   0x.... 0x....      BL       SPI_FLASH_SendByte
    400          
    401            /* Deselect the FLASH: Chip Select high */
    402          
    403          	W25QXX_CS=1;//SPI_FLASH_CS_HIGH();
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x6021             STR      R1,[R4, #+0]
    404          
    405          
    406            Temp = (Temp0 << 16) | (Temp1 << 8) | Temp2;
    407          
    408            return Temp;
   \   0000002E   0x4306             ORRS     R6,R0,R6
   \   00000030   0x4630             MOV      R0,R6
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    409          }
    410          /*******************************************************************************
    411          * Function Name  : SPI_FLASH_ReadID
    412          * Description    : Reads FLASH identification.
    413          * Input          : None
    414          * Output         : None
    415          * Return         : FLASH identification
    416          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    417          u32 SPI_FLASH_ReadDeviceID(void)
    418          {
   \                     SPI_FLASH_ReadDeviceID: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    419            u32 Temp = 0;
    420          
    421            /* Select the FLASH: Chip Select low */
    422          
    423          	W25QXX_CS=0;//SPI_FLASH_CS_LOW();-3
   \   00000002   0x....             LDR.N    R4,??DataTable14  ;; 0x422181b0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    424          
    425          
    426            /* Send "RDID " instruction */
    427            SPI_FLASH_SendByte(W25X_DeviceID);
   \   00000008   0x20AB             MOVS     R0,#+171
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_SendByte
    428            SPI_FLASH_SendByte(Dummy_Byte);
   \   0000000E   0x20A5             MOVS     R0,#+165
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
    429            SPI_FLASH_SendByte(Dummy_Byte);
   \   00000014   0x20A5             MOVS     R0,#+165
   \   00000016   0x.... 0x....      BL       SPI_FLASH_SendByte
    430            SPI_FLASH_SendByte(Dummy_Byte);
   \   0000001A   0x20A5             MOVS     R0,#+165
   \   0000001C   0x.... 0x....      BL       SPI_FLASH_SendByte
    431            
    432            /* Read a byte from the FLASH */
    433            Temp = SPI_FLASH_SendByte(Dummy_Byte);
   \   00000020   0x20A5             MOVS     R0,#+165
   \   00000022   0x.... 0x....      BL       SPI_FLASH_SendByte
    434          
    435            /* Deselect the FLASH: Chip Select high */
    436          
    437          	W25QXX_CS=1;//SPI_FLASH_CS_HIGH();
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x6021             STR      R1,[R4, #+0]
    438          
    439          
    440            return Temp;
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    441          }
    442          /*******************************************************************************
    443          * Function Name  : SPI_FLASH_StartReadSequence
    444          * Description    : Initiates a read data byte (READ) sequence from the Flash.
    445          *                  This is done by driving the /CS line low to select the device,
    446          *                  then the READ instruction is transmitted followed by 3 bytes
    447          *                  address. This function exit and keep the /CS line low, so the
    448          *                  Flash still being selected. With this technique the whole
    449          *                  content of the Flash is read with a single READ instruction.
    450          * Input          : - ReadAddr : FLASH's internal address to read from.
    451          * Output         : None
    452          * Return         : None
    453          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    454          void SPI_FLASH_StartReadSequence(u32 ReadAddr)
    455          {
   \                     SPI_FLASH_StartReadSequence: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    456            /* Select the FLASH: Chip Select low */
    457          	W25QXX_CS=0;//SPI_FLASH_CS_LOW();-4
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable14  ;; 0x422181b0
   \   00000008   0x6008             STR      R0,[R1, #+0]
    458            
    459          
    460            /* Send "Read from Memory " instruction */
    461            SPI_FLASH_SendByte(W25X_ReadData);
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x.... 0x....      BL       SPI_FLASH_SendByte
    462          
    463            /* Send the 24-bit address of the address to read from -----------------------*/
    464            /* Send ReadAddr high nibble address byte */
    465            SPI_FLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x0C00             LSRS     R0,R0,#+16
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x.... 0x....      BL       SPI_FLASH_SendByte
    466            /* Send ReadAddr medium nibble address byte */
    467            SPI_FLASH_SendByte((ReadAddr& 0xFF00) >> 8);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x0A00             LSRS     R0,R0,#+8
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x.... 0x....      BL       SPI_FLASH_SendByte
    468            /* Send ReadAddr low nibble address byte */
    469            SPI_FLASH_SendByte(ReadAddr & 0xFF);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002C   0x....             B.N      SPI_FLASH_SendByte
    470          }
    471          
    472          /*******************************************************************************
    473          * Function Name  : SPI_FLASH_ReadByte
    474          * Description    : Reads a byte from the SPI Flash.
    475          *                  This function must be used only if the Start_Read_Sequence
    476          *                  function has been previously called.
    477          * Input          : None
    478          * Output         : None
    479          * Return         : Byte Read from the SPI Flash.
    480          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    481          u8 SPI_FLASH_ReadByte(void)
    482          {
    483            return (SPI_FLASH_SendByte(Dummy_Byte));
   \                     SPI_FLASH_ReadByte: (+1)
   \   00000000   0x20A5             MOVS     R0,#+165
   \   00000002                      REQUIRE SPI_FLASH_SendByte
   \   00000002                      ;; // Fall through to label SPI_FLASH_SendByte
    484          }
    485          
    486          /*******************************************************************************
    487          * Function Name  : SPI_FLASH_SendByte
    488          * Description    : Sends a byte through the SPI interface and return the byte
    489          *                  received from the SPI bus.
    490          * Input          : byte : byte to send.
    491          * Output         : None
    492          * Return         : The value of the received byte.
    493          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    494          u8 SPI_FLASH_SendByte(u8 byte)
    495          {
   \                     SPI_FLASH_SendByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable14_1  ;; 0x40003800
    496            /* Loop while DR register in not emplty */
    497            while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
   \                     ??SPI_FLASH_SendByte_0: (+1)
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD0F9             BEQ.N    ??SPI_FLASH_SendByte_0
    498          
    499            /* Send byte through the SPI1 peripheral */
    500            SPI_I2S_SendData(SPI2, byte);
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       SPI_I2S_SendData
    501          
    502            /* Wait to receive a byte */
    503            while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET);
   \                     ??SPI_FLASH_SendByte_1: (+1)
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F9             BEQ.N    ??SPI_FLASH_SendByte_1
    504          
    505            /* Return the byte read from the SPI bus */
    506            return SPI_I2S_ReceiveData(SPI2);
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       SPI_I2S_ReceiveData
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    507          }
    508          
    509          /*******************************************************************************
    510          * Function Name  : SPI_FLASH_SendHalfWord
    511          * Description    : Sends a Half Word through the SPI interface and return the
    512          *                  Half Word received from the SPI bus.
    513          * Input          : Half Word : Half Word to send.
    514          * Output         : None
    515          * Return         : The value of the received Half Word.
    516          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    517          u16 SPI_FLASH_SendHalfWord(u16 HalfWord)
    518          {
   \                     SPI_FLASH_SendHalfWord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable14_1  ;; 0x40003800
    519            /* Loop while DR register in not emplty */
    520            while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
   \                     ??SPI_FLASH_SendHalfWord_0: (+1)
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD0F9             BEQ.N    ??SPI_FLASH_SendHalfWord_0
    521          
    522            /* Send Half Word through the SPI1 peripheral */
    523            SPI_I2S_SendData(SPI2, HalfWord);
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       SPI_I2S_SendData
    524          
    525            /* Wait to receive a Half Word */
    526            while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET);
   \                     ??SPI_FLASH_SendHalfWord_1: (+1)
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F9             BEQ.N    ??SPI_FLASH_SendHalfWord_1
    527          
    528            /* Return the Half Word read from the SPI bus */
    529            return SPI_I2S_ReceiveData(SPI2);
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002C   0x.... 0x....      B.W      SPI_I2S_ReceiveData
    530          }
    531          
    532          /*******************************************************************************
    533          * Function Name  : SPI_FLASH_WriteEnable
    534          * Description    : Enables the write access to the FLASH.
    535          * Input          : None
    536          * Output         : None
    537          * Return         : None
    538          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    539          void SPI_FLASH_WriteEnable(void)
    540          {
   \                     SPI_FLASH_WriteEnable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    541            /* Select the FLASH: Chip Select low */
    542          
    543          	W25QXX_CS=0;
   \   00000002   0x....             LDR.N    R4,??DataTable14  ;; 0x422181b0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    544            /* Send "Write Enable" instruction */
    545            SPI_FLASH_SendByte(W25X_WriteEnable);
   \   00000008   0x2006             MOVS     R0,#+6
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_SendByte
    546          
    547            /* Deselect the FLASH: Chip Select high */
    548          	W25QXX_CS=1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x6020             STR      R0,[R4, #+0]
    549          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    550          
    551          /*******************************************************************************
    552          * Function Name  : SPI_FLASH_WaitForWriteEnd
    553          * Description    : Polls the status of the Write In Progress (WIP) flag in the
    554          *                  FLASH's status  register  and  loop  until write  opertaion
    555          *                  has completed.
    556          * Input          : None
    557          * Output         : None
    558          * Return         : None
    559          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    560          void SPI_FLASH_WaitForWriteEnd(void)
    561          {
   \                     SPI_FLASH_WaitForWriteEnd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    562            u8 FLASH_Status = 0;
    563          
    564            /* Select the FLASH: Chip Select low */
    565            W25QXX_CS=0;
   \   00000002   0x....             LDR.N    R4,??DataTable14  ;; 0x422181b0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    566            /* Send "Read Status Register" instruction */
    567            SPI_FLASH_SendByte(W25X_ReadStatusReg);
   \   00000008   0x2005             MOVS     R0,#+5
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_SendByte
    568          
    569            /* Loop as long as the memory is busy with a write cycle */
    570            do
    571            {
    572              /* Send a dummy byte to generate the clock needed by the FLASH
    573              and put the value of the status register in FLASH_Status variable */
    574              FLASH_Status = SPI_FLASH_SendByte(Dummy_Byte);
    575          
    576            }
    577            while ((FLASH_Status & WIP_Flag) == SET); /* Write in progress */
   \                     ??SPI_FLASH_WaitForWriteEnd_0: (+1)
   \   0000000E   0x20A5             MOVS     R0,#+165
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   00000014   0x07C0             LSLS     R0,R0,#+31
   \   00000016   0xD4FA             BMI.N    ??SPI_FLASH_WaitForWriteEnd_0
    578          
    579            /* Deselect the FLASH: Chip Select high */
    580            W25QXX_CS=1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x6020             STR      R0,[R4, #+0]
    581          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    582          
    583          
    584          /**-----------------------------------------------------------------
    585            * @@@@ SPI_Flash_PowerDown
    586            * @@@   SPI FLASH@@@@@@
    587            * @@@   @
    588            * @@@@ @
    589          ***----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    590          void SPI_Flash_PowerDown(void)   
    591          { 
   \                     SPI_Flash_PowerDown: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    592            /* Select the FLASH: Chip Select low */
    593           // SPI_FLASH_CS_LOW();
    594              W25QXX_CS=0;
   \   00000002   0x....             LDR.N    R4,??DataTable14  ;; 0x422181b0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    595            /* Send "Power Down" instruction */
    596            SPI_FLASH_SendByte(W25X_PowerDown);
   \   00000008   0x20B9             MOVS     R0,#+185
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_SendByte
    597          
    598            /* Deselect the FLASH: Chip Select high */
    599            //SPI_FLASH_CS_HIGH();
    600              W25QXX_CS=1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x6020             STR      R0,[R4, #+0]
    601          }   
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    602          
    603          /**-----------------------------------------------------------------
    604            * @@@@ SPI_Flash_WAKEUP
    605            * @@@   @@SPI FLASH
    606            * @@@   @
    607            * @@@@ @
    608          ***----------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    609          void SPI_Flash_WAKEUP(void)   
    610          {
   \                     SPI_Flash_WAKEUP: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    611            /* Select the FLASH: Chip Select low */
    612            //SPI_FLASH_CS_LOW();
    613            W25QXX_CS=0;
   \   00000002   0x....             LDR.N    R4,??DataTable14  ;; 0x422181b0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    614            /* Send "Power Down" instruction */
    615            SPI_FLASH_SendByte(W25X_ReleasePowerDown);
   \   00000008   0x20AB             MOVS     R0,#+171
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_SendByte
    616          
    617            /* Deselect the FLASH: Chip Select high */
    618            //SPI_FLASH_CS_HIGH();
    619            W25QXX_CS=1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x6020             STR      R0,[R4, #+0]
    620          }   
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    621          
    622          /**-------------------------------------------------------
    623            * @@@@ Buffercmp
    624            * @@@   @@@@@@@@@@@@@@@@@@@@@
    625            * @@@1  pBuffer1 @ pBuffer2 @@@@@@@@@@@@@
    626            * @@@2  BufferLength @@@@@@@@@@@@@
    627            * @@@@ PASSED: @@@@@@@@@@@@
    628            *         FAILED: @@@@@@@@@@@@@
    629          ***------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    630          TestStatus Buffercmp(u8* pBuffer1, u8* pBuffer2, u16 BufferLength)
    631          {
   \                     Buffercmp: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xE001             B.N      ??Buffercmp_0
    632              while(BufferLength--)
    633              {
    634                  if(*pBuffer1 != *pBuffer2)
    635                  {
    636                      return FAILED;
    637                  }
    638          
    639                  pBuffer1++;
   \                     ??Buffercmp_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
    640                  pBuffer2++;
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \                     ??Buffercmp_0: (+1)
   \   00000008   0x4613             MOV      R3,R2
   \   0000000A   0x1E5A             SUBS     R2,R3,#+1
   \   0000000C   0xB29B             UXTH     R3,R3
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD005             BEQ.N    ??Buffercmp_2
   \   00000012   0x7803             LDRB     R3,[R0, #+0]
   \   00000014   0x780C             LDRB     R4,[R1, #+0]
   \   00000016   0x42A3             CMP      R3,R4
   \   00000018   0xD0F4             BEQ.N    ??Buffercmp_1
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE000             B.N      ??Buffercmp_3
    641              }
    642          
    643              return PASSED;
   \                     ??Buffercmp_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \                     ??Buffercmp_3: (+1)
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    644          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x422181B0         DC32     0x422181b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40003800         DC32     0x40003800
    645          
    646          /******************* (C) COPYRIGHT 2010 www.armjishu.com *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   Buffercmp
      16   SPI_FLASH_BlockErase
        16   -> SPI_FLASH_SendByte
         0   -> SPI_FLASH_WaitForWriteEnd
        16   -> SPI_FLASH_WriteEnable
      24   SPI_FLASH_BufferRead
        24   -> SPI_FLASH_SendByte
      24   SPI_FLASH_BufferWrite
         0   -> SPI_FLASH_PageWrite
        24   -> SPI_FLASH_PageWrite
       8   SPI_FLASH_BulkErase
         8   -> SPI_FLASH_SendByte
         0   -> SPI_FLASH_WaitForWriteEnd
         8   -> SPI_FLASH_WriteEnable
      24   SPI_FLASH_PageWrite
        24   -> SPI_FLASH_SendByte
         0   -> SPI_FLASH_WaitForWriteEnd
        24   -> SPI_FLASH_WriteEnable
       0   SPI_FLASH_ReadByte
         0   -> SPI_FLASH_SendByte
       8   SPI_FLASH_ReadDeviceID
         8   -> SPI_FLASH_SendByte
      16   SPI_FLASH_ReadID
        16   -> SPI_FLASH_SendByte
      16   SPI_FLASH_SectorErase
        16   -> SPI_FLASH_SendByte
         0   -> SPI_FLASH_WaitForWriteEnd
        16   -> SPI_FLASH_WriteEnable
      16   SPI_FLASH_SendByte
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   SPI_FLASH_SendHalfWord
        16   -> SPI_I2S_GetFlagStatus
         0   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
       8   SPI_FLASH_StartReadSequence
         0   -> SPI_FLASH_SendByte
         8   -> SPI_FLASH_SendByte
       8   SPI_FLASH_WaitForWriteEnd
         8   -> SPI_FLASH_SendByte
       8   SPI_FLASH_WriteEnable
         8   -> SPI_FLASH_SendByte
       8   SPI_Flash_PowerDown
         8   -> SPI_FLASH_SendByte
       8   SPI_Flash_WAKEUP
         8   -> SPI_FLASH_SendByte
      16   W25QXX_ReadID
        16   -> SPI2_ReadWriteByte


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
      36  Buffercmp
       1  DMA_ERRO_FLAG
      58  SPI_FLASH_BlockErase
      76  SPI_FLASH_BufferRead
     194  SPI_FLASH_BufferWrite
      28  SPI_FLASH_BulkErase
      96  SPI_FLASH_PageWrite
       2  SPI_FLASH_ReadByte
      44  SPI_FLASH_ReadDeviceID
      52  SPI_FLASH_ReadID
      58  SPI_FLASH_SectorErase
      48  SPI_FLASH_SendByte
      48  SPI_FLASH_SendHalfWord
      46  SPI_FLASH_StartReadSequence
      30  SPI_FLASH_WaitForWriteEnd
      20  SPI_FLASH_WriteEnable
      20  SPI_Flash_PowerDown
      20  SPI_Flash_WAKEUP
      60  W25QXX_ReadID

 
   1 byte  in section .bss
 944 bytes in section .text
 
 944 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: 14
