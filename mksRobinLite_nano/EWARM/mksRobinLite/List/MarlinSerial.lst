###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         07/Apr/2021  11:05:02
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\MarlinSerial.cpp
#    Command line =  
#        -f C:\Users\PLT\AppData\Local\Temp\EW7B83.tmp
#        (C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\MarlinSerial.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lC
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lA
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Src\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/l6474\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/MotorControl\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino/avr\
#        -I C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc/Logo\ -Om --c++
#        --no_exceptions --no_rtti -I "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I "D:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List\MarlinSerial.lst
#    Object file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj\MarlinSerial.o
#
###############################################################################

C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\MarlinSerial.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * MarlinSerial.cpp - Hardware serial library for Wiring
     25           * Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
     26           *
     27           * Modified 23 November 2006 by David A. Mellis
     28           * Modified 28 September 2010 by Mark Sproul
     29           * Modified 14 February 2016 by Andreas Hardtung (added tx buffer)
     30           */
     31          
     32          #include "Marlin.h"

    #define SDSS   18
            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\pins_MKS_ROBIN_LITE.h",161  Warning[Pa181]: 
          incompatible redefinition of macro "SDSS" (declared at line 62)

  #define UNUSED(x) ((void)(x))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pa181]: 
          incompatible redefinition of macro "UNUSED" (declared at line 88 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\macros.h")

   \                                 In section .text, align 2
   \   __interwork __softfp void MarlinSerial::write(uint8_t)
   \                     _ZN12MarlinSerial5writeEh: (+1)
   \        0x0   0xB502             PUSH     {R1,LR}
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x.... 0x....      BL       BSP_UartIfQueueTxData
   \        0xA   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void MarlinSerial::write(char const *)
   \                     _ZN12MarlinSerial5writeEPKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      BL       strlen
   \        0xC   0x4602             MOV      R2,R0
   \        0xE   0xB2D2             UXTB     R2,R2
   \       0x10   0x4629             MOV      R1,R5
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x18   0x.... 0x....      B.W      BSP_UartIfQueueTxData

   \                                 In section .text, align 4
   \   __interwork __softfp void MarlinSerial::print(char const *)
   \                     _ZN12MarlinSerial5printEPKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      BL       strlen
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD013             BEQ.N    ??print_1
   \       0x10   0x480A             LDR.N    R0,??print_0
   \       0x12   0x7800             LDRB     R0,[R0, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??print_2
   \       0x18   0x4629             MOV      R1,R5
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x20   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEPKc
   \                     ??print_2: (+1)
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x.... 0x....      BL       strlen
   \       0x2A   0x4602             MOV      R2,R0
   \       0x2C   0x4629             MOV      R1,R5
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x34   0x.... 0x....      B.W      package_to_wifi
   \                     ??print_1: (+1)
   \       0x38   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \       0x3A   0xBF00             Nop      
   \                     ??print_0:
   \       0x3C   0x....'....        DC32     from_wifi_flag

  #define PRINT_LED_PIN         PDout(2)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\BSP\STM32MKS-3dPrinter\mks_fastio.h",14  Warning[Pa181]: 
          incompatible redefinition of macro "PRINT_LED_PIN" (declared at line
          146 of "C:\Users\PLT\Desktop\mksRobinLite_nano\Inc\main.h")
     33          #include "serial.h"   
     34          //#include "MarlinSerial.h"

   \                                 In section .bss, align 4
     35          char buffer_for_wifi[100];
   \                     buffer_for_wifi:
   \        0x0                      DS8 100
     36          
     37          
     38          /* Global variables ----------------------------------------------------------*/

   \                                 In section .bss, align 4
     39          BspUartDataType gBspUartData;
   \                     gBspUartData:
   \        0x0                      DS8 132
     40          BspUartDataType gBspUartData2;
   \                     gBspUartData2:
   \       0x84                      DS8 132
     41          
     42          #if USE_MKS_USART_TX
     43          uint8_t gBspUartTxBuffer[UART_TX_BUFFER_SIZE]; // real size is double to easily handle memcpy and tx uart
   \                     gBspUartTxBuffer:
   \      0x108                      DS8 256
     44          uint8_t gBspUartRxBuffer[2 * UART_RX_BUFFER_SIZE];
   \                     gBspUartRxBuffer:
   \      0x208                      DS8 512
     45          uint8_t gBspUartTxBuffer2[UART_TX_BUFFER_SIZE/8]; // real size is double to easily handle memcpy and tx uart
   \                     gBspUartTxBuffer2:
   \      0x408                      DS8 32
     46          uint8_t gBspUartRxBuffer2[4 * UART_RX_BUFFER_SIZE];
   \                     gBspUartRxBuffer2:
   \      0x428                      DS8 1024
     47          #else
     48          uint8_t gBspUartTxBuffer[2 * UART_TX_BUFFER_SIZE]; // real size is double to easily handle memcpy and tx uart
     49          uint8_t gBspUartRxBuffer[2 * UART_RX_BUFFER_SIZE];
     50          uint8_t gBspUartTxBuffer2[2 * UART_TX_BUFFER_SIZE]; // real size is double to easily handle memcpy and tx uart
     51          uint8_t gBspUartRxBuffer2[4 * UART_RX_BUFFER_SIZE];
     52          #endif
     53          
     54          
     55          // Disable HardwareSerial.cpp to support chips without a UART (Attiny, etc.)
     56          /*--mks--*/
     57          //#if !defined(USBCON) && (defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H))
     58          
     59            #if UART_PRESENT(SERIAL_PORT)
     60              ring_buffer_r rx_buffer = { { 0 }, 0, 0 };
     61              #if TX_BUFFER_SIZE > 0
     62                ring_buffer_t tx_buffer = { { 0 }, 0, 0 };
     63                static bool _written;
     64              #endif
     65            #endif
     66          
     67            #if ENABLED(EMERGENCY_PARSER)
     68          
     69              #include "stepper.h"
     70              #include "language.h"
     71          
     72              // Currently looking for: M108, M112, M410
     73              // If you alter the parser please don't forget to update the capabilities in Conditionals_post.h
     74          
     75              FORCE_INLINE void emergency_parser(const unsigned char c) {
     76          
     77                static e_parser_state state = state_RESET;
     78          
     79                switch (state) {
     80                  case state_RESET:
     81                    switch (c) {
     82                      case ' ': break;
     83                      case 'N': state = state_N;      break;
     84                      case 'M': state = state_M;      break;
     85                      default: state = state_IGNORE;
     86                    }
     87                    break;
     88          
     89                  case state_N:
     90                    switch (c) {
     91                      case '0': case '1': case '2':
     92                      case '3': case '4': case '5':
     93                      case '6': case '7': case '8':
     94                      case '9': case '-': case ' ':   break;
     95                      case 'M': state = state_M;      break;
     96                      default:  state = state_IGNORE;
     97                    }
     98                    break;
     99          
    100                  case state_M:
    101                    switch (c) {
    102                      case ' ': break;
    103                      case '1': state = state_M1;     break;
    104                      case '4': state = state_M4;     break;
    105                      default: state = state_IGNORE;
    106                    }
    107                    break;
    108          
    109                  case state_M1:
    110                    switch (c) {
    111                      case '0': state = state_M10;    break;
    112                      case '1': state = state_M11;    break;
    113                      default: state = state_IGNORE;
    114                    }
    115                    break;
    116          
    117                  case state_M10:
    118                    state = (c == '8') ? state_M108 : state_IGNORE;
    119                    break;
    120          
    121                  case state_M11:
    122                    state = (c == '2') ? state_M112 : state_IGNORE;
    123                    break;
    124          
    125                  case state_M4:
    126                    state = (c == '1') ? state_M41 : state_IGNORE;
    127                    break;
    128          
    129                  case state_M41:
    130                    state = (c == '0') ? state_M410 : state_IGNORE;
    131                    break;
    132          
    133                  case state_IGNORE:
    134                    if (c == '\n') state = state_RESET;
    135                    break;
    136          
    137                  default:
    138                    if (c == '\n') {
    139                      switch (state) {
    140                        case state_M108:
    141                          wait_for_user = wait_for_heatup = false;
    142                          break;
    143                        case state_M112:
    144                          kill(PSTR(MSG_KILLED));
    145                          break;
    146                        case state_M410:
    147                          quickstop_stepper();
    148                          break;
    149                        default:
    150                          break;
    151                      }
    152                      state = state_RESET;
    153                    }
    154                }
    155              }
    156          
    157            #endif // EMERGENCY_PARSER
    158          #if 0  /*--mks--*/
    159            FORCE_INLINE void store_char(unsigned char c) {
    160              CRITICAL_SECTION_START;
    161                const uint8_t h = rx_buffer.head,
    162                              i = (uint8_t)(h + 1) & (RX_BUFFER_SIZE - 1);
    163          
    164                // if we should be storing the received character into the location
    165                // just before the tail (meaning that the head would advance to the
    166                // current location of the tail), we're about to overflow the buffer
    167                // and so we don't write the character or advance the head.
    168                if (i != rx_buffer.tail) {
    169                  rx_buffer.buffer[h] = c;
    170                  rx_buffer.head = i;
    171                }
    172              CRITICAL_SECTION_END;
    173          
    174              #if ENABLED(EMERGENCY_PARSER)
    175                emergency_parser(c);
    176              #endif
    177            }
    178          #endif
    179          
    180            #if TX_BUFFER_SIZE > 0
    181          
    182              FORCE_INLINE void _tx_udr_empty_irq(void) {
    183                // If interrupts are enabled, there must be more data in the output
    184                // buffer. Send the next byte
    185                const uint8_t t = tx_buffer.tail,
    186                              c = tx_buffer.buffer[t];
    187                tx_buffer.tail = (t + 1) & (TX_BUFFER_SIZE - 1);
    188          
    189                M_UDRx = c;
    190          
    191                // clear the TXC bit -- "can be cleared by writing a one to its bit
    192                // location". This makes sure flush() won't return until the bytes
    193                // actually got written
    194                SBI(M_UCSRxA, M_TXCx);
    195          
    196                if (tx_buffer.head == tx_buffer.tail) {
    197                  // Buffer empty, so disable interrupts
    198                  CBI(M_UCSRxB, M_UDRIEx);
    199                }
    200              }
    201            
    202          #if 0	/*--mks--*/
    203              #ifdef M_USARTx_UDRE_vect
    204                ISR(M_USARTx_UDRE_vect) {
    205                  _tx_udr_empty_irq();
    206                }
    207              #endif
    208          #endif
    209          
    210          
    211            #endif // TX_BUFFER_SIZE
    212          
    213          #if 0	/*--mks--*/
    214            #ifdef M_USARTx_RX_vect
    215              ISR(M_USARTx_RX_vect) {
    216                const unsigned char c = M_UDRx;
    217                store_char(c);
    218              }
    219            #endif
    220          #endif
    221          
    222          
    223            // Public Methods
    224            //flag & 0x1 : interrupt mode
    225            //flag & 0x2 : dma mode

   \                                 In section .text, align 2, keep-with-next
    226             void MarlinSerial::begin(long baud, uint8_t flag) {	/*--mks--*/
   \                     _ZN12MarlinSerial5beginElh: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    227             /*only id = 1 / id= 2 support*/
    228             	resetRxBuffer();
   \        0x8   0x.... 0x....      BL       _ZN12MarlinSerial13resetRxBufferEv
    229          
    230          	BSP_UartHwInit(&uart_stack, baud);
   \        0xC   0x4629             MOV      R1,R5
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       BSP_UartHwInit
    231          	
    232          	BSP_UartIfStart(&uart_stack, flag);
   \       0x14   0x4631             MOV      R1,R6
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x1C   0x.... 0x....      B.W      BSP_UartIfStart
    233          	
    234            }
    235          

   \                                 In section .text, align 2, keep-with-next
    236            void MarlinSerial::end() {	/*--mks--*/
    237           	
    238            	 HAL_UART_DeInit(&uart_stack.pUart->handle);	  
   \                     _ZN12MarlinSerial3endEv: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x3038             ADDS     R0,R0,#+56
   \        0x4   0x.... 0x....      B.W      HAL_UART_DeInit
    239          
    240            }
    241          #if 0	/*--mks--*/
    242            void MarlinSerial::checkRx(void) {
    243              if (TEST(M_UCSRxA, M_RXCx)) {
    244                const uint8_t c = M_UDRx;
    245                store_char(c);
    246              }
    247            }
    248          #endif 	

   \                                 In section .text, align 2, keep-with-next
    249            int MarlinSerial::peek(void) {	/*--mks--*/
    250              /*CRITICAL_SECTION_START;
    251                const int v = rx_buffer.head == rx_buffer.tail ? -1 : rx_buffer.buffer[rx_buffer.tail];
    252              CRITICAL_SECTION_END;
    253              return v;*/
    254              return -1;
   \                     _ZN12MarlinSerial4peekEv: (+1)
   \        0x0   0xF04F 0x30FF      MOV      R0,#-1
   \        0x4   0x4770             BX       LR               ;; return
    255            }
    256          

   \                                 In section .text, align 2, keep-with-next
    257            int MarlinSerial::read(void) {	/*--mks--*/
    258          	  return BSP_UartGetNextRxBytes(&uart_stack);
   \                     _ZN12MarlinSerial4readEv: (+1)
   \        0x0   0x.... 0x....      B.W      BSP_UartGetNextRxBytes
    259            }
    260          

   \                                 In section .text, align 2, keep-with-next
    261            uint32_t MarlinSerial::readNbytes(uint8_t *buf, uint32_t len )
    262            {
    263            	return BSP_UartGetNRxBytes(&uart_stack, buf, len);
   \                     _ZN12MarlinSerial10readNbytesEPhj: (+1)
   \        0x0   0x.... 0x....      B.W      BSP_UartGetNRxBytes
    264            }
    265          #if 0
    266            uint8_t MarlinSerial::available(void) {
    267              CRITICAL_SECTION_START;
    268                const uint8_t h = rx_buffer.head,
    269                              t = rx_buffer.tail;
    270              CRITICAL_SECTION_END;
    271              return (uint8_t)(RX_BUFFER_SIZE + h - t) & (RX_BUFFER_SIZE - 1);
    272            }
    273          #endif

   \                                 In section .text, align 2, keep-with-next
    274            void MarlinSerial::flush(void) {}
   \                     _ZN12MarlinSerial5flushEv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    275          
    276          #ifdef USE_MKS_WIFI

   \                                 In section .text, align 2, keep-with-next
    277            void MarlinSerial::flushRx(void) {
    278          	BSP_UartFlushRx(&uart_stack);
   \                     _ZN12MarlinSerial7flushRxEv: (+1)
   \        0x0   0x.... 0x....      B.W      BSP_UartFlushRx
    279            }
    280          #endif
    281          

   \                                 In section .text, align 2, keep-with-next
    282            void MarlinSerial::resetRxBuffer(void) {
    283            	   /*only id = 1 / id= 2 support*/
    284          	if(uart_stack.id == 1)
   \                     _ZN12MarlinSerial13resetRxBufferEv: (+1)
   \        0x0   0x6841             LDR      R1,[R0, #+4]
   \        0x2   0x2901             CMP      R1,#+1
   \        0x4   0xD111             BNE.N    ??resetRxBuffer_0
    285          	{
    286          		uart_stack.pUart = &gBspUartData;
   \        0x6   0x....             LDR.N    R1,??DataTable4
   \        0x8   0x6001             STR      R1,[R0, #+0]
    287          		uart_stack.pUart->pRxBuffer = (uint8_t *)gBspUartRxBuffer;
   \        0xA   0xF501 0x7202      ADD      R2,R1,#+520
   \        0xE   0x604A             STR      R2,[R1, #+4]
    288          		uart_stack.pUart->pTxBuffer = (uint8_t *)gBspUartTxBuffer;
   \       0x10   0xF501 0x7184      ADD      R1,R1,#+264
   \       0x14   0x6802             LDR      R2,[R0, #+0]
   \       0x16   0x6151             STR      R1,[R2, #+20]
    289          		
    290          		uart_stack.pUart->rxBufferSize = sizeof(gBspUartRxBuffer);
   \       0x18   0xF44F 0x7100      MOV      R1,#+512
   \       0x1C   0x6802             LDR      R2,[R0, #+0]
   \       0x1E   0x6091             STR      R1,[R2, #+8]
    291          		uart_stack.pUart->txBufferSize = sizeof(gBspUartTxBuffer);
   \       0x20   0xF44F 0x7180      MOV      R1,#+256
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x6181             STR      R1,[R0, #+24]
   \       0x28   0x4770             BX       LR
    292             	}
    293          	else if(uart_stack.id == 2)
   \                     ??resetRxBuffer_0: (+1)
   \       0x2A   0x2902             CMP      R1,#+2
   \       0x2C   0xD112             BNE.N    ??resetRxBuffer_1
    294          	{
    295          		uart_stack.pUart = &gBspUartData2;
   \       0x2E   0x....             LDR.N    R1,??DataTable4
   \       0x30   0xF101 0x0284      ADD      R2,R1,#+132
   \       0x34   0x6002             STR      R2,[R0, #+0]
    296          		uart_stack.pUart->pRxBuffer = (uint8_t *)gBspUartRxBuffer2;
   \       0x36   0xF501 0x6285      ADD      R2,R1,#+1064
   \       0x3A   0xF8C1 0x2088      STR      R2,[R1, #+136]
    297          		uart_stack.pUart->pTxBuffer = (uint8_t *)gBspUartTxBuffer2;
   \       0x3E   0xF501 0x6181      ADD      R1,R1,#+1032
   \       0x42   0x6802             LDR      R2,[R0, #+0]
   \       0x44   0x6151             STR      R1,[R2, #+20]
    298          		
    299          		uart_stack.pUart->rxBufferSize = sizeof(gBspUartRxBuffer2);
   \       0x46   0xF44F 0x6180      MOV      R1,#+1024
   \       0x4A   0x6802             LDR      R2,[R0, #+0]
   \       0x4C   0x6091             STR      R1,[R2, #+8]
    300          		uart_stack.pUart->txBufferSize = sizeof(gBspUartTxBuffer2);
   \       0x4E   0x2120             MOVS     R1,#+32
   \       0x50   0x6800             LDR      R0,[R0, #+0]
   \       0x52   0x6181             STR      R1,[R0, #+24]
    301             	}	
    302            }
   \                     ??resetRxBuffer_1: (+1)
   \       0x54   0x4770             BX       LR               ;; return
    303          

   \                                 In section .text, align 2, keep-with-next
    304            uint32_t MarlinSerial::availableForRead() {
    305            	uint32_t tmpW, tmpR;
    306          		
    307          	tmpW = (uint32_t)uart_stack.pUart->pRxBufferWIndex;
   \                     _ZN12MarlinSerial16availableForReadEv: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x68C8             LDR      R0,[R1, #+12]
    308          	tmpR = (uint32_t)uart_stack.pUart->pRxBufferRIndex;
   \        0x4   0x690A             LDR      R2,[R1, #+16]
    309          	
    310          	if(tmpR <= tmpW)
   \        0x6   0x4290             CMP      R0,R2
   \        0x8   0xD301             BCC.N    ??availableForRead_0
    311          		return tmpW - tmpR;
   \        0xA   0x1A80             SUBS     R0,R0,R2
   \        0xC   0x4770             BX       LR
    312          	else
    313          		return tmpW + uart_stack.pUart->rxBufferSize - tmpR;
   \                     ??availableForRead_0: (+1)
   \        0xE   0x6889             LDR      R1,[R1, #+8]
   \       0x10   0x1808             ADDS     R0,R1,R0
   \       0x12   0x1A80             SUBS     R0,R0,R2
   \       0x14   0x4770             BX       LR               ;; return
    314          
    315            }
    316          
    317          
    318          #if 0
    319            #if TX_BUFFER_SIZE > 0
    320              uint8_t MarlinSerial::availableForWrite(void) {
    321                CRITICAL_SECTION_START;
    322                  const uint8_t h = tx_buffer.head,
    323                                t = tx_buffer.tail;
    324                CRITICAL_SECTION_END;
    325                return (uint8_t)(TX_BUFFER_SIZE + h - t) & (TX_BUFFER_SIZE - 1);
    326              }
    327          
    328              void MarlinSerial::write(const uint8_t c) {
    329                _written = true;
    330                CRITICAL_SECTION_START;
    331                  bool emty = (tx_buffer.head == tx_buffer.tail);
    332                CRITICAL_SECTION_END;
    333                // If the buffer and the data register is empty, just write the byte
    334                // to the data register and be done. This shortcut helps
    335                // significantly improve the effective datarate at high (>
    336                // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
    337                if (emty && TEST(M_UCSRxA, M_UDREx)) {
    338                  CRITICAL_SECTION_START;
    339                    M_UDRx = c;
    340                    SBI(M_UCSRxA, M_TXCx);
    341                  CRITICAL_SECTION_END;
    342                  return;
    343                }
    344                const uint8_t i = (tx_buffer.head + 1) & (TX_BUFFER_SIZE - 1);
    345          
    346                // If the output buffer is full, there's nothing for it other than to
    347                // wait for the interrupt handler to empty it a bit
    348                while (i == tx_buffer.tail) {
    349                  if (!TEST(SREG, SREG_I)) {
    350                    // Interrupts are disabled, so we'll have to poll the data
    351                    // register empty flag ourselves. If it is set, pretend an
    352                    // interrupt has happened and call the handler to free up
    353                    // space for us.
    354                    if (TEST(M_UCSRxA, M_UDREx))
    355                      _tx_udr_empty_irq();
    356                  } else {
    357                    // nop, the interrupt handler will free up space for us
    358                  }
    359                }
    360          
    361                tx_buffer.buffer[tx_buffer.head] = c;
    362                { CRITICAL_SECTION_START;
    363                    tx_buffer.head = i;
    364                    SBI(M_UCSRxB, M_UDRIEx);
    365                  CRITICAL_SECTION_END;
    366                }
    367                return;
    368              }
    369          
    370              void MarlinSerial::flushTX(void) {
    371                // TX
    372                // If we have never written a byte, no need to flush. This special
    373                // case is needed since there is no way to force the TXC (transmit
    374                // complete) bit to 1 during initialization
    375                if (!_written)
    376                  return;
    377          
    378                while (TEST(M_UCSRxB, M_UDRIEx) || !TEST(M_UCSRxA, M_TXCx)) {
    379                  if (!TEST(SREG, SREG_I) && TEST(M_UCSRxB, M_UDRIEx))
    380                    // Interrupts are globally disabled, but the DR empty
    381                    // interrupt should be enabled, so poll the DR empty flag to
    382                    // prevent deadlock
    383                    if (TEST(M_UCSRxA, M_UDREx))
    384                      _tx_udr_empty_irq();
    385                }
    386                // If we get here, nothing is queued anymore (DRIE is disabled) and
    387                // the hardware finished tranmission (TXC is set).
    388            }
    389          
    390            #else
    391          #if 0  	/*--mks--*/
    392              void MarlinSerial::write(uint8_t c) {
    393                while (!TEST(M_UCSRxA, M_UDREx))
    394                  ;
    395                M_UDRx = c;
    396              }
    397            #endif
    398          #endif 
    399            // end NEW
    400          
    401            /// imports from print.h
    402          #endif
    403          

   \                                 In section .text, align 2, keep-with-next
    404            void MarlinSerial::print(char c, int base) {
    405              print((long)c, base);
   \                     _ZN12MarlinSerial5printEci: (+1)
   \        0x0   0x....             B.N      _ZN12MarlinSerial5printEli
    406            }
    407          

   \                                 In section .text, align 2, keep-with-next
    408            void MarlinSerial::print(unsigned char b, int base) {
    409              print((unsigned long)b, base);
   \                     _ZN12MarlinSerial5printEhi: (+1)
   \        0x0   0x....             B.N      _ZN12MarlinSerial5printEmi
    410            }
    411          

   \                                 In section .text, align 2, keep-with-next
    412            void MarlinSerial::print(int n, int base) {
    413              print((long)n, base);
   \                     _ZN12MarlinSerial5printEii: (+1)
   \        0x0   0x....             B.N      _ZN12MarlinSerial5printEli
    414            }
    415          

   \                                 In section .text, align 2, keep-with-next
    416            void MarlinSerial::print(unsigned int n, int base) {
    417              print((unsigned long)n, base);
   \                     _ZN12MarlinSerial5printEji: (+1)
   \        0x0   0x....             B.N      _ZN12MarlinSerial5printEmi
    418            }
    419          

   \                                 In section .text, align 2, keep-with-next
    420            void MarlinSerial::print(long n, int base) {
   \                     _ZN12MarlinSerial5printEli: (+1)
   \        0x0   0xB513             PUSH     {R0,R1,R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    421              if (base == 0)
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD10E             BNE.N    ??print_3
    422              {
    423          	if(!from_wifi_flag)
   \        0x8   0x....             LDR.N    R0,??DataTable4_1
   \        0xA   0x7800             LDRB     R0,[R0, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD104             BNE.N    ??print_4
    424          		write(n);
   \       0x10   0xB2C9             UXTB     R1,R1
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x18   0xBD13             POP      {R0,R1,R4,PC}
    425          	else
    426          	{
    427          	/*	if(strlen((char const *)buffer_for_wifi) < sizeof(buffer_for_wifi) - 1)
    428          			strcat(buffer_for_wifi, (char *)&n);
    429          		else
    430          			memset(buffer_for_wifi, 0, sizeof(buffer_for_wifi));*/
    431          #ifdef USE_MKS_WIFI 			
    432          		package_to_wifi(WIFI_TRANS_INF, (char *)&n, 1);
   \                     ??print_4: (+1)
   \       0x1A   0x2201             MOVS     R2,#+1
   \       0x1C   0xA901             ADD      R1,SP,#+4
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x.... 0x....      BL       package_to_wifi
   \       0x24   0xBD13             POP      {R0,R1,R4,PC}
    433          #endif
    434          	}
    435              }
    436              else if (base == 10) {
   \                     ??print_3: (+1)
   \       0x26   0x2A0A             CMP      R2,#+10
   \       0x28   0xD110             BNE.N    ??print_5
    437                if (n < 0) {
   \       0x2A   0x4608             MOV      R0,R1
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD507             BPL.N    ??print_6
    438                  print('-');
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x212D             MOVS     R1,#+45
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
    439                  n = -n;
   \       0x3A   0x9801             LDR      R0,[SP, #+4]
   \       0x3C   0x4240             RSBS     R0,R0,#+0
   \       0x3E   0x9001             STR      R0,[SP, #+4]
    440                }
    441                printNumber(n, 10);
   \                     ??print_6: (+1)
   \       0x40   0x220A             MOVS     R2,#+10
   \       0x42   0x9901             LDR      R1,[SP, #+4]
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0x.... 0x....      BL       _ZN12MarlinSerial11printNumberEmh
   \       0x4A   0xBD13             POP      {R0,R1,R4,PC}
    442              }
    443              else
    444                printNumber(n, base);
   \                     ??print_5: (+1)
   \       0x4C   0xB2D2             UXTB     R2,R2
   \       0x4E   0x.... 0x....      BL       _ZN12MarlinSerial11printNumberEmh
    445            }
   \       0x52   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    446          

   \                                 In section .text, align 2, keep-with-next
    447            void MarlinSerial::print(unsigned long n, int base) {
   \                     _ZN12MarlinSerial5printEmi: (+1)
   \        0x0   0xB502             PUSH     {R1,LR}
    448              if (base == 0) 
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD10E             BNE.N    ??print_7
    449             {
    450          	if(!from_wifi_flag)
   \        0x6   0x....             LDR.N    R1,??DataTable4_1
   \        0x8   0x7809             LDRB     R1,[R1, #+0]
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD104             BNE.N    ??print_8
    451          		write(n);
   \        0xE   0x9900             LDR      R1,[SP, #+0]
   \       0x10   0xB2C9             UXTB     R1,R1
   \       0x12   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x16   0xBD01             POP      {R0,PC}
    452          	else
    453          	{
    454          		/*if(strlen((char const *)buffer_for_wifi) < sizeof(buffer_for_wifi) - 1)
    455          			strcat(buffer_for_wifi, (char *)&n);
    456          		else
    457          			memset(buffer_for_wifi, 0, sizeof(buffer_for_wifi));*/
    458          #ifdef USE_MKS_WIFI 			
    459          		package_to_wifi(WIFI_TRANS_INF, (char *)&n, 1);
   \                     ??print_8: (+1)
   \       0x18   0x2201             MOVS     R2,#+1
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x.... 0x....      BL       package_to_wifi
   \       0x22   0xBD01             POP      {R0,PC}
    460          #endif
    461          	}
    462              }
    463              else printNumber(n, base);
   \                     ??print_7: (+1)
   \       0x24   0xB2D2             UXTB     R2,R2
   \       0x26   0x.... 0x....      BL       _ZN12MarlinSerial11printNumberEmh
    464            }
   \       0x2A   0xBD01             POP      {R0,PC}          ;; return
    465          

   \                                 In section .text, align 2, keep-with-next
    466            void MarlinSerial::print(double n, int digits) {
   \                     _ZN12MarlinSerial5printEdi: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x9902             LDR      R1,[SP, #+8]
    467              printFloat(n, digits);
   \        0x4   0xB2C9             UXTB     R1,R1
   \        0x6   0x9100             STR      R1,[SP, #+0]
   \        0x8   0x.... 0x....      BL       _ZN12MarlinSerial10printFloatEdh
    468            }
   \        0xC   0xBD01             POP      {R0,PC}          ;; return
    469          

   \                                 In section .text, align 2, keep-with-next
    470            void MarlinSerial::println(void) {
   \                     _ZN12MarlinSerial7printlnEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    471              print('\r');
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x210D             MOVS     R1,#+13
   \        0x8   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
    472              print('\n');
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x210A             MOVS     R1,#+10
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0xE8BD 0x4010      POP      {R4,LR}
   \       0x16   0x....             B.N      _ZN12MarlinSerial5printEci
    473            }
    474          #if 0	/*--mks--*/
    475          
    476            void MarlinSerial::println(const String& s) {
    477              print(s);
    478              println();
    479            }
    480          #endif 

   \                                 In section .text, align 2, keep-with-next
    481            void MarlinSerial::println(const char c[]) {
   \                     _ZN12MarlinSerial7printlnEPKc: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    482              print(c);
   \        0x4   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
    483              println();
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x....             B.N      _ZN12MarlinSerial7printlnEv
    484            }
    485          

   \                                 In section .text, align 2, keep-with-next
    486            void MarlinSerial::println(char c, int base) {
   \                     _ZN12MarlinSerial7printlnEci: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    487              print(c, base);
   \        0x4   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
    488              println();
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x....             B.N      _ZN12MarlinSerial7printlnEv
    489            }
    490          

   \                                 In section .text, align 2, keep-with-next
    491            void MarlinSerial::println(unsigned char b, int base) {
   \                     _ZN12MarlinSerial7printlnEhi: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    492              print(b, base);
   \        0x4   0x.... 0x....      BL       _ZN12MarlinSerial5printEhi
    493              println();
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x....             B.N      _ZN12MarlinSerial7printlnEv
    494            }
    495          

   \                                 In section .text, align 2, keep-with-next
    496            void MarlinSerial::println(int n, int base) {
   \                     _ZN12MarlinSerial7printlnEii: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    497              print(n, base);
   \        0x4   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
    498              println();
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x....             B.N      _ZN12MarlinSerial7printlnEv
    499            }
    500          

   \                                 In section .text, align 2, keep-with-next
    501            void MarlinSerial::println(unsigned int n, int base) {
   \                     _ZN12MarlinSerial7printlnEji: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    502              print(n, base);
   \        0x4   0x.... 0x....      BL       _ZN12MarlinSerial5printEji
    503              println();
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x....             B.N      _ZN12MarlinSerial7printlnEv
    504            }
    505          

   \                                 In section .text, align 2, keep-with-next
    506            void MarlinSerial::println(long n, int base) {
   \                     _ZN12MarlinSerial7printlnEli: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    507              print(n, base);
   \        0x4   0x.... 0x....      BL       _ZN12MarlinSerial5printEli
    508              println();
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x....             B.N      _ZN12MarlinSerial7printlnEv
    509            }
    510          

   \                                 In section .text, align 2, keep-with-next
    511            void MarlinSerial::println(unsigned long n, int base) {
   \                     _ZN12MarlinSerial7printlnEmi: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    512              print(n, base);
   \        0x4   0x.... 0x....      BL       _ZN12MarlinSerial5printEmi
    513              println();
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x....             B.N      _ZN12MarlinSerial7printlnEv
    514            }
    515          

   \                                 In section .text, align 2, keep-with-next
    516            void MarlinSerial::println(double n, int digits) {
   \                     _ZN12MarlinSerial7printlnEdi: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x9804             LDR      R0,[SP, #+16]
    517              print(n, digits);
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
    518              println();
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0xE8BD 0x4016      POP      {R1,R2,R4,LR}
   \       0x14   0x....             B.N      _ZN12MarlinSerial7printlnEv
    519            }
    520          
    521            // Private Methods
    522          

   \                                 In section .text, align 2, keep-with-next
    523            void MarlinSerial::printNumber(unsigned long n, uint8_t base) {
   \                     _ZN12MarlinSerial11printNumberEmh: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x4604             MOV      R4,R0
    524              if (n) {
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD024             BEQ.N    ??printNumber_0
    525                unsigned char buf[8 * sizeof(long)]; // Enough space for base 2
    526                int8_t i = 0;
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xE00A             B.N      ??printNumber_1
    527                while (n) {
    528                  buf[i++] = n % base;
   \                     ??printNumber_2: (+1)
   \       0x10   0x4610             MOV      R0,R2
   \       0x12   0xFBB1 0xF3F0      UDIV     R3,R1,R0
   \       0x16   0xFB00 0x1113      MLS      R1,R0,R3,R1
   \       0x1A   0x4668             MOV      R0,SP
   \       0x1C   0x462E             MOV      R6,R5
   \       0x1E   0xB276             SXTB     R6,R6
   \       0x20   0x5581             STRB     R1,[R0, R6]
   \       0x22   0x1C6D             ADDS     R5,R5,#+1
    529                  n /= base;
   \       0x24   0x0019             MOVS     R1,R3
    530                }
   \                     ??printNumber_1: (+1)
   \       0x26   0xD1F3             BNE.N    ??printNumber_2
    531                while (i--)
   \                     ??printNumber_3: (+1)
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x1E45             SUBS     R5,R0,#+1
   \       0x2C   0xB240             SXTB     R0,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD014             BEQ.N    ??printNumber_4
    532                  print((char)(buf[i] + (buf[i] < 10 ? '0' : 'A' - 10)));
   \       0x32   0x4668             MOV      R0,SP
   \       0x34   0x4629             MOV      R1,R5
   \       0x36   0xB249             SXTB     R1,R1
   \       0x38   0x5C41             LDRB     R1,[R0, R1]
   \       0x3A   0x4608             MOV      R0,R1
   \       0x3C   0x280A             CMP      R0,#+10
   \       0x3E   0xDA01             BGE.N    ??printNumber_5
   \       0x40   0x2030             MOVS     R0,#+48
   \       0x42   0xE000             B.N      ??printNumber_6
   \                     ??printNumber_5: (+1)
   \       0x44   0x2037             MOVS     R0,#+55
   \                     ??printNumber_6: (+1)
   \       0x46   0x2200             MOVS     R2,#+0
   \       0x48   0x1841             ADDS     R1,R0,R1
   \       0x4A   0xB249             SXTB     R1,R1
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \       0x52   0xE7E9             B.N      ??printNumber_3
    533              }
    534              else
    535                print('0');
   \                     ??printNumber_0: (+1)
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0x2130             MOVS     R1,#+48
   \       0x58   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
    536            }
   \                     ??printNumber_4: (+1)
   \       0x5C   0xB008             ADD      SP,SP,#+32
   \       0x5E   0xBD70             POP      {R4-R6,PC}       ;; return
    537          

   \                                 In section .text, align 2, keep-with-next
    538            void MarlinSerial::printFloat(double number, uint8_t digits) {
   \                     _ZN12MarlinSerial10printFloatEdh: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x461D             MOV      R5,R3
    539              // Handle negative numbers
    540              if (number < 0.0) {
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x4629             MOV      R1,R5
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x4613             MOV      R3,R2
   \       0x12   0x.... 0x....      BL       __aeabi_cdcmple
   \       0x16   0xD205             BCS.N    ??printFloat_0
    541                print('-');
   \       0x18   0x212D             MOVS     R1,#+45
   \       0x1A   0x4638             MOV      R0,R7
   \       0x1C   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
    542                number = -number;
   \       0x20   0xF085 0x4500      EOR      R5,R5,#0x80000000
    543              }
    544          
    545              // Round correctly so that print(1.999, 2) prints as "2.00"
    546              double rounding = 0.5;
   \                     ??printFloat_0: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x....             LDR.N    R1,??DataTable4_2  ;; 0x3fe00000
    547              for (uint8_t i = 0; i < digits; ++i)
   \       0x28   0x4606             MOV      R6,R0
   \       0x2A   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   \       0x2E   0xE004             B.N      ??printFloat_1
    548                rounding *= 0.1;
   \                     ??printFloat_2: (+1)
   \       0x30   0x....             LDR.N    R2,??DataTable4_3  ;; 0x9999999a
   \       0x32   0x....             LDR.N    R3,??DataTable4_4  ;; 0x3fb99999
   \       0x34   0x.... 0x....      BL       __aeabi_dmul
   \       0x38   0x1C76             ADDS     R6,R6,#+1
   \                     ??printFloat_1: (+1)
   \       0x3A   0x4632             MOV      R2,R6
   \       0x3C   0x4643             MOV      R3,R8
   \       0x3E   0xB2D2             UXTB     R2,R2
   \       0x40   0x429A             CMP      R2,R3
   \       0x42   0xD3F5             BCC.N    ??printFloat_2
   \       0x44   0x4646             MOV      R6,R8
    549          
    550              number += rounding;
   \       0x46   0x4622             MOV      R2,R4
   \       0x48   0x462B             MOV      R3,R5
   \       0x4A   0x.... 0x....      BL       __aeabi_dadd
   \       0x4E   0x4604             MOV      R4,R0
   \       0x50   0x460D             MOV      R5,R1
    551          
    552              // Extract the integer part of the number and print it
    553              unsigned long int_part = (unsigned long)number;
   \       0x52   0x.... 0x....      BL       __aeabi_d2uiz
   \       0x56   0x4680             MOV      R8,R0
    554              double remainder = number - (double)int_part;
   \       0x58   0x.... 0x....      BL       __aeabi_ui2d
   \       0x5C   0x4602             MOV      R2,R0
   \       0x5E   0x460B             MOV      R3,R1
   \       0x60   0x4620             MOV      R0,R4
   \       0x62   0x4629             MOV      R1,R5
   \       0x64   0x.... 0x....      BL       __aeabi_dsub
   \       0x68   0x4604             MOV      R4,R0
   \       0x6A   0x460D             MOV      R5,R1
    555              print(int_part);
   \       0x6C   0x220A             MOVS     R2,#+10
   \       0x6E   0x4641             MOV      R1,R8
   \       0x70   0x4638             MOV      R0,R7
   \       0x72   0x.... 0x....      BL       _ZN12MarlinSerial5printEmi
    556          
    557              // Print the decimal point, but only if there are digits beyond
    558              if (digits) {
   \       0x76   0x0030             MOVS     R0,R6
   \       0x78   0xD023             BEQ.N    ??printFloat_3
    559                print('.');
   \       0x7A   0x2200             MOVS     R2,#+0
   \       0x7C   0x212E             MOVS     R1,#+46
   \       0x7E   0x4638             MOV      R0,R7
   \       0x80   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \       0x84   0x4620             MOV      R0,R4
   \       0x86   0x4629             MOV      R1,R5
   \       0x88   0xE016             B.N      ??printFloat_4
    560                // Extract digits from the remainder one at a time
    561                while (digits--) {
    562                  remainder *= 10.0;
   \                     ??printFloat_5: (+1)
   \       0x8A   0x2200             MOVS     R2,#+0
   \       0x8C   0x....             LDR.N    R3,??DataTable4_5  ;; 0x40240000
   \       0x8E   0x.... 0x....      BL       __aeabi_dmul
   \       0x92   0x4604             MOV      R4,R0
   \       0x94   0x460D             MOV      R5,R1
    563                  int toPrint = int(remainder);
   \       0x96   0x.... 0x....      BL       __aeabi_d2iz
   \       0x9A   0x4680             MOV      R8,R0
    564                  print(toPrint);
   \       0x9C   0x220A             MOVS     R2,#+10
   \       0x9E   0x4641             MOV      R1,R8
   \       0xA0   0x4638             MOV      R0,R7
   \       0xA2   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
    565                  remainder -= toPrint;
   \       0xA6   0x4640             MOV      R0,R8
   \       0xA8   0x.... 0x....      BL       __aeabi_i2d
   \       0xAC   0x4602             MOV      R2,R0
   \       0xAE   0x460B             MOV      R3,R1
   \       0xB0   0x4620             MOV      R0,R4
   \       0xB2   0x4629             MOV      R1,R5
   \       0xB4   0x.... 0x....      BL       __aeabi_dsub
    566                }
   \                     ??printFloat_4: (+1)
   \       0xB8   0x4632             MOV      R2,R6
   \       0xBA   0x1E56             SUBS     R6,R2,#+1
   \       0xBC   0xB2D2             UXTB     R2,R2
   \       0xBE   0x2A00             CMP      R2,#+0
   \       0xC0   0xD1E3             BNE.N    ??printFloat_5
    567              }
    568            }
   \                     ??printFloat_3: (+1)
   \       0xC2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    569          

   \                                 In section .text, align 2, keep-with-next
    570            BSP_UART_STACK *MarlinSerial::getUartStack()
    571            {
    572            	return (BSP_UART_STACK *)&uart_stack;  	
   \                     _ZN12MarlinSerial12getUartStackEv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    573            }
    574          
    575            // Preinstantiate

   \                                 In section .data, align 4
    576            MarlinSerial customizedSerial(1);
   \                     customizedSerial:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \        0x4   0x0000'0001        DC32 1
    577          #ifdef USE_MKS_WIFI

   \                                 In section .data, align 4
    578            MarlinSerial serial2(2);
   \                     serial2:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \        0x4   0x0000'0002        DC32 2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x....'....        DC32     gBspUartData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x....'....        DC32     from_wifi_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x3FE0'0000        DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x9999'999A        DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x3FB9'9999        DC32     0x3fb99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x4024'0000        DC32     0x40240000
    579          #endif
    580          /*--mks--*/
    581          //#endif // !USBCON && (UBRRH || UBRR0H || UBRR1H || UBRR2H || UBRR3H)
    582          
    583          // For AT90USB targets use the UART for BT interfacing
    584          #if defined(USBCON) && ENABLED(BLUETOOTH)
    585            HardwareSerial bluetoothSerial;
    586          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MarlinSerial::availableForRead()
      16   MarlinSerial::begin(long, uint8_t)
        16   -> BSP_UartHwInit
         0   -> BSP_UartIfStart
        16   -> MarlinSerial::resetRxBuffer()
       0   MarlinSerial::end()
         0   -> HAL_UART_DeInit
       0   MarlinSerial::flush()
       0   MarlinSerial::flushRx()
         0   -> BSP_UartFlushRx
       0   MarlinSerial::getUartStack()
       0   MarlinSerial::peek()
      16   MarlinSerial::print(char const *)
         0   -> MarlinSerial::write(char const *)
         0   -> package_to_wifi
        16   -> strlen
       0   MarlinSerial::print(char, int)
         0   -> MarlinSerial::print(long, int)
       8   MarlinSerial::print(double, int)
         8   -> MarlinSerial::printFloat(double, uint8_t)
       0   MarlinSerial::print(int, int)
         0   -> MarlinSerial::print(long, int)
      16   MarlinSerial::print(long, int)
        16   -> MarlinSerial::print(char, int)
        16   -> MarlinSerial::printNumber(unsigned long, uint8_t)
        16   -> MarlinSerial::write(uint8_t)
        16   -> package_to_wifi
       0   MarlinSerial::print(unsigned char, int)
         0   -> MarlinSerial::print(unsigned long, int)
       0   MarlinSerial::print(unsigned int, int)
         0   -> MarlinSerial::print(unsigned long, int)
       8   MarlinSerial::print(unsigned long, int)
         8   -> MarlinSerial::printNumber(unsigned long, uint8_t)
         8   -> MarlinSerial::write(uint8_t)
         8   -> package_to_wifi
      24   MarlinSerial::printFloat(double, uint8_t)
        24   -> MarlinSerial::print(char, int)
        24   -> MarlinSerial::print(int, int)
        24   -> MarlinSerial::print(unsigned long, int)
        24   -> __aeabi_d2iz
        24   -> __aeabi_d2uiz
        24   -> __aeabi_dadd
        24   -> __aeabi_dmul
        24   -> __aeabi_dsub
        24   -> __aeabi_i2d
        24   -> __aeabi_ui2d
        24 __aeabi_cdcmple
      48   MarlinSerial::printNumber(unsigned long, uint8_t)
        48   -> MarlinSerial::print(char, int)
       8   MarlinSerial::println()
         0   -> MarlinSerial::print(char, int)
         8   -> MarlinSerial::print(char, int)
       8   MarlinSerial::println(char const *)
         8   -> MarlinSerial::print(char const *)
         0   -> MarlinSerial::println()
       8   MarlinSerial::println(char, int)
         8   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::println()
      16   MarlinSerial::println(double, int)
        16   -> MarlinSerial::print(double, int)
         0   -> MarlinSerial::println()
       8   MarlinSerial::println(int, int)
         8   -> MarlinSerial::print(int, int)
         0   -> MarlinSerial::println()
       8   MarlinSerial::println(long, int)
         8   -> MarlinSerial::print(long, int)
         0   -> MarlinSerial::println()
       8   MarlinSerial::println(unsigned char, int)
         8   -> MarlinSerial::print(unsigned char, int)
         0   -> MarlinSerial::println()
       8   MarlinSerial::println(unsigned int, int)
         8   -> MarlinSerial::print(unsigned int, int)
         0   -> MarlinSerial::println()
       8   MarlinSerial::println(unsigned long, int)
         8   -> MarlinSerial::print(unsigned long, int)
         0   -> MarlinSerial::println()
       0   MarlinSerial::read()
         0   -> BSP_UartGetNextRxBytes
       0   MarlinSerial::readNbytes(uint8_t *, uint32_t)
         0   -> BSP_UartGetNRxBytes
       0   MarlinSerial::resetRxBuffer()
      16   MarlinSerial::write(char const *)
         0   -> BSP_UartIfQueueTxData
        16   -> strlen
       8   MarlinSerial::write(uint8_t)
         8   -> BSP_UartIfQueueTxData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
      22  MarlinSerial::availableForRead()
      32  MarlinSerial::begin(long, uint8_t)
       8  MarlinSerial::end()
       2  MarlinSerial::flush()
       4  MarlinSerial::flushRx()
       2  MarlinSerial::getUartStack()
       6  MarlinSerial::peek()
      64  MarlinSerial::print(char const *)
       2  MarlinSerial::print(char, int)
      14  MarlinSerial::print(double, int)
       2  MarlinSerial::print(int, int)
      84  MarlinSerial::print(long, int)
       2  MarlinSerial::print(unsigned char, int)
       2  MarlinSerial::print(unsigned int, int)
      44  MarlinSerial::print(unsigned long, int)
     198  MarlinSerial::printFloat(double, uint8_t)
      96  MarlinSerial::printNumber(unsigned long, uint8_t)
      24  MarlinSerial::println()
      16  MarlinSerial::println(char const *)
      16  MarlinSerial::println(char, int)
      22  MarlinSerial::println(double, int)
      16  MarlinSerial::println(int, int)
      16  MarlinSerial::println(long, int)
      16  MarlinSerial::println(unsigned char, int)
      16  MarlinSerial::println(unsigned int, int)
      16  MarlinSerial::println(unsigned long, int)
       4  MarlinSerial::read()
       4  MarlinSerial::readNbytes(uint8_t *, uint32_t)
      86  MarlinSerial::resetRxBuffer()
      28  MarlinSerial::write(char const *)
      12  MarlinSerial::write(uint8_t)
     100  buffer_for_wifi
       8  customizedSerial
    2088  gBspUartData
          gBspUartData2
          gBspUartTxBuffer
          gBspUartRxBuffer
          gBspUartTxBuffer2
          gBspUartRxBuffer2
       8  serial2

 
 2 188 bytes in section .bss
    16 bytes in section .data
   900 bytes in section .text
 
   796 bytes of CODE memory (+ 104 bytes shared)
 2 204 bytes of DATA memory

Errors: none
Warnings: 3
