###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  21:37:10
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_font.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EW4CED.tmp
#        (F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_font.c -D
#        USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\u8g_font.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\u8g_font.o
#
###############################################################################

F:\nano\Middlewares\Third_Party\u8glib_arm_v1.17\src\u8g_font.c
      1          /*
      2          
      3            u8g_font.c
      4            
      5            U8G Font High Level Interface
      6          
      7            Universal 8bit Graphics Library
      8            
      9            Copyright (c) 2011, olikraus@gmail.com
     10            All rights reserved.
     11          
     12            Redistribution and use in source and binary forms, with or without modification, 
     13            are permitted provided that the following conditions are met:
     14          
     15            * Redistributions of source code must retain the above copyright notice, this list 
     16              of conditions and the following disclaimer.
     17              
     18            * Redistributions in binary form must reproduce the above copyright notice, this 
     19              list of conditions and the following disclaimer in the documentation and/or other 
     20              materials provided with the distribution.
     21          
     22            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
     23            CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
     24            INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
     25            MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
     26            DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
     27            CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     28            SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
     29            NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
     30            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
     31            CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
     32            STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
     33            ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
     34            ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
     35            
     36          */
     37          
     38          #include "u8g.h"
     39          
     40          /* font api */
     41          
     42          /* pointer to the start adress of the glyph, points to progmem area */
     43          typedef void * u8g_glyph_t;
     44          
     45          /* size of the font data structure, there is no struct or class... */
     46          #define U8G_FONT_DATA_STRUCT_SIZE 17
     47          
     48          /*
     49            ... instead the fields of the font data structure are accessed directly by offset 
     50            font information 
     51            offset
     52            0             font format
     53            1             FONTBOUNDINGBOX width           unsigned
     54            2             FONTBOUNDINGBOX height          unsigned
     55            3             FONTBOUNDINGBOX x-offset         signed
     56            4             FONTBOUNDINGBOX y-offset        signed
     57            5             capital A height                                unsigned
     58            6             start 'A'
     59            8             start 'a'
     60            10            encoding start
     61            11            encoding end
     62            12            descent 'g'                     negative: below baseline
     63            13            font max ascent
     64            14            font min decent             negative: below baseline 
     65            15            font xascent
     66            16            font xdecent             negative: below baseline 
     67            
     68          */
     69          
     70          /* use case: What is the width and the height of the minimal box into which string s fints? */
     71          void u8g_font_GetStrSize(const void *font, const char *s, u8g_uint_t *width, u8g_uint_t *height);
     72          void u8g_font_GetStrSizeP(const void *font, const char *s, u8g_uint_t *width, u8g_uint_t *height);
     73          
     74          /* use case: lower left edge of a minimal box is known, what is the correct x, y position for the string draw procedure */
     75          void u8g_font_AdjustXYToDraw(const void *font, const char *s, u8g_uint_t *x, u8g_uint_t *y);
     76          void u8g_font_AdjustXYToDrawP(const void *font, const char *s, u8g_uint_t *x, u8g_uint_t *y);
     77          
     78          /* use case: Baseline origin known, return minimal box */
     79          void u8g_font_GetStrMinBox(u8g_t *u8g, const void *font, const char *s, u8g_uint_t *x, u8g_uint_t *y, u8g_uint_t *width, u8g_uint_t *height);
     80          
     81          /* procedures */
     82          
     83          /*========================================================================*/
     84          /* low level byte and word access */
     85          
     86          /* removed NOINLINE, because it leads to smaller code, might also be faster */
     87          //static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE;

   \                                 In section .text, align 2, keep-with-next
     88          static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset)
     89          {
     90            font += offset;
     91            return u8g_pgm_read( (u8g_pgm_uint8_t *)font );  
   \                     u8g_font_get_byte: (+1)
   \   00000000   0x5C40             LDRB     R0,[R0, R1]
   \   00000002   0x4770             BX       LR               ;; return
     92          }
     93          
     94          static uint16_t u8g_font_get_word(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE; 

   \                                 In section .text, align 2, keep-with-next
     95          static uint16_t u8g_font_get_word(const u8g_fntpgm_uint8_t *font, uint8_t offset)
     96          {
     97              uint16_t pos;
     98              font += offset;
   \                     u8g_font_get_word: (+1)
   \   00000000   0x4408             ADD      R0,R0,R1
     99              pos = u8g_pgm_read( (u8g_pgm_uint8_t *)font );
    100              font++;
    101              pos <<= 8;
    102              pos += u8g_pgm_read( (u8g_pgm_uint8_t *)font);
    103              return pos;
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   0000000A   0xB280             UXTH     R0,R0
   \   0000000C   0x4770             BX       LR               ;; return
    104          }
    105          
    106          /*========================================================================*/
    107          /* direct access on the font */
    108          
    109          static uint8_t u8g_font_GetFormat(const u8g_fntpgm_uint8_t *font) U8G_NOINLINE;

   \                                 In section .text, align 2, keep-with-next
    110          static uint8_t u8g_font_GetFormat(const u8g_fntpgm_uint8_t *font)
    111          {
    112            return u8g_font_get_byte(font, 0);
   \                     u8g_font_GetFormat: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      u8g_font_get_byte
    113          }
    114          
    115          static uint8_t u8g_font_GetFontGlyphStructureSize(const u8g_fntpgm_uint8_t *font) U8G_NOINLINE;

   \                                 In section .text, align 2, keep-with-next
    116          static uint8_t u8g_font_GetFontGlyphStructureSize(const u8g_fntpgm_uint8_t *font)
    117          {
   \                     u8g_font_GetFontGlyphStructureSize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    118            switch(u8g_font_GetFormat(font))
   \   00000002   0x.... 0x....      BL       u8g_font_GetFormat
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ.N    ??u8g_font_GetFontGlyphStructureSize_0
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD101             BNE.N    ??u8g_font_GetFontGlyphStructureSize_1
    119            {
    120              case 0: return 6;
    121              case 1: return 3;
    122              case 2: return 6;
   \                     ??u8g_font_GetFontGlyphStructureSize_0: (+1)
   \   0000000E   0x2006             MOVS     R0,#+6
   \   00000010   0xBD02             POP      {R1,PC}
    123            }
    124            return 3;
   \                     ??u8g_font_GetFontGlyphStructureSize_1: (+1)
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    125          }
    126          

   \                                 In section .text, align 2, keep-with-next
    127          static uint8_t u8g_font_GetBBXWidth(const void *font)
    128          {
    129            return u8g_font_get_byte(font, 1);
   \                     u8g_font_GetBBXWidth: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             B.N      u8g_font_get_byte
    130          }
    131          

   \                                 In section .text, align 2, keep-with-next
    132          static uint8_t u8g_font_GetBBXHeight(const void *font)
    133          {
    134            return u8g_font_get_byte(font, 2);
   \                     u8g_font_GetBBXHeight: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0x....             B.N      u8g_font_get_byte
    135          }
    136          

   \                                 In section .text, align 2, keep-with-next
    137          static int8_t u8g_font_GetBBXOffX(const void *font)
    138          {
   \                     u8g_font_GetBBXOffX: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    139            return u8g_font_get_byte(font, 3);
   \   00000002   0x2103             MOVS     R1,#+3
   \   00000004   0x.... 0x....      BL       u8g_font_get_byte
   \   00000008   0xB240             SXTB     R0,R0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    140          }
    141          

   \                                 In section .text, align 2, keep-with-next
    142          static int8_t u8g_font_GetBBXOffY(const void *font)
    143          {
   \                     u8g_font_GetBBXOffY: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    144            return u8g_font_get_byte(font, 4);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x.... 0x....      BL       u8g_font_get_byte
   \   00000008   0xB240             SXTB     R0,R0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    145          }
    146          

   \                                 In section .text, align 2, keep-with-next
    147          uint8_t u8g_font_GetCapitalAHeight(const void *font)
    148          {
    149            return u8g_font_get_byte(font, 5);
   \                     u8g_font_GetCapitalAHeight: (+1)
   \   00000000   0x2105             MOVS     R1,#+5
   \   00000002   0x....             B.N      u8g_font_get_byte
    150          }
    151          
    152          uint16_t u8g_font_GetEncoding65Pos(const void *font) U8G_NOINLINE;

   \                                 In section .text, align 2, keep-with-next
    153          uint16_t u8g_font_GetEncoding65Pos(const void *font)
    154          {
    155              return u8g_font_get_word(font, 6);
   \                     u8g_font_GetEncoding65Pos: (+1)
   \   00000000   0x2106             MOVS     R1,#+6
   \   00000002   0x....             B.N      u8g_font_get_word
    156          }
    157          
    158          uint16_t u8g_font_GetEncoding97Pos(const void *font) U8G_NOINLINE;

   \                                 In section .text, align 2, keep-with-next
    159          uint16_t u8g_font_GetEncoding97Pos(const void *font)
    160          {
    161              return u8g_font_get_word(font, 8);
   \                     u8g_font_GetEncoding97Pos: (+1)
   \   00000000   0x2108             MOVS     R1,#+8
   \   00000002   0x....             B.N      u8g_font_get_word
    162          }
    163          

   \                                 In section .text, align 2, keep-with-next
    164          uint8_t u8g_font_GetFontStartEncoding(const void *font)
    165          {
    166            return u8g_font_get_byte(font, 10);
   \                     u8g_font_GetFontStartEncoding: (+1)
   \   00000000   0x210A             MOVS     R1,#+10
   \   00000002   0x....             B.N      u8g_font_get_byte
    167          }
    168          

   \                                 In section .text, align 2, keep-with-next
    169          uint8_t u8g_font_GetFontEndEncoding(const void *font)
    170          {
    171            return u8g_font_get_byte(font, 11);
   \                     u8g_font_GetFontEndEncoding: (+1)
   \   00000000   0x210B             MOVS     R1,#+11
   \   00000002   0x....             B.N      u8g_font_get_byte
    172          }
    173          

   \                                 In section .text, align 2, keep-with-next
    174          int8_t u8g_font_GetLowerGDescent(const void *font)
    175          {
   \                     u8g_font_GetLowerGDescent: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    176            return u8g_font_get_byte(font, 12);
   \   00000002   0x210C             MOVS     R1,#+12
   \   00000004   0x.... 0x....      BL       u8g_font_get_byte
   \   00000008   0xB240             SXTB     R0,R0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    177          }
    178          

   \                                 In section .text, align 2, keep-with-next
    179          int8_t u8g_font_GetFontAscent(const void *font)
    180          {
   \                     u8g_font_GetFontAscent: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    181            return u8g_font_get_byte(font, 13);
   \   00000002   0x210D             MOVS     R1,#+13
   \   00000004   0x.... 0x....      BL       u8g_font_get_byte
   \   00000008   0xB240             SXTB     R0,R0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    182          }
    183          

   \                                 In section .text, align 2, keep-with-next
    184          int8_t u8g_font_GetFontDescent(const void *font)
    185          {
   \                     u8g_font_GetFontDescent: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    186            return u8g_font_get_byte(font, 14);
   \   00000002   0x210E             MOVS     R1,#+14
   \   00000004   0x.... 0x....      BL       u8g_font_get_byte
   \   00000008   0xB240             SXTB     R0,R0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    187          }
    188          

   \                                 In section .text, align 2, keep-with-next
    189          int8_t u8g_font_GetFontXAscent(const void *font)
    190          {
   \                     u8g_font_GetFontXAscent: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    191            return u8g_font_get_byte(font, 15);
   \   00000002   0x210F             MOVS     R1,#+15
   \   00000004   0x.... 0x....      BL       u8g_font_get_byte
   \   00000008   0xB240             SXTB     R0,R0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    192          }
    193          

   \                                 In section .text, align 2, keep-with-next
    194          int8_t u8g_font_GetFontXDescent(const void *font)
    195          {
   \                     u8g_font_GetFontXDescent: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    196            return u8g_font_get_byte(font, 16);
   \   00000002   0x2110             MOVS     R1,#+16
   \   00000004   0x.... 0x....      BL       u8g_font_get_byte
   \   00000008   0xB240             SXTB     R0,R0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    197          }
    198          
    199          
    200          /* return the data start for a font and the glyph pointer */

   \                                 In section .text, align 2, keep-with-next
    201          static uint8_t *u8g_font_GetGlyphDataStart(const void *font, u8g_glyph_t g)
    202          {
   \                     u8g_font_GetGlyphDataStart: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    203            return ((u8g_fntpgm_uint8_t *)g) + u8g_font_GetFontGlyphStructureSize(font);
   \   00000004   0x.... 0x....      BL       u8g_font_GetFontGlyphStructureSize
   \   00000008   0x4420             ADD      R0,R4,R0
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    204          }
    205          
    206          /* calculate the overall length of the font, only used to create the picture for the google wiki */

   \                                 In section .text, align 2, keep-with-next
    207          size_t u8g_font_GetSize(const void *font)
    208          {
   \                     u8g_font_GetSize: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
    209            uint8_t *p = (uint8_t *)(font);
    210            uint8_t font_format = u8g_font_GetFormat(font);
   \   00000006   0x.... 0x....      BL       u8g_font_GetFormat
   \   0000000A   0x4680             MOV      R8,R0
    211            uint8_t data_structure_size = u8g_font_GetFontGlyphStructureSize(font);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       u8g_font_GetFontGlyphStructureSize
   \   00000012   0x4605             MOV      R5,R0
    212            uint8_t start, end;
    213            uint8_t i;
    214            uint8_t mask = 255;
   \   00000014   0x26FF             MOVS     R6,#+255
    215            
    216            start = u8g_font_GetFontStartEncoding(font);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       u8g_font_GetFontStartEncoding
   \   0000001C   0x4607             MOV      R7,R0
    217            end = u8g_font_GetFontEndEncoding(font);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       u8g_font_GetFontEndEncoding
    218          
    219            if ( font_format == 1 )
   \   00000024   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000028   0xD100             BNE.N    ??u8g_font_GetSize_0
    220              mask = 15;
   \   0000002A   0x260F             MOVS     R6,#+15
    221          
    222            p += U8G_FONT_DATA_STRUCT_SIZE;       /* skip font general information */  
   \                     ??u8g_font_GetSize_0: (+1)
   \   0000002C   0xF104 0x0111      ADD      R1,R4,#+17
    223          
    224            i = start;  
   \   00000030   0xE000             B.N      ??u8g_font_GetSize_1
    225            for(;;)
    226            {
    227              if ( u8g_pgm_read((u8g_pgm_uint8_t *)(p)) == 255 )
    228              {
    229                p += 1;
    230              }
    231              else
    232              {
    233                p += u8g_pgm_read( ((u8g_pgm_uint8_t *)(p)) + 2 ) & mask;
    234                p += data_structure_size;
    235              }
    236              if ( i == end )
    237                break;
    238              i++;
   \                     ??u8g_font_GetSize_2: (+1)
   \   00000032   0x1C7F             ADDS     R7,R7,#+1
   \                     ??u8g_font_GetSize_1: (+1)
   \   00000034   0x780A             LDRB     R2,[R1, #+0]
   \   00000036   0x2AFF             CMP      R2,#+255
   \   00000038   0xD101             BNE.N    ??u8g_font_GetSize_3
   \   0000003A   0x1C49             ADDS     R1,R1,#+1
   \   0000003C   0xE003             B.N      ??u8g_font_GetSize_4
   \                     ??u8g_font_GetSize_3: (+1)
   \   0000003E   0x788A             LDRB     R2,[R1, #+2]
   \   00000040   0x4032             ANDS     R2,R6,R2
   \   00000042   0x4411             ADD      R1,R1,R2
   \   00000044   0x4429             ADD      R1,R1,R5
   \                     ??u8g_font_GetSize_4: (+1)
   \   00000046   0x463A             MOV      R2,R7
   \   00000048   0xB2D2             UXTB     R2,R2
   \   0000004A   0x4282             CMP      R2,R0
   \   0000004C   0xD1F1             BNE.N    ??u8g_font_GetSize_2
    239            }
    240              
    241            return p - (uint8_t *)font;
   \   0000004E   0x1B0C             SUBS     R4,R1,R4
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    242          }
    243          
    244          /*========================================================================*/
    245          /* u8g interface, font access */
    246          

   \                                 In section .text, align 2, keep-with-next
    247          uint8_t u8g_GetFontBBXWidth(u8g_t *u8g)
    248          {
    249            return u8g_font_GetBBXWidth(u8g->font);
   \                     u8g_GetFontBBXWidth: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0x....             B.N      u8g_font_GetBBXWidth
    250          }
    251          

   \                                 In section .text, align 2, keep-with-next
    252          uint8_t u8g_GetFontBBXHeight(u8g_t *u8g)
    253          {
    254            return u8g_font_GetBBXHeight(u8g->font);
   \                     u8g_GetFontBBXHeight: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0x....             B.N      u8g_font_GetBBXHeight
    255          }
    256          
    257          int8_t u8g_GetFontBBXOffX(u8g_t *u8g) U8G_NOINLINE;

   \                                 In section .text, align 2, keep-with-next
    258          int8_t u8g_GetFontBBXOffX(u8g_t *u8g)
    259          {
    260            return u8g_font_GetBBXOffX(u8g->font);
   \                     u8g_GetFontBBXOffX: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0x....             B.N      u8g_font_GetBBXOffX
    261          }
    262          
    263          int8_t u8g_GetFontBBXOffY(u8g_t *u8g) U8G_NOINLINE;

   \                                 In section .text, align 2, keep-with-next
    264          int8_t u8g_GetFontBBXOffY(u8g_t *u8g)
    265          {
    266            return u8g_font_GetBBXOffY(u8g->font);
   \                     u8g_GetFontBBXOffY: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0x....             B.N      u8g_font_GetBBXOffY
    267          }
    268          
    269          uint8_t u8g_GetFontCapitalAHeight(u8g_t *u8g) U8G_NOINLINE; 

   \                                 In section .text, align 2, keep-with-next
    270          uint8_t u8g_GetFontCapitalAHeight(u8g_t *u8g)
    271          {
    272            return u8g_font_GetCapitalAHeight(u8g->font);
   \                     u8g_GetFontCapitalAHeight: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0x....             B.N      u8g_font_GetCapitalAHeight
    273          }
    274          
    275          /*========================================================================*/
    276          /* glyph handling */
    277          

   \                                 In section .text, align 2, keep-with-next
    278          static void u8g_CopyGlyphDataToCache(u8g_t *u8g, u8g_glyph_t g)
    279          {
   \                     u8g_CopyGlyphDataToCache: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    280            uint8_t tmp;
    281            switch( u8g_font_GetFormat(u8g->font) )
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x.... 0x....      BL       u8g_font_GetFormat
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??u8g_CopyGlyphDataToCache_0
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD10E             BNE.N    ??u8g_CopyGlyphDataToCache_1
    282            {
    283              case 0:
    284              case 2:
    285            /*
    286              format 0
    287              glyph information 
    288              offset
    289              0             BBX width                                       unsigned
    290              1             BBX height                                      unsigned
    291              2             data size                                          unsigned    (BBX width + 7)/8 * BBX height
    292              3             DWIDTH                                          signed
    293              4             BBX xoffset                                    signed
    294              5             BBX yoffset                                    signed
    295            byte 0 == 255 indicates empty glyph
    296            */
    297                u8g->glyph_width =  u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 0 );
   \                     ??u8g_CopyGlyphDataToCache_0: (+1)
   \   00000014   0x7828             LDRB     R0,[R5, #+0]
   \   00000016   0x77E0             STRB     R0,[R4, #+31]
    298                u8g->glyph_height =  u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 1 );
   \   00000018   0x7868             LDRB     R0,[R5, #+1]
   \   0000001A   0xF884 0x0020      STRB     R0,[R4, #+32]
    299                u8g->glyph_dx =  u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 3 );
   \   0000001E   0xF995 0x0003      LDRSB    R0,[R5, #+3]
   \   00000022   0x7720             STRB     R0,[R4, #+28]
    300                u8g->glyph_x =  u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 4 );
   \   00000024   0xF995 0x0004      LDRSB    R0,[R5, #+4]
   \   00000028   0x7760             STRB     R0,[R4, #+29]
    301                u8g->glyph_y =  u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 5 );
   \   0000002A   0xF995 0x0005      LDRSB    R0,[R5, #+5]
   \   0000002E   0x77A0             STRB     R0,[R4, #+30]
    302                break;
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}
    303              case 1:
    304              default:
    305                /*
    306          format 1
    307            0             BBX xoffset                                    signed   --> upper 4 Bit
    308            0             BBX yoffset                                    signed --> lower 4 Bit
    309            1             BBX width                                       unsigned --> upper 4 Bit
    310            1             BBX height                                      unsigned --> lower 4 Bit
    311            2             data size                                           unsigned -(BBX width + 7)/8 * BBX height  --> lower 4 Bit
    312            2             DWIDTH                                          signed --> upper  4 Bit
    313            byte 0 == 255 indicates empty glyph
    314                */
    315              
    316                tmp = u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 0 );
   \                     ??u8g_CopyGlyphDataToCache_1: (+1)
   \   00000032   0x7828             LDRB     R0,[R5, #+0]
    317                u8g->glyph_y =  tmp & 15;
   \   00000034   0xF000 0x010F      AND      R1,R0,#0xF
   \   00000038   0x77A1             STRB     R1,[R4, #+30]
    318                u8g->glyph_y-=2;
   \   0000003A   0x1E89             SUBS     R1,R1,#+2
   \   0000003C   0x77A1             STRB     R1,[R4, #+30]
    319                tmp >>= 4;
    320                u8g->glyph_x =  tmp;
   \   0000003E   0x0900             LSRS     R0,R0,#+4
   \   00000040   0x7760             STRB     R0,[R4, #+29]
    321              
    322                tmp = u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 1 );
   \   00000042   0x7868             LDRB     R0,[R5, #+1]
    323                u8g->glyph_height =  tmp & 15;
   \   00000044   0xF000 0x010F      AND      R1,R0,#0xF
   \   00000048   0xF884 0x1020      STRB     R1,[R4, #+32]
    324                tmp >>= 4;
    325                u8g->glyph_width =  tmp;
   \   0000004C   0x0900             LSRS     R0,R0,#+4
   \   0000004E   0x77E0             STRB     R0,[R4, #+31]
    326                
    327                tmp = u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 2 );
    328                tmp >>= 4;
    329                u8g->glyph_dx = tmp;
   \   00000050   0x78A8             LDRB     R0,[R5, #+2]
   \   00000052   0x0900             LSRS     R0,R0,#+4
   \   00000054   0x7720             STRB     R0,[R4, #+28]
    330              
    331                
    332                break;
    333            }
    334          }
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    335          
    336          //void u8g_FillEmptyGlyphCache(u8g_t *u8g) U8G_NOINLINE;

   \                                 In section .text, align 2, keep-with-next
    337          static void u8g_FillEmptyGlyphCache(u8g_t *u8g)
    338          {
    339            u8g->glyph_dx = 0;
   \                     u8g_FillEmptyGlyphCache: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7701             STRB     R1,[R0, #+28]
    340            u8g->glyph_width = 0;
   \   00000004   0x77C1             STRB     R1,[R0, #+31]
    341            u8g->glyph_height = 0;
   \   00000006   0xF880 0x1020      STRB     R1,[R0, #+32]
    342            u8g->glyph_x = 0;
   \   0000000A   0x7741             STRB     R1,[R0, #+29]
    343            u8g->glyph_y = 0;
   \   0000000C   0x7781             STRB     R1,[R0, #+30]
    344          }
   \   0000000E   0x4770             BX       LR               ;; return
    345          
    346          /*
    347            Find (with some speed optimization) and return a pointer to the glyph data structure
    348            Also uncompress (format 1) and copy the content of the data structure to the u8g structure
    349          */

   \                                 In section .text, align 2, keep-with-next
    350          u8g_glyph_t u8g_GetGlyph(u8g_t *u8g, uint8_t requested_encoding)
    351          {
   \                     u8g_GetGlyph: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460C             MOV      R4,R1
    352            uint8_t *p = (uint8_t *)(u8g->font);
   \   00000008   0x68B0             LDR      R0,[R6, #+8]
   \   0000000A   0x4683             MOV      R11,R0
    353            uint8_t font_format = u8g_font_GetFormat(u8g->font);
   \   0000000C   0x.... 0x....      BL       u8g_font_GetFormat
   \   00000010   0x4680             MOV      R8,R0
    354            uint8_t data_structure_size = u8g_font_GetFontGlyphStructureSize(u8g->font);
   \   00000012   0x68B0             LDR      R0,[R6, #+8]
   \   00000014   0x.... 0x....      BL       u8g_font_GetFontGlyphStructureSize
   \   00000018   0x4605             MOV      R5,R0
    355            uint8_t start, end;
    356            uint16_t pos;
    357            uint8_t i;
    358            uint8_t mask = 255;
   \   0000001A   0x27FF             MOVS     R7,#+255
    359          
    360            if ( font_format == 1 )
   \   0000001C   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000020   0xD100             BNE.N    ??u8g_GetGlyph_0
    361              mask = 15;
   \   00000022   0x270F             MOVS     R7,#+15
    362            
    363            start = u8g_font_GetFontStartEncoding(u8g->font);
   \                     ??u8g_GetGlyph_0: (+1)
   \   00000024   0x68B0             LDR      R0,[R6, #+8]
   \   00000026   0x.... 0x....      BL       u8g_font_GetFontStartEncoding
   \   0000002A   0x4682             MOV      R10,R0
    364            end = u8g_font_GetFontEndEncoding(u8g->font);
   \   0000002C   0x68B0             LDR      R0,[R6, #+8]
   \   0000002E   0x.... 0x....      BL       u8g_font_GetFontEndEncoding
   \   00000032   0x4680             MOV      R8,R0
    365          
    366            pos = u8g_font_GetEncoding97Pos(u8g->font);
   \   00000034   0x68B0             LDR      R0,[R6, #+8]
   \   00000036   0x.... 0x....      BL       u8g_font_GetEncoding97Pos
    367            if ( requested_encoding >= 97 && pos > 0 )
   \   0000003A   0x46A1             MOV      R9,R4
   \   0000003C   0xF1B9 0x0F61      CMP      R9,#+97
   \   00000040   0xDB05             BLT.N    ??u8g_GetGlyph_1
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD003             BEQ.N    ??u8g_GetGlyph_1
    368            {
    369              p+= pos;
   \   00000046   0x4458             ADD      R0,R11,R0
    370              start = 97;
   \   00000048   0xF04F 0x0A61      MOV      R10,#+97
   \   0000004C   0xE00D             B.N      ??u8g_GetGlyph_2
    371            }
    372            else 
    373            {
    374              pos = u8g_font_GetEncoding65Pos(u8g->font);
   \                     ??u8g_GetGlyph_1: (+1)
   \   0000004E   0x68B0             LDR      R0,[R6, #+8]
   \   00000050   0x.... 0x....      BL       u8g_font_GetEncoding65Pos
    375              if ( requested_encoding >= 65 && pos > 0 )
   \   00000054   0xF1B9 0x0F41      CMP      R9,#+65
   \   00000058   0xDB05             BLT.N    ??u8g_GetGlyph_3
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD003             BEQ.N    ??u8g_GetGlyph_3
    376              {
    377                p+= pos;
   \   0000005E   0x4458             ADD      R0,R11,R0
    378                start = 65;
   \   00000060   0xF04F 0x0A41      MOV      R10,#+65
   \   00000064   0xE001             B.N      ??u8g_GetGlyph_2
    379              }
    380              else
    381                p += U8G_FONT_DATA_STRUCT_SIZE;       /* skip font general information */  
   \                     ??u8g_GetGlyph_3: (+1)
   \   00000066   0xF10B 0x0011      ADD      R0,R11,#+17
    382            }
    383            
    384            if ( requested_encoding > end )
   \                     ??u8g_GetGlyph_2: (+1)
   \   0000006A   0x45C8             CMP      R8,R9
   \   0000006C   0xDB22             BLT.N    ??u8g_GetGlyph_4
    385            {
    386              u8g_FillEmptyGlyphCache(u8g);
    387              return NULL;                      /* not found */
    388            }
    389            
    390            i = start;
    391            if ( i <= end )
   \   0000006E   0x4651             MOV      R1,R10
   \   00000070   0x4588             CMP      R8,R1
   \   00000072   0xDB1F             BLT.N    ??u8g_GetGlyph_4
   \   00000074   0x4681             MOV      R9,R0
   \   00000076   0x4621             MOV      R1,R4
   \   00000078   0xE00B             B.N      ??u8g_GetGlyph_5
    392            {
    393              for(;;)
    394              {
    395                if ( u8g_pgm_read((u8g_pgm_uint8_t *)(p)) == 255 )
    396                {
    397                  p += 1;
    398                }
    399                else
    400                {
    401                  if ( i == requested_encoding )
    402                  {
    403                    u8g_CopyGlyphDataToCache(u8g, p);
    404                    return p;
    405                  }
    406                  p += u8g_pgm_read( ((u8g_pgm_uint8_t *)(p)) + 2 ) & mask;
    407                  p += data_structure_size;
   \                     ??u8g_GetGlyph_6: (+1)
   \   0000007A   0xF899 0x0002      LDRB     R0,[R9, #+2]
   \   0000007E   0x4038             ANDS     R0,R7,R0
   \   00000080   0x4448             ADD      R0,R9,R0
   \   00000082   0xEB00 0x0905      ADD      R9,R0,R5
    408                }
    409                if ( i == end )
   \                     ??u8g_GetGlyph_7: (+1)
   \   00000086   0x4650             MOV      R0,R10
   \   00000088   0xB2C0             UXTB     R0,R0
   \   0000008A   0x4540             CMP      R0,R8
   \   0000008C   0xD012             BEQ.N    ??u8g_GetGlyph_4
    410                  break;
    411                i++;
   \   0000008E   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??u8g_GetGlyph_5: (+1)
   \   00000092   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000096   0x28FF             CMP      R0,#+255
   \   00000098   0xD102             BNE.N    ??u8g_GetGlyph_8
   \   0000009A   0xF109 0x0901      ADD      R9,R9,#+1
   \   0000009E   0xE7F2             B.N      ??u8g_GetGlyph_7
   \                     ??u8g_GetGlyph_8: (+1)
   \   000000A0   0x4650             MOV      R0,R10
   \   000000A2   0xB2C0             UXTB     R0,R0
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xD1E8             BNE.N    ??u8g_GetGlyph_6
   \   000000A8   0x4649             MOV      R1,R9
   \   000000AA   0x4630             MOV      R0,R6
   \   000000AC   0x.... 0x....      BL       u8g_CopyGlyphDataToCache
   \   000000B0   0x4648             MOV      R0,R9
   \   000000B2   0xE003             B.N      ??u8g_GetGlyph_9
    412              }
    413            }
    414            
    415            u8g_FillEmptyGlyphCache(u8g);
   \                     ??u8g_GetGlyph_4: (+1)
   \   000000B4   0x4630             MOV      R0,R6
   \   000000B6   0x.... 0x....      BL       u8g_FillEmptyGlyphCache
    416              
    417            return NULL;
   \   000000BA   0x2000             MOVS     R0,#+0
   \                     ??u8g_GetGlyph_9: (+1)
   \   000000BC   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    418          }
    419          

   \                                 In section .text, align 2, keep-with-next
    420          uint8_t u8g_IsGlyph(u8g_t *u8g, uint8_t requested_encoding)
    421          {
   \                     u8g_IsGlyph: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    422            if ( u8g_GetGlyph(u8g, requested_encoding) != NULL )
   \   00000002   0x.... 0x....      BL       u8g_GetGlyph
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ.N    ??u8g_IsGlyph_0
    423              return 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD02             POP      {R1,PC}
    424            return 0;
   \                     ??u8g_IsGlyph_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    425          }
    426          

   \                                 In section .text, align 2, keep-with-next
    427          int8_t u8g_GetGlyphDeltaX(u8g_t *u8g, uint8_t requested_encoding)
    428          {
   \                     u8g_GetGlyphDeltaX: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    429            if ( u8g_GetGlyph(u8g, requested_encoding) == NULL )
   \   00000004   0x.... 0x....      BL       u8g_GetGlyph
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??u8g_GetGlyphDeltaX_0
    430              return 0;  /* should never happen, so return something */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}
    431            return u8g->glyph_dx;
   \                     ??u8g_GetGlyphDeltaX_0: (+1)
   \   00000010   0xF994 0x001C      LDRSB    R0,[R4, #+28]
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    432          }
    433          
    434          
    435          /*========================================================================*/
    436          /* glyph drawing procedures */
    437          
    438          #ifdef OBSOLETE
    439          /*
    440            Draw a glyph
    441            x,y: left baseline position of the glyph
    442          */
    443          int8_t u8g_DrawGlyphDir(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t dir, uint8_t encoding)
    444          {
    445            u8g_glyph_t g;
    446            uint8_t w, h, i, j;
    447            const u8g_pgm_uint8_t *data;
    448            uint8_t bytes_per_line;
    449            u8g_uint_t ix, iy;
    450          
    451            g = u8g_GetGlyph(u8g, encoding);
    452            if ( g == NULL  )
    453              return 0;
    454            w = u8g->glyph_width;
    455            h = u8g->glyph_height;
    456          
    457            bytes_per_line = w;
    458            bytes_per_line += 7;
    459            bytes_per_line /= 8;
    460            
    461            data = u8g_font_GetGlyphDataStart(u8g->font, g);
    462          
    463            switch(dir)
    464            {
    465              case 0:
    466                x += u8g->glyph_x;
    467                y -= u8g->glyph_y;
    468                y--;
    469                //u8g_DrawFrame(u8g, x, y-h+1, w, h);
    470                if ( u8g_IsBBXIntersection(u8g, x, y-h+1, w, h) == 0 )
    471                  return u8g->glyph_dx;
    472                
    473                iy = y;
    474                iy -= h;
    475                iy++;
    476                
    477                for( j = 0; j < h; j++ )
    478                {
    479                  ix = x;
    480                  for( i = 0; i < bytes_per_line; i++ )
    481                  {
    482                    u8g_Draw8Pixel(u8g, ix, iy, dir, u8g_pgm_read(data));
    483                    data++;
    484                    ix+=8;
    485                  }
    486                  iy++;
    487                }
    488                break;
    489              case 1:
    490                x += u8g->glyph_y;
    491                x++;
    492                y += u8g->glyph_x;
    493                //printf("enc %d, dir %d, x %d, y %d, w %d, h %d\n", encoding, dir, x, y, w, h);
    494                //u8g_DrawFrame(u8g, x, y, h, w);
    495                if ( u8g_IsBBXIntersection(u8g, x, y, h, w) == 0 )
    496                  return u8g->glyph_dx;
    497                
    498                ix = x;
    499                ix += h;
    500                ix--;
    501                for( j = 0; j < h; j++ )
    502                {
    503                  iy = y;
    504                  for( i = 0; i < bytes_per_line; i++ )
    505                  {
    506                    u8g_Draw8Pixel(u8g, ix, iy, dir, u8g_pgm_read(data));
    507                    data++;
    508                    iy+=8;
    509                  }
    510                  ix--;
    511                }
    512                break;
    513              case 2:
    514                x -= u8g->glyph_x;
    515                y += u8g->glyph_y;
    516                y++;
    517                if ( u8g_IsBBXIntersection(u8g, x-w-1, y, w, h) == 0 )
    518                  return u8g->glyph_dx;
    519                
    520                iy = y;
    521                iy += h;
    522                iy--;
    523                for( j = 0; j < h; j++ )
    524                {
    525                  ix = x;
    526                  for( i = 0; i < bytes_per_line; i++ )
    527                  {
    528                    u8g_Draw8Pixel(u8g, ix, iy, dir, u8g_pgm_read(data));
    529                    data++;
    530                    ix-=8;
    531                  }
    532                  iy--;
    533                }
    534                break;
    535              case 3:
    536                x -= u8g->glyph_y;
    537                x--;
    538                y -= u8g->glyph_x;
    539                
    540                if ( u8g_IsBBXIntersection(u8g, x-h-1, y-w-1, h, w) == 0 )
    541                  return u8g->glyph_dx;
    542                
    543                ix = x;
    544                ix -= h;
    545                ix++;
    546                
    547                for( j = 0; j < h; j++ )
    548                {
    549                  iy = y;
    550                  for( i = 0; i < bytes_per_line; i++ )
    551                  {
    552                    u8g_Draw8Pixel(u8g, ix, iy, dir, u8g_pgm_read(data));
    553                    data++;
    554                    iy-=8;
    555                  }
    556                  ix++;
    557                }
    558                break;    
    559            }
    560            return u8g->glyph_dx;
    561          }
    562          #endif
    563          

   \                                 In section .text, align 2, keep-with-next
    564          int8_t u8g_draw_glyph(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t encoding)
    565          {
   \                     u8g_draw_glyph: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4691             MOV      R9,R2
    566            const u8g_pgm_uint8_t *data;
    567            uint8_t w, h;
    568            uint8_t i, j;
    569            u8g_uint_t ix, iy;
    570          
    571            {
    572              u8g_glyph_t g = u8g_GetGlyph(u8g, encoding);
   \   0000000A   0x4619             MOV      R1,R3
   \   0000000C   0x.... 0x....      BL       u8g_GetGlyph
    573              if ( g == NULL  )
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??u8g_draw_glyph_0
    574                return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE048             B.N      ??u8g_draw_glyph_1
    575              data = u8g_font_GetGlyphDataStart(u8g->font, g);
   \                     ??u8g_draw_glyph_0: (+1)
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x68B0             LDR      R0,[R6, #+8]
   \   0000001C   0x.... 0x....      BL       u8g_font_GetGlyphDataStart
   \   00000020   0x4607             MOV      R7,R0
    576            }
    577            
    578            w = u8g->glyph_width;
   \   00000022   0x7FF4             LDRB     R4,[R6, #+31]
    579            h = u8g->glyph_height;
   \   00000024   0xF896 0x8020      LDRB     R8,[R6, #+32]
    580            
    581            x += u8g->glyph_x;
   \   00000028   0xF996 0x001D      LDRSB    R0,[R6, #+29]
   \   0000002C   0x1945             ADDS     R5,R0,R5
   \   0000002E   0xF88D 0x5004      STRB     R5,[SP, #+4]
    582            y -= u8g->glyph_y;
    583            y--;
   \   00000032   0xF996 0x001E      LDRSB    R0,[R6, #+30]
   \   00000036   0xEBA9 0x0900      SUB      R9,R9,R0
   \   0000003A   0xF1A9 0x0501      SUB      R5,R9,#+1
    584            
    585            if ( u8g_IsBBXIntersection(u8g, x, y-h+1, w, h) == 0 )
   \   0000003E   0xEBA5 0x0508      SUB      R5,R5,R8
   \   00000042   0x1C6D             ADDS     R5,R5,#+1
   \   00000044   0x4640             MOV      R0,R8
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0x4623             MOV      R3,R4
   \   0000004A   0x462A             MOV      R2,R5
   \   0000004C   0xB2D2             UXTB     R2,R2
   \   0000004E   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0x.... 0x....      BL       u8g_IsBBXIntersection
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD024             BEQ.N    ??u8g_draw_glyph_2
    586              return u8g->glyph_dx;
    587          
    588            /* now, w is reused as bytes per line */
    589            w += 7;
    590            w /= 8;
   \   0000005C   0x1DE4             ADDS     R4,R4,#+7
   \   0000005E   0xB2E4             UXTB     R4,R4
    591            
    592            iy = y;
    593            iy -= h;
    594            iy++;
    595          
    596            for( j = 0; j < h; j++ )
   \   00000060   0xF04F 0x0900      MOV      R9,#+0
   \   00000064   0xE016             B.N      ??u8g_draw_glyph_3
    597            {
    598              ix = x;
    599              for( i = 0; i < w; i++ )
    600              {
    601                u8g_Draw8Pixel(u8g, ix, iy, 0, u8g_pgm_read(data));
   \                     ??u8g_draw_glyph_4: (+1)
   \   00000066   0xF817 0x0B01      LDRB     R0,[R7], #+1
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x2300             MOVS     R3,#+0
   \   0000006E   0x462A             MOV      R2,R5
   \   00000070   0xB2D2             UXTB     R2,R2
   \   00000072   0x4651             MOV      R1,R10
   \   00000074   0xB2C9             UXTB     R1,R1
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       u8g_Draw8Pixel
    602                data++;
    603                ix+=8;
   \   0000007C   0xF10A 0x0A08      ADD      R10,R10,#+8
    604              }
   \   00000080   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??u8g_draw_glyph_5: (+1)
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0xB2C0             UXTB     R0,R0
   \   00000088   0xEBB0 0x0FD4      CMP      R0,R4, LSR #+3
   \   0000008C   0xDBEB             BLT.N    ??u8g_draw_glyph_4
    605              iy++;
   \   0000008E   0x1C6D             ADDS     R5,R5,#+1
   \   00000090   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??u8g_draw_glyph_3: (+1)
   \   00000094   0x4648             MOV      R0,R9
   \   00000096   0xB2C0             UXTB     R0,R0
   \   00000098   0x4540             CMP      R0,R8
   \   0000009A   0xDA04             BGE.N    ??u8g_draw_glyph_2
   \   0000009C   0xF89D 0xA004      LDRB     R10,[SP, #+4]
   \   000000A0   0xF04F 0x0B00      MOV      R11,#+0
   \   000000A4   0xE7EE             B.N      ??u8g_draw_glyph_5
    606            }
    607            return u8g->glyph_dx;
   \                     ??u8g_draw_glyph_2: (+1)
   \   000000A6   0xF996 0x001C      LDRSB    R0,[R6, #+28]
   \                     ??u8g_draw_glyph_1: (+1)
   \   000000AA   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    608          }
    609          

   \                                 In section .text, align 2, keep-with-next
    610          int8_t u8g_DrawGlyph(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t encoding)
    611          {
   \                     u8g_DrawGlyph: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    612            y += u8g->font_calc_vref(u8g);
   \   0000000A   0x6A61             LDR      R1,[R4, #+36]
   \   0000000C   0x4788             BLX      R1
   \   0000000E   0x1986             ADDS     R6,R0,R6
    613            return u8g_draw_glyph(u8g, x, y, encoding);
   \   00000010   0x463B             MOV      R3,R7
   \   00000012   0x4632             MOV      R2,R6
   \   00000014   0xB2D2             UXTB     R2,R2
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000020   0x....             B.N      u8g_draw_glyph
    614          }
    615          

   \                                 In section .text, align 2, keep-with-next
    616          int8_t u8g_draw_glyph90(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t encoding)
    617          {
   \                     u8g_draw_glyph90: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4690             MOV      R8,R2
    618            const u8g_pgm_uint8_t *data;
    619            uint8_t w, h;
    620            uint8_t i, j;
    621            u8g_uint_t ix, iy;
    622          
    623            {
    624              u8g_glyph_t g = u8g_GetGlyph(u8g, encoding);
   \   0000000A   0x4619             MOV      R1,R3
   \   0000000C   0x.... 0x....      BL       u8g_GetGlyph
    625              if ( g == NULL  )
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??u8g_draw_glyph90_0
    626                return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE048             B.N      ??u8g_draw_glyph90_1
    627              data = u8g_font_GetGlyphDataStart(u8g->font, g);
   \                     ??u8g_draw_glyph90_0: (+1)
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x68A0             LDR      R0,[R4, #+8]
   \   0000001C   0x.... 0x....      BL       u8g_font_GetGlyphDataStart
   \   00000020   0x4605             MOV      R5,R0
    628            }
    629            
    630            w = u8g->glyph_width;
   \   00000022   0xF894 0x901F      LDRB     R9,[R4, #+31]
    631            h = u8g->glyph_height;
   \   00000026   0xF894 0x7020      LDRB     R7,[R4, #+32]
    632            
    633            x += u8g->glyph_y;
    634            x++;
   \   0000002A   0xF994 0x001E      LDRSB    R0,[R4, #+30]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0x1986             ADDS     R6,R0,R6
    635            y += u8g->glyph_x;
   \   00000032   0xF994 0x001D      LDRSB    R0,[R4, #+29]
   \   00000036   0x4480             ADD      R8,R0,R8
   \   00000038   0xF88D 0x8004      STRB     R8,[SP, #+4]
    636            
    637            if ( u8g_IsBBXIntersection(u8g, x, y, h, w) == 0 )
   \   0000003C   0x4648             MOV      R0,R9
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x463B             MOV      R3,R7
   \   00000042   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \   00000046   0x4631             MOV      R1,R6
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       u8g_IsBBXIntersection
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD028             BEQ.N    ??u8g_draw_glyph90_2
    638              return u8g->glyph_dx;
    639          
    640            /* now, w is reused as bytes per line */
    641            w += 7;
    642            w /= 8;
   \   00000054   0xF109 0x0907      ADD      R9,R9,#+7
   \   00000058   0xFA5F 0xF989      UXTB     R9,R9
    643            
    644            ix = x;
    645            ix += h;
    646            ix--;
   \   0000005C   0x19BE             ADDS     R6,R7,R6
   \   0000005E   0x1E76             SUBS     R6,R6,#+1
    647            for( j = 0; j < h; j++ )
   \   00000060   0xF04F 0x0800      MOV      R8,#+0
   \   00000064   0xE016             B.N      ??u8g_draw_glyph90_3
    648            {
    649              iy = y;
    650              for( i = 0; i < w; i++ )
    651              {
    652                u8g_Draw8Pixel(u8g, ix, iy, 1, u8g_pgm_read(data));
   \                     ??u8g_draw_glyph90_4: (+1)
   \   00000066   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x2301             MOVS     R3,#+1
   \   0000006E   0x4652             MOV      R2,R10
   \   00000070   0xB2D2             UXTB     R2,R2
   \   00000072   0x4631             MOV      R1,R6
   \   00000074   0xB2C9             UXTB     R1,R1
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       u8g_Draw8Pixel
    653                data++;
    654                iy+=8;
   \   0000007C   0xF10A 0x0A08      ADD      R10,R10,#+8
    655              }
   \   00000080   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??u8g_draw_glyph90_5: (+1)
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0xB2C0             UXTB     R0,R0
   \   00000088   0xEBB0 0x0FD9      CMP      R0,R9, LSR #+3
   \   0000008C   0xDBEB             BLT.N    ??u8g_draw_glyph90_4
    656              ix--;
   \   0000008E   0x1E76             SUBS     R6,R6,#+1
   \   00000090   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??u8g_draw_glyph90_3: (+1)
   \   00000094   0x4640             MOV      R0,R8
   \   00000096   0xB2C0             UXTB     R0,R0
   \   00000098   0x42B8             CMP      R0,R7
   \   0000009A   0xDA04             BGE.N    ??u8g_draw_glyph90_2
   \   0000009C   0xF89D 0xA004      LDRB     R10,[SP, #+4]
   \   000000A0   0xF04F 0x0B00      MOV      R11,#+0
   \   000000A4   0xE7EE             B.N      ??u8g_draw_glyph90_5
    657            }
    658            return u8g->glyph_dx;
   \                     ??u8g_draw_glyph90_2: (+1)
   \   000000A6   0xF994 0x001C      LDRSB    R0,[R4, #+28]
   \                     ??u8g_draw_glyph90_1: (+1)
   \   000000AA   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    659          }
    660          

   \                                 In section .text, align 2, keep-with-next
    661          int8_t u8g_DrawGlyph90(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t encoding)
    662          {
   \                     u8g_DrawGlyph90: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    663            x -= u8g->font_calc_vref(u8g);
   \   0000000A   0x6A61             LDR      R1,[R4, #+36]
   \   0000000C   0x4788             BLX      R1
   \   0000000E   0x1A2D             SUBS     R5,R5,R0
    664            return u8g_draw_glyph90(u8g, x, y, encoding);
   \   00000010   0x463B             MOV      R3,R7
   \   00000012   0x4632             MOV      R2,R6
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0xB2C9             UXTB     R1,R1
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000020   0x....             B.N      u8g_draw_glyph90
    665          }
    666          
    667          

   \                                 In section .text, align 2, keep-with-next
    668          int8_t u8g_draw_glyph180(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t encoding)
    669          {
   \                     u8g_draw_glyph180: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4616             MOV      R6,R2
    670            const u8g_pgm_uint8_t *data;
    671            uint8_t w, h;
    672            uint8_t i, j;
    673            u8g_uint_t ix, iy;
    674          
    675            {
    676              u8g_glyph_t g = u8g_GetGlyph(u8g, encoding);
   \   0000000A   0x4619             MOV      R1,R3
   \   0000000C   0x.... 0x....      BL       u8g_GetGlyph
    677              if ( g == NULL  )
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??u8g_draw_glyph180_0
    678                return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE04D             B.N      ??u8g_draw_glyph180_1
    679              data = u8g_font_GetGlyphDataStart(u8g->font, g);
   \                     ??u8g_draw_glyph180_0: (+1)
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x68A0             LDR      R0,[R4, #+8]
   \   0000001C   0x.... 0x....      BL       u8g_font_GetGlyphDataStart
   \   00000020   0x4605             MOV      R5,R0
    680            }
    681            
    682            w = u8g->glyph_width;
   \   00000022   0xF894 0x901F      LDRB     R9,[R4, #+31]
    683            h = u8g->glyph_height;
   \   00000026   0xF894 0x7020      LDRB     R7,[R4, #+32]
    684            
    685            x -= u8g->glyph_x;
   \   0000002A   0xF994 0x001D      LDRSB    R0,[R4, #+29]
   \   0000002E   0xEBA8 0x0800      SUB      R8,R8,R0
   \   00000032   0xF88D 0x8004      STRB     R8,[SP, #+4]
    686            y += u8g->glyph_y;
    687            y++;
   \   00000036   0xF994 0x001E      LDRSB    R0,[R4, #+30]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x1986             ADDS     R6,R0,R6
    688            
    689            if ( u8g_IsBBXIntersection(u8g, x-(w-1), y, w, h) == 0 )
   \   0000003E   0x4638             MOV      R0,R7
   \   00000040   0x9000             STR      R0,[SP, #+0]
   \   00000042   0x464B             MOV      R3,R9
   \   00000044   0x4632             MOV      R2,R6
   \   00000046   0xB2D2             UXTB     R2,R2
   \   00000048   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000004C   0xEBA1 0x0109      SUB      R1,R1,R9
   \   00000050   0x1C49             ADDS     R1,R1,#+1
   \   00000052   0xB2C9             UXTB     R1,R1
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       u8g_IsBBXIntersection
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD028             BEQ.N    ??u8g_draw_glyph180_2
    690              return u8g->glyph_dx;
    691          
    692            /* now, w is reused as bytes per line */
    693            w += 7;
    694            w /= 8;
   \   0000005E   0xF109 0x0907      ADD      R9,R9,#+7
   \   00000062   0xFA5F 0xF989      UXTB     R9,R9
    695            
    696            iy = y;
    697            iy += h;
    698            iy--;
   \   00000066   0x19BE             ADDS     R6,R7,R6
   \   00000068   0x1E76             SUBS     R6,R6,#+1
    699            for( j = 0; j < h; j++ )
   \   0000006A   0xF04F 0x0800      MOV      R8,#+0
   \   0000006E   0xE016             B.N      ??u8g_draw_glyph180_3
    700            {
    701              ix = x;
    702              for( i = 0; i < w; i++ )
    703              {
    704                u8g_Draw8Pixel(u8g, ix, iy, 2, u8g_pgm_read(data));
   \                     ??u8g_draw_glyph180_4: (+1)
   \   00000070   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0x2302             MOVS     R3,#+2
   \   00000078   0x4632             MOV      R2,R6
   \   0000007A   0xB2D2             UXTB     R2,R2
   \   0000007C   0x4651             MOV      R1,R10
   \   0000007E   0xB2C9             UXTB     R1,R1
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       u8g_Draw8Pixel
    705                data++;
    706                ix-=8;
   \   00000086   0xF1AA 0x0A08      SUB      R10,R10,#+8
    707              }
   \   0000008A   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??u8g_draw_glyph180_5: (+1)
   \   0000008E   0x4658             MOV      R0,R11
   \   00000090   0xB2C0             UXTB     R0,R0
   \   00000092   0xEBB0 0x0FD9      CMP      R0,R9, LSR #+3
   \   00000096   0xDBEB             BLT.N    ??u8g_draw_glyph180_4
    708              iy--;
   \   00000098   0x1E76             SUBS     R6,R6,#+1
   \   0000009A   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??u8g_draw_glyph180_3: (+1)
   \   0000009E   0x4640             MOV      R0,R8
   \   000000A0   0xB2C0             UXTB     R0,R0
   \   000000A2   0x42B8             CMP      R0,R7
   \   000000A4   0xDA04             BGE.N    ??u8g_draw_glyph180_2
   \   000000A6   0xF89D 0xA004      LDRB     R10,[SP, #+4]
   \   000000AA   0xF04F 0x0B00      MOV      R11,#+0
   \   000000AE   0xE7EE             B.N      ??u8g_draw_glyph180_5
    709            }
    710            return u8g->glyph_dx;
   \                     ??u8g_draw_glyph180_2: (+1)
   \   000000B0   0xF994 0x001C      LDRSB    R0,[R4, #+28]
   \                     ??u8g_draw_glyph180_1: (+1)
   \   000000B4   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    711          }
    712          

   \                                 In section .text, align 2, keep-with-next
    713          int8_t u8g_DrawGlyph180(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t encoding)
    714          {
   \                     u8g_DrawGlyph180: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    715            y -= u8g->font_calc_vref(u8g);
   \   0000000A   0x6A61             LDR      R1,[R4, #+36]
   \   0000000C   0x4788             BLX      R1
   \   0000000E   0x1A36             SUBS     R6,R6,R0
    716            return u8g_draw_glyph180(u8g, x, y, encoding);
   \   00000010   0x463B             MOV      R3,R7
   \   00000012   0x4632             MOV      R2,R6
   \   00000014   0xB2D2             UXTB     R2,R2
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000020   0x....             B.N      u8g_draw_glyph180
    717          }
    718          
    719          

   \                                 In section .text, align 2, keep-with-next
    720          int8_t u8g_draw_glyph270(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t encoding)
    721          {
   \                     u8g_draw_glyph270: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4691             MOV      R9,R2
    722            const u8g_pgm_uint8_t *data;
    723            uint8_t w, h;
    724            uint8_t i, j;
    725            u8g_uint_t ix, iy;
    726          
    727            {
    728              u8g_glyph_t g = u8g_GetGlyph(u8g, encoding);
   \   0000000A   0x4619             MOV      R1,R3
   \   0000000C   0x.... 0x....      BL       u8g_GetGlyph
    729              if ( g == NULL  )
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??u8g_draw_glyph270_0
    730                return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE04A             B.N      ??u8g_draw_glyph270_1
    731              data = u8g_font_GetGlyphDataStart(u8g->font, g);
   \                     ??u8g_draw_glyph270_0: (+1)
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x68B0             LDR      R0,[R6, #+8]
   \   0000001C   0x.... 0x....      BL       u8g_font_GetGlyphDataStart
   \   00000020   0x4607             MOV      R7,R0
    732            }
    733            
    734            w = u8g->glyph_width;
   \   00000022   0x7FF4             LDRB     R4,[R6, #+31]
    735            h = u8g->glyph_height;
   \   00000024   0xF896 0x8020      LDRB     R8,[R6, #+32]
    736            
    737            x -= u8g->glyph_y;
    738            x--;
   \   00000028   0xF996 0x001E      LDRSB    R0,[R6, #+30]
   \   0000002C   0x1A2D             SUBS     R5,R5,R0
   \   0000002E   0x1E6D             SUBS     R5,R5,#+1
    739            y -= u8g->glyph_x;
   \   00000030   0xF996 0x001D      LDRSB    R0,[R6, #+29]
   \   00000034   0xEBA9 0x0900      SUB      R9,R9,R0
   \   00000038   0xF88D 0x9004      STRB     R9,[SP, #+4]
    740            
    741            if ( u8g_IsBBXIntersection(u8g, x-(h-1), y-(w-1), h, w) == 0 )
   \   0000003C   0xEBA5 0x0508      SUB      R5,R5,R8
   \   00000040   0x1C6D             ADDS     R5,R5,#+1
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0x4643             MOV      R3,R8
   \   00000048   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \   0000004C   0x1B12             SUBS     R2,R2,R4
   \   0000004E   0x1C52             ADDS     R2,R2,#+1
   \   00000050   0xB2D2             UXTB     R2,R2
   \   00000052   0x4629             MOV      R1,R5
   \   00000054   0xB2C9             UXTB     R1,R1
   \   00000056   0x4630             MOV      R0,R6
   \   00000058   0x.... 0x....      BL       u8g_IsBBXIntersection
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD024             BEQ.N    ??u8g_draw_glyph270_2
    742              return u8g->glyph_dx;
    743            
    744          
    745            /* now, w is reused as bytes per line */
    746            w += 7;
    747            w /= 8;  
   \   00000060   0x1DE4             ADDS     R4,R4,#+7
   \   00000062   0xB2E4             UXTB     R4,R4
    748                
    749            ix = x;
    750            ix -= h;
    751            ix++;
    752            
    753            for( j = 0; j < h; j++ )
   \   00000064   0xF04F 0x0900      MOV      R9,#+0
   \   00000068   0xE016             B.N      ??u8g_draw_glyph270_3
    754            {
    755              iy = y;
    756              for( i = 0; i < w; i++ )
    757              {
    758                u8g_Draw8Pixel(u8g, ix, iy, 3, u8g_pgm_read(data));
   \                     ??u8g_draw_glyph270_4: (+1)
   \   0000006A   0xF817 0x0B01      LDRB     R0,[R7], #+1
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0x2303             MOVS     R3,#+3
   \   00000072   0x4652             MOV      R2,R10
   \   00000074   0xB2D2             UXTB     R2,R2
   \   00000076   0x4629             MOV      R1,R5
   \   00000078   0xB2C9             UXTB     R1,R1
   \   0000007A   0x4630             MOV      R0,R6
   \   0000007C   0x.... 0x....      BL       u8g_Draw8Pixel
    759                data++;
    760                iy-=8;
   \   00000080   0xF1AA 0x0A08      SUB      R10,R10,#+8
    761              }
   \   00000084   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??u8g_draw_glyph270_5: (+1)
   \   00000088   0x4658             MOV      R0,R11
   \   0000008A   0xB2C0             UXTB     R0,R0
   \   0000008C   0xEBB0 0x0FD4      CMP      R0,R4, LSR #+3
   \   00000090   0xDBEB             BLT.N    ??u8g_draw_glyph270_4
    762              ix++;
   \   00000092   0x1C6D             ADDS     R5,R5,#+1
   \   00000094   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??u8g_draw_glyph270_3: (+1)
   \   00000098   0x4648             MOV      R0,R9
   \   0000009A   0xB2C0             UXTB     R0,R0
   \   0000009C   0x4540             CMP      R0,R8
   \   0000009E   0xDA04             BGE.N    ??u8g_draw_glyph270_2
   \   000000A0   0xF89D 0xA004      LDRB     R10,[SP, #+4]
   \   000000A4   0xF04F 0x0B00      MOV      R11,#+0
   \   000000A8   0xE7EE             B.N      ??u8g_draw_glyph270_5
    763            }
    764            return u8g->glyph_dx;
   \                     ??u8g_draw_glyph270_2: (+1)
   \   000000AA   0xF996 0x001C      LDRSB    R0,[R6, #+28]
   \                     ??u8g_draw_glyph270_1: (+1)
   \   000000AE   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    765          }
    766          

   \                                 In section .text, align 2, keep-with-next
    767          int8_t u8g_DrawGlyph270(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t encoding)
    768          {
   \                     u8g_DrawGlyph270: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    769            x += u8g->font_calc_vref(u8g);
   \   0000000A   0x6A61             LDR      R1,[R4, #+36]
   \   0000000C   0x4788             BLX      R1
   \   0000000E   0x1945             ADDS     R5,R0,R5
    770            return u8g_draw_glyph270(u8g, x, y, encoding);
   \   00000010   0x463B             MOV      R3,R7
   \   00000012   0x4632             MOV      R2,R6
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0xB2C9             UXTB     R1,R1
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000020   0x....             B.N      u8g_draw_glyph270
    771          }
    772          
    773          
    774          
    775          #ifdef OBSOLETE
    776          /*
    777            Draw a glyph
    778            x,y: lower left corner of the font bounding box
    779          */
    780          int8_t u8g_DrawGlyphFontBBX(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t dir, uint8_t encoding)
    781          {
    782            /* TODO: apply "dir" */
    783            x -= u8g_GetFontBBXOffX(u8g);
    784            y += u8g_GetFontBBXOffY(u8g);
    785            return u8g_DrawGlyphDir(u8g, x, y, dir, encoding);
    786          }
    787          #endif
    788          
    789          /*========================================================================*/
    790          /* string drawing procedures */
    791          
    792          

   \                                 In section .text, align 2, keep-with-next
    793          u8g_uint_t u8g_DrawStr(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, const char *s)
    794          {
   \                     u8g_DrawStr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    795            u8g_uint_t t = 0;
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
    796            int8_t d;
    797            
    798            //u8g_uint_t u8g_GetStrWidth(u8g, s);
    799            //u8g_font_GetFontAscent(u8g->font)-u8g_font_GetFontDescent(u8g->font);
    800            
    801            y += u8g->font_calc_vref(u8g);
   \   00000010   0x6A61             LDR      R1,[R4, #+36]
   \   00000012   0x4788             BLX      R1
   \   00000014   0x1986             ADDS     R6,R0,R6
   \   00000016   0xE00B             B.N      ??u8g_DrawStr_0
    802            
    803            while( *s != '\0' )
    804            {
    805              d = u8g_draw_glyph(u8g, x, y, *s);
   \                     ??u8g_DrawStr_1: (+1)
   \   00000018   0xF817 0x0B01      LDRB     R0,[R7], #+1
   \   0000001C   0x4603             MOV      R3,R0
   \   0000001E   0x4632             MOV      R2,R6
   \   00000020   0xB2D2             UXTB     R2,R2
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       u8g_draw_glyph
    806              x += d;
   \   0000002C   0x1945             ADDS     R5,R0,R5
    807              t += d;
   \   0000002E   0x4480             ADD      R8,R0,R8
    808              s++;
    809            }
   \                     ??u8g_DrawStr_0: (+1)
   \   00000030   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD1EF             BNE.N    ??u8g_DrawStr_1
    810            return t;
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    811          }
    812          

   \                                 In section .text, align 2, keep-with-next
    813          u8g_uint_t u8g_DrawStr90(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, const char *s)
    814          {
   \                     u8g_DrawStr90: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    815            u8g_uint_t t = 0;
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
    816            int8_t d;
    817              
    818            x -= u8g->font_calc_vref(u8g);
   \   00000010   0x6A61             LDR      R1,[R4, #+36]
   \   00000012   0x4788             BLX      R1
   \   00000014   0x1A2D             SUBS     R5,R5,R0
   \   00000016   0xE00B             B.N      ??u8g_DrawStr90_0
    819          
    820            while( *s != '\0' )
    821            {
    822              d = u8g_draw_glyph90(u8g, x, y, *s);
   \                     ??u8g_DrawStr90_1: (+1)
   \   00000018   0xF817 0x0B01      LDRB     R0,[R7], #+1
   \   0000001C   0x4603             MOV      R3,R0
   \   0000001E   0x4632             MOV      R2,R6
   \   00000020   0xB2D2             UXTB     R2,R2
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       u8g_draw_glyph90
    823              y += d;
   \   0000002C   0x1986             ADDS     R6,R0,R6
    824              t += d;
   \   0000002E   0x4480             ADD      R8,R0,R8
    825              s++;
    826            }
   \                     ??u8g_DrawStr90_0: (+1)
   \   00000030   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD1EF             BNE.N    ??u8g_DrawStr90_1
    827            return t;
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    828          }
    829          

   \                                 In section .text, align 2, keep-with-next
    830          u8g_uint_t u8g_DrawStr180(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, const char *s)
    831          {
   \                     u8g_DrawStr180: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    832            u8g_uint_t t = 0;
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
    833            int8_t d;
    834          
    835            y -= u8g->font_calc_vref(u8g);
   \   00000010   0x6A61             LDR      R1,[R4, #+36]
   \   00000012   0x4788             BLX      R1
   \   00000014   0x1A36             SUBS     R6,R6,R0
   \   00000016   0xE00B             B.N      ??u8g_DrawStr180_0
    836            
    837            while( *s != '\0' )
    838            {
    839              d = u8g_draw_glyph180(u8g, x, y, *s);
   \                     ??u8g_DrawStr180_1: (+1)
   \   00000018   0xF817 0x0B01      LDRB     R0,[R7], #+1
   \   0000001C   0x4603             MOV      R3,R0
   \   0000001E   0x4632             MOV      R2,R6
   \   00000020   0xB2D2             UXTB     R2,R2
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       u8g_draw_glyph180
    840              x -= d;
   \   0000002C   0x1A2D             SUBS     R5,R5,R0
    841              t += d;
   \   0000002E   0x4480             ADD      R8,R0,R8
    842              s++;
    843            }
   \                     ??u8g_DrawStr180_0: (+1)
   \   00000030   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD1EF             BNE.N    ??u8g_DrawStr180_1
    844            return t;
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    845          }
    846          

   \                                 In section .text, align 2, keep-with-next
    847          u8g_uint_t u8g_DrawStr270(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, const char *s)
    848          {
   \                     u8g_DrawStr270: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    849            u8g_uint_t t = 0;
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
    850            int8_t d;
    851          
    852            x += u8g->font_calc_vref(u8g);
   \   00000010   0x6A61             LDR      R1,[R4, #+36]
   \   00000012   0x4788             BLX      R1
   \   00000014   0x1945             ADDS     R5,R0,R5
   \   00000016   0xE00B             B.N      ??u8g_DrawStr270_0
    853          
    854            while( *s != '\0' )
    855            {
    856              d = u8g_draw_glyph270(u8g, x, y, *s);
   \                     ??u8g_DrawStr270_1: (+1)
   \   00000018   0xF817 0x0B01      LDRB     R0,[R7], #+1
   \   0000001C   0x4603             MOV      R3,R0
   \   0000001E   0x4632             MOV      R2,R6
   \   00000020   0xB2D2             UXTB     R2,R2
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       u8g_draw_glyph270
    857              y -= d;
   \   0000002C   0x1A36             SUBS     R6,R6,R0
    858              t += d;
   \   0000002E   0x4480             ADD      R8,R0,R8
    859              s++;
    860            }
   \                     ??u8g_DrawStr270_0: (+1)
   \   00000030   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD1EF             BNE.N    ??u8g_DrawStr270_1
    861            return t;
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    862          }
    863          

   \                                 In section .text, align 4, keep-with-next
    864          u8g_uint_t u8g_DrawStrDir(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t dir, const char *s)
    865          {
   \                     u8g_DrawStrDir: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   \   00000002   0x461C             MOV      R4,R3
   \   00000004   0x9B02             LDR      R3,[SP, #+8]
    866            switch(dir)
   \   00000006   0x2C03             CMP      R4,#+3
   \   00000008   0xD80F             BHI.N    ??u8g_DrawStrDir_1
   \   0000000A   0xE8DF 0xF004      TBB      [PC, R4]
   \                     ??u8g_DrawStrDir_0:
   \   0000000E   0x02 0x05          DC8      0x2,0x5,0x8,0xB
   \              0x08 0x0B    
    867            {
    868              case 0:
    869                return u8g_DrawStr(u8g, x, y, s);
   \                     ??u8g_DrawStrDir_2: (+1)
   \   00000012   0xB001             ADD      SP,SP,#+4
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x....             B.N      u8g_DrawStr
    870              case 1:
    871                return u8g_DrawStr90(u8g, x, y, s);
   \                     ??u8g_DrawStrDir_3: (+1)
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x....             B.N      u8g_DrawStr90
    872              case 2:
    873                return u8g_DrawStr180(u8g, x, y, s);
   \                     ??u8g_DrawStrDir_4: (+1)
   \   0000001E   0xB001             ADD      SP,SP,#+4
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x....             B.N      u8g_DrawStr180
    874              case 3:
    875                return u8g_DrawStr270(u8g, x, y, s);
   \                     ??u8g_DrawStrDir_5: (+1)
   \   00000024   0xB001             ADD      SP,SP,#+4
   \   00000026   0xBC10             POP      {R4}
   \   00000028   0x....             B.N      u8g_DrawStr270
    876            }
    877            return 0;
   \                     ??u8g_DrawStrDir_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBC12             POP      {R1,R4}
   \   0000002E   0x4770             BX       LR               ;; return
    878          }
    879          

   \                                 In section .text, align 2, keep-with-next
    880          u8g_uint_t u8g_DrawStrP(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, const u8g_pgm_uint8_t *s)
    881          {
   \                     u8g_DrawStrP: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    882            u8g_uint_t t = 0;
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
    883            int8_t d;
    884            uint8_t c;
    885            
    886            y += u8g->font_calc_vref(u8g);
   \   00000010   0x6A61             LDR      R1,[R4, #+36]
   \   00000012   0x4788             BLX      R1
   \   00000014   0x1986             ADDS     R6,R0,R6
   \   00000016   0xE009             B.N      ??u8g_DrawStrP_0
    887            
    888            for(;;)
    889            {
    890              c = u8g_pgm_read(s);
    891              if ( c == '\0' )
    892                break;
    893              d = u8g_draw_glyph(u8g, x, y, c);
   \                     ??u8g_DrawStrP_1: (+1)
   \   00000018   0x4632             MOV      R2,R6
   \   0000001A   0xB2D2             UXTB     R2,R2
   \   0000001C   0x4629             MOV      R1,R5
   \   0000001E   0xB2C9             UXTB     R1,R1
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       u8g_draw_glyph
    894              x += d;
   \   00000026   0x1945             ADDS     R5,R0,R5
    895              t += d;
   \   00000028   0x4480             ADD      R8,R0,R8
    896              s++;
   \   0000002A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??u8g_DrawStrP_0: (+1)
   \   0000002C   0x783B             LDRB     R3,[R7, #+0]
   \   0000002E   0x0018             MOVS     R0,R3
   \   00000030   0xD1F2             BNE.N    ??u8g_DrawStrP_1
    897            }
    898            return t;
   \   00000032   0x4640             MOV      R0,R8
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    899          }
    900          

   \                                 In section .text, align 2, keep-with-next
    901          u8g_uint_t u8g_DrawStr90P(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, const u8g_pgm_uint8_t *s)
    902          {
   \                     u8g_DrawStr90P: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    903            u8g_uint_t t = 0;
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
    904            int8_t d;
    905            
    906            x -= u8g->font_calc_vref(u8g);
   \   00000010   0x6A61             LDR      R1,[R4, #+36]
   \   00000012   0x4788             BLX      R1
   \   00000014   0x1A2D             SUBS     R5,R5,R0
   \   00000016   0xE00A             B.N      ??u8g_DrawStr90P_0
    907          
    908            while( *s != '\0' )
    909            {
    910              d = u8g_DrawGlyph90(u8g, x, y, u8g_pgm_read(s));
   \                     ??u8g_DrawStr90P_1: (+1)
   \   00000018   0xF817 0x3B01      LDRB     R3,[R7], #+1
   \   0000001C   0x4632             MOV      R2,R6
   \   0000001E   0xB2D2             UXTB     R2,R2
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0xB2C9             UXTB     R1,R1
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       u8g_DrawGlyph90
    911              y += d;
   \   0000002A   0x1986             ADDS     R6,R0,R6
    912              t += d;
   \   0000002C   0x4480             ADD      R8,R0,R8
    913              s++;
    914            }
   \                     ??u8g_DrawStr90P_0: (+1)
   \   0000002E   0x7838             LDRB     R0,[R7, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD1F1             BNE.N    ??u8g_DrawStr90P_1
    915            return t;
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    916          }
    917          

   \                                 In section .text, align 2, keep-with-next
    918          u8g_uint_t u8g_DrawStr180P(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, const u8g_pgm_uint8_t *s)
    919          {
   \                     u8g_DrawStr180P: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    920            u8g_uint_t t = 0;
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
    921            int8_t d;
    922          
    923            y -= u8g->font_calc_vref(u8g);
   \   00000010   0x6A61             LDR      R1,[R4, #+36]
   \   00000012   0x4788             BLX      R1
   \   00000014   0x1A36             SUBS     R6,R6,R0
   \   00000016   0xE00A             B.N      ??u8g_DrawStr180P_0
    924            
    925            while( *s != '\0' )
    926            {
    927              d = u8g_DrawGlyph180(u8g, x, y, u8g_pgm_read(s));
   \                     ??u8g_DrawStr180P_1: (+1)
   \   00000018   0xF817 0x3B01      LDRB     R3,[R7], #+1
   \   0000001C   0x4632             MOV      R2,R6
   \   0000001E   0xB2D2             UXTB     R2,R2
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0xB2C9             UXTB     R1,R1
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       u8g_DrawGlyph180
    928              x -= d;
   \   0000002A   0x1A2D             SUBS     R5,R5,R0
    929              t += d;
   \   0000002C   0x4480             ADD      R8,R0,R8
    930              s++;
    931            }
   \                     ??u8g_DrawStr180P_0: (+1)
   \   0000002E   0x7838             LDRB     R0,[R7, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD1F1             BNE.N    ??u8g_DrawStr180P_1
    932            return t;
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    933          }
    934          

   \                                 In section .text, align 2, keep-with-next
    935          u8g_uint_t u8g_DrawStr270P(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, const u8g_pgm_uint8_t *s)
    936          {
   \                     u8g_DrawStr270P: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    937            u8g_uint_t t = 0;
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
    938            int8_t d;
    939          
    940            x += u8g->font_calc_vref(u8g);
   \   00000010   0x6A61             LDR      R1,[R4, #+36]
   \   00000012   0x4788             BLX      R1
   \   00000014   0x1945             ADDS     R5,R0,R5
   \   00000016   0xE00A             B.N      ??u8g_DrawStr270P_0
    941          
    942            while( *s != '\0' )
    943            {
    944              d = u8g_DrawGlyph270(u8g, x, y, u8g_pgm_read(s));
   \                     ??u8g_DrawStr270P_1: (+1)
   \   00000018   0xF817 0x3B01      LDRB     R3,[R7], #+1
   \   0000001C   0x4632             MOV      R2,R6
   \   0000001E   0xB2D2             UXTB     R2,R2
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0xB2C9             UXTB     R1,R1
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       u8g_DrawGlyph270
    945              y -= d;
   \   0000002A   0x1A36             SUBS     R6,R6,R0
    946              t += d;
   \   0000002C   0x4480             ADD      R8,R0,R8
    947              s++;
    948            }
   \                     ??u8g_DrawStr270P_0: (+1)
   \   0000002E   0x7838             LDRB     R0,[R7, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD1F1             BNE.N    ??u8g_DrawStr270P_1
    949            return t;
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    950          }
    951          

   \                                 In section .text, align 2, keep-with-next
    952          u8g_uint_t u8g_DrawStrFontBBX(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t dir, const char *s)
    953          {
   \                     u8g_DrawStrFontBBX: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    954            x -= u8g_GetFontBBXOffX(u8g);
   \   00000010   0x.... 0x....      BL       u8g_GetFontBBXOffX
   \   00000014   0x1A2D             SUBS     R5,R5,R0
    955            y += u8g_GetFontBBXOffY(u8g);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       u8g_GetFontBBXOffY
   \   0000001C   0x1986             ADDS     R6,R0,R6
    956            return u8g_DrawStrDir(u8g, x, y, dir, s);
   \   0000001E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000022   0x463B             MOV      R3,R7
   \   00000024   0x4632             MOV      R2,R6
   \   00000026   0xB2D2             UXTB     R2,R2
   \   00000028   0x4629             MOV      R1,R5
   \   0000002A   0xB2C9             UXTB     R1,R1
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       u8g_DrawStrDir
   \   00000032   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    957          }
    958          
    959          /* still used by picgen.c, dir argument is ignored */

   \                                 In section .text, align 2, keep-with-next
    960          int8_t u8g_DrawGlyphFontBBX(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t dir, uint8_t encoding)
    961          {
   \                     u8g_DrawGlyphFontBBX: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
   \   00000008   0x9C06             LDR      R4,[SP, #+24]
    962            x -= u8g_GetFontBBXOffX(u8g);
   \   0000000A   0x.... 0x....      BL       u8g_GetFontBBXOffX
   \   0000000E   0x1A36             SUBS     R6,R6,R0
    963            y += u8g_GetFontBBXOffY(u8g);
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       u8g_GetFontBBXOffY
   \   00000016   0x19C7             ADDS     R7,R0,R7
    964            u8g_draw_glyph(u8g, x, y, encoding);
   \   00000018   0x4623             MOV      R3,R4
   \   0000001A   0x463A             MOV      R2,R7
   \   0000001C   0xB2D2             UXTB     R2,R2
   \   0000001E   0x4631             MOV      R1,R6
   \   00000020   0xB2C9             UXTB     R1,R1
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       u8g_draw_glyph
    965            return 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    966          }
    967          
    968          
    969          /*========================================================================*/
    970          /* set ascent/descent for reference point calculation */
    971          

   \                                 In section .text, align 2, keep-with-next
    972          void u8g_UpdateRefHeight(u8g_t *u8g)
    973          {
   \                     u8g_UpdateRefHeight: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    974            uint16_t ls;
    975            if ( u8g->font == NULL )
   \   00000004   0x68A0             LDR      R0,[R4, #+8]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD02B             BEQ.N    ??u8g_UpdateRefHeight_0
    976              return;
    977            if ( u8g->font_height_mode == U8G_FONT_HEIGHT_MODE_TEXT )
   \   0000000A   0xF104 0x0528      ADD      R5,R4,#+40
   \   0000000E   0x7829             LDRB     R1,[R5, #+0]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD107             BNE.N    ??u8g_UpdateRefHeight_1
    978            {
    979              u8g->font_ref_ascent = u8g_font_GetCapitalAHeight(u8g->font);
   \   00000014   0x.... 0x....      BL       u8g_font_GetCapitalAHeight
   \   00000018   0x7068             STRB     R0,[R5, #+1]
    980              u8g->font_ref_descent = u8g_font_GetLowerGDescent(u8g->font);
   \   0000001A   0x68A0             LDR      R0,[R4, #+8]
   \   0000001C   0x.... 0x....      BL       u8g_font_GetLowerGDescent
   \   00000020   0x70A8             STRB     R0,[R5, #+2]
   \   00000022   0xE010             B.N      ??u8g_UpdateRefHeight_2
    981            }
    982            else if ( u8g->font_height_mode == U8G_FONT_HEIGHT_MODE_XTEXT )
   \                     ??u8g_UpdateRefHeight_1: (+1)
   \   00000024   0x2901             CMP      R1,#+1
   \   00000026   0xD107             BNE.N    ??u8g_UpdateRefHeight_3
    983            {
    984              u8g->font_ref_ascent = u8g_font_GetFontXAscent(u8g->font);
   \   00000028   0x.... 0x....      BL       u8g_font_GetFontXAscent
   \   0000002C   0x7068             STRB     R0,[R5, #+1]
    985              u8g->font_ref_descent = u8g_font_GetFontXDescent(u8g->font);
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0x.... 0x....      BL       u8g_font_GetFontXDescent
   \   00000034   0x70A8             STRB     R0,[R5, #+2]
   \   00000036   0xE006             B.N      ??u8g_UpdateRefHeight_2
    986            }
    987            else
    988            {
    989              u8g->font_ref_ascent = u8g_font_GetFontAscent(u8g->font);
   \                     ??u8g_UpdateRefHeight_3: (+1)
   \   00000038   0x.... 0x....      BL       u8g_font_GetFontAscent
   \   0000003C   0x7068             STRB     R0,[R5, #+1]
    990              u8g->font_ref_descent = u8g_font_GetFontDescent(u8g->font);
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0x.... 0x....      BL       u8g_font_GetFontDescent
   \   00000044   0x70A8             STRB     R0,[R5, #+2]
    991            }
    992            
    993            ls = u8g->font_ref_ascent - u8g->font_ref_descent;
   \                     ??u8g_UpdateRefHeight_2: (+1)
   \   00000046   0xF995 0x1001      LDRSB    R1,[R5, #+1]
   \   0000004A   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   0000004E   0x1A08             SUBS     R0,R1,R0
    994            if ( u8g->font_line_spacing_factor != 64 )
   \   00000050   0x78E9             LDRB     R1,[R5, #+3]
   \   00000052   0x460A             MOV      R2,R1
   \   00000054   0x2A40             CMP      R2,#+64
   \   00000056   0xD003             BEQ.N    ??u8g_UpdateRefHeight_4
    995            {
    996              ls &= 255;
    997              ls *= u8g->font_line_spacing_factor;
    998              ls >>= 6;
   \   00000058   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   0000005C   0x4348             MULS     R0,R1,R0
   \   0000005E   0x0980             LSRS     R0,R0,#+6
    999            }
   1000            u8g->line_spacing = ls;
   \                     ??u8g_UpdateRefHeight_4: (+1)
   \   00000060   0x7128             STRB     R0,[R5, #+4]
   1001          }
   \                     ??u8g_UpdateRefHeight_0: (+1)
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1002          

   \                                 In section .text, align 2, keep-with-next
   1003          void u8g_SetFontRefHeightText(u8g_t *u8g)
   1004          {
   1005            u8g->font_height_mode = U8G_FONT_HEIGHT_MODE_TEXT;
   \                     u8g_SetFontRefHeightText: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x1028      STRB     R1,[R0, #+40]
   1006            u8g_UpdateRefHeight(u8g);
   \   00000006   0x....             B.N      u8g_UpdateRefHeight
   1007          }
   1008          

   \                                 In section .text, align 2, keep-with-next
   1009          void u8g_SetFontRefHeightExtendedText(u8g_t *u8g)
   1010          {
   1011            u8g->font_height_mode = U8G_FONT_HEIGHT_MODE_XTEXT;
   \                     u8g_SetFontRefHeightExtendedText: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF880 0x1028      STRB     R1,[R0, #+40]
   1012            u8g_UpdateRefHeight(u8g);
   \   00000006   0x....             B.N      u8g_UpdateRefHeight
   1013          }
   1014          
   1015          

   \                                 In section .text, align 2, keep-with-next
   1016          void u8g_SetFontRefHeightAll(u8g_t *u8g)
   1017          {
   1018            u8g->font_height_mode = U8G_FONT_HEIGHT_MODE_ALL;
   \                     u8g_SetFontRefHeightAll: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1028      STRB     R1,[R0, #+40]
   1019            u8g_UpdateRefHeight(u8g);
   \   00000006   0x....             B.N      u8g_UpdateRefHeight
   1020          }
   1021          
   1022          /* factor = 64: linespaceing == ascent and descent */

   \                                 In section .text, align 2, keep-with-next
   1023          void u8g_SetFontLineSpacingFactor(u8g_t *u8g, uint8_t  factor)
   1024          {
   1025            u8g->font_line_spacing_factor = factor;
   \                     u8g_SetFontLineSpacingFactor: (+1)
   \   00000000   0xF880 0x102B      STRB     R1,[R0, #+43]
   1026            u8g_UpdateRefHeight(u8g);
   \   00000004   0x....             B.N      u8g_UpdateRefHeight
   1027          }
   1028          
   1029          
   1030          
   1031          /*========================================================================*/
   1032          /* callback procedures to correct the y position */
   1033          

   \                                 In section .text, align 2, keep-with-next
   1034          u8g_uint_t u8g_font_calc_vref_font(u8g_t *u8g)
   1035          {
   1036            return 0;
   \                     u8g_font_calc_vref_font: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1037          }
   1038          

   \                                 In section .text, align 2, keep-with-next
   1039          void u8g_SetFontPosBaseline(u8g_t *u8g)
   1040          {
   1041            u8g->font_calc_vref = u8g_font_calc_vref_font;
   \                     u8g_SetFontPosBaseline: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable6
   \   00000002   0x6241             STR      R1,[R0, #+36]
   1042          }
   \   00000004   0x4770             BX       LR               ;; return
   1043          
   1044          

   \                                 In section .text, align 2, keep-with-next
   1045          u8g_uint_t u8g_font_calc_vref_bottom(u8g_t *u8g)
   1046          {
   1047            /* y += (u8g_uint_t)(u8g_int_t)(u8g->font_ref_descent); */
   1048            return (u8g_uint_t)(u8g_int_t)(u8g->font_ref_descent);
   \                     u8g_font_calc_vref_bottom: (+1)
   \   00000000   0xF990 0x002A      LDRSB    R0,[R0, #+42]
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x4770             BX       LR               ;; return
   1049          }
   1050          

   \                                 In section .text, align 2, keep-with-next
   1051          void u8g_SetFontPosBottom(u8g_t *u8g)
   1052          {
   1053            u8g->font_calc_vref = u8g_font_calc_vref_bottom;
   \                     u8g_SetFontPosBottom: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable6_1
   \   00000002   0x6241             STR      R1,[R0, #+36]
   1054          }
   \   00000004   0x4770             BX       LR               ;; return
   1055          

   \                                 In section .text, align 2, keep-with-next
   1056          u8g_uint_t u8g_font_calc_vref_top(u8g_t *u8g)
   1057          {
   1058            u8g_uint_t tmp;
   1059            /* reference pos is one pixel above the upper edge of the reference glyph */
   1060          
   1061            /*
   1062            y += (u8g_uint_t)(u8g_int_t)(u8g->font_ref_ascent);
   1063            y++;
   1064            */
   1065            tmp = (u8g_uint_t)(u8g_int_t)(u8g->font_ref_ascent);
   1066            tmp++;
   1067            return tmp;
   \                     u8g_font_calc_vref_top: (+1)
   \   00000000   0xF990 0x0029      LDRSB    R0,[R0, #+41]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x4770             BX       LR               ;; return
   1068          }
   1069          

   \                                 In section .text, align 2, keep-with-next
   1070          void u8g_SetFontPosTop(u8g_t *u8g)
   1071          {
   1072            u8g->font_calc_vref = u8g_font_calc_vref_top;
   \                     u8g_SetFontPosTop: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable6_2
   \   00000002   0x6241             STR      R1,[R0, #+36]
   1073          }
   \   00000004   0x4770             BX       LR               ;; return
   1074          

   \                                 In section .text, align 2, keep-with-next
   1075          u8g_uint_t u8g_font_calc_vref_center(u8g_t *u8g)
   1076          {
   \                     u8g_font_calc_vref_center: (+1)
   \   00000000   0x4601             MOV      R1,R0
   1077            int8_t tmp;
   1078            tmp = u8g->font_ref_ascent;
   1079            tmp -= u8g->font_ref_descent;
   1080            tmp /= 2;
   1081            tmp += u8g->font_ref_descent;  
   1082            /* y += (u8g_uint_t)(u8g_int_t)(tmp); */
   1083            return tmp;
   \   00000002   0xF991 0x002A      LDRSB    R0,[R1, #+42]
   \   00000006   0xF891 0x1029      LDRB     R1,[R1, #+41]
   \   0000000A   0x1A09             SUBS     R1,R1,R0
   \   0000000C   0xB249             SXTB     R1,R1
   \   0000000E   0xEB01 0x71D1      ADD      R1,R1,R1, LSR #+31
   \   00000012   0xEB10 0x0061      ADDS     R0,R0,R1, ASR #+1
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0x4770             BX       LR               ;; return
   1084          }
   1085          

   \                                 In section .text, align 2, keep-with-next
   1086          void u8g_SetFontPosCenter(u8g_t *u8g)
   1087          {
   1088            u8g->font_calc_vref = u8g_font_calc_vref_center;
   \                     u8g_SetFontPosCenter: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable6_3
   \   00000002   0x6241             STR      R1,[R0, #+36]
   1089          }
   \   00000004   0x4770             BX       LR               ;; return
   1090          
   1091          /*========================================================================*/
   1092          /* string pixel width calculation */
   1093          

   \                                 In section .text, align 2, keep-with-next
   1094          char u8g_font_get_char(const void *s)
   1095          {
   1096            return *(const char *)(s);
   \                     u8g_font_get_char: (+1)
   \   00000000   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1097          }
   1098          

   \                                 In section .text, align 2, keep-with-next
   1099          char u8g_font_get_charP(const void *s)
   1100          {
   1101            return u8g_pgm_read(s);
   \                     u8g_font_get_charP: (+1)
   \   00000000   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1102          }
   1103          
   1104          typedef char (*u8g_font_get_char_fn)(const void *s);
   1105          
   1106          

   \                                 In section .text, align 2, keep-with-next
   1107          u8g_uint_t u8g_font_calc_str_pixel_width(u8g_t *u8g, const char *s, u8g_font_get_char_fn get_char )
   1108          {
   \                     u8g_font_calc_str_pixel_width: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4617             MOV      R7,R2
   1109            u8g_uint_t  w;
   1110            uint8_t enc;
   1111            
   1112            /* reset the total minimal width to zero, this will be expanded during calculation */
   1113            w = 0;
   1114              
   1115            enc = get_char(s);
   \   0000000A   0x4630             MOV      R0,R6
   \   0000000C   0x47B8             BLX      R7
   \   0000000E   0x4680             MOV      R8,R0
   1116            
   1117            /* check for empty string, width is already 0 */
   1118            if ( enc == '\0' )
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??u8g_font_calc_str_pixel_width_0
   1119            {
   1120              return w;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE029             B.N      ??u8g_font_calc_str_pixel_width_1
   1121            }
   1122            
   1123            /* get the glyph information of the first char. This must be valid, because we already checked for the empty string */
   1124            /* if *s is not inside the font, then the cached parameters of the glyph are all zero */
   1125            u8g_GetGlyph(u8g, enc);
   \                     ??u8g_font_calc_str_pixel_width_0: (+1)
   \   0000001A   0x4641             MOV      R1,R8
   \   0000001C   0xB2C9             UXTB     R1,R1
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       u8g_GetGlyph
   1126          
   1127            /* strlen(s) == 1:       width = width(s[0]) */
   1128            /* strlen(s) == 2:       width = - offx(s[0]) + deltax(s[0]) + offx(s[1]) + width(s[1]) */
   1129            /* strlen(s) == 3:       width = - offx(s[0]) + deltax(s[0]) + deltax(s[1]) + offx(s[2]) + width(s[2]) */
   1130            
   1131            /* assume that the string has size 2 or more, than start with negative offset-x */
   1132            /* for string with size 1, this will be nullified after the loop */
   1133            w = -u8g->glyph_x;  
   \   00000024   0xF995 0x401D      LDRSB    R4,[R5, #+29]
   \   00000028   0x4264             RSBS     R4,R4,#+0
   \   0000002A   0xE00A             B.N      ??u8g_font_calc_str_pixel_width_2
   1134            for(;;)
   1135            {
   1136              
   1137              /* check and stop if the end of the string is reached */
   1138              s++;
   1139              if ( get_char(s) == '\0' )
   1140                break;
   1141              
   1142              /* if there are still more characters, add the delta to the next glyph */
   1143              w += u8g->glyph_dx;
   \                     ??u8g_font_calc_str_pixel_width_3: (+1)
   \   0000002C   0xF995 0x001C      LDRSB    R0,[R5, #+28]
   \   00000030   0x1904             ADDS     R4,R0,R4
   1144              
   1145              /* store the encoding in a local variable, used also after the for(;;) loop */
   1146              enc = get_char(s);
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x47B8             BLX      R7
   \   00000036   0x4680             MOV      R8,R0
   1147              
   1148              /* load the next glyph information */
   1149              u8g_GetGlyph(u8g, enc);
   \   00000038   0x4641             MOV      R1,R8
   \   0000003A   0xB2C9             UXTB     R1,R1
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x.... 0x....      BL       u8g_GetGlyph
   \                     ??u8g_font_calc_str_pixel_width_2: (+1)
   \   00000042   0x1C76             ADDS     R6,R6,#+1
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x47B8             BLX      R7
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD1EF             BNE.N    ??u8g_font_calc_str_pixel_width_3
   1150            }
   1151            
   1152            /* finally calculate the width of the last char */
   1153            /* here is another exception, if the last char is a black, use the dx value instead */
   1154            if ( enc != ' ' )
   \   0000004C   0xFA5F 0xF888      UXTB     R8,R8
   \   00000050   0xF1B8 0x0F20      CMP      R8,#+32
   \   00000054   0xD006             BEQ.N    ??u8g_font_calc_str_pixel_width_4
   1155            {
   1156              /* if g was not updated in the for loop (strlen() == 1), then the initial offset x gets removed */
   1157              w += u8g->glyph_width;
   1158              w += u8g->glyph_x;
   \   00000056   0x7FE8             LDRB     R0,[R5, #+31]
   \   00000058   0x1904             ADDS     R4,R0,R4
   \   0000005A   0xF995 0x001D      LDRSB    R0,[R5, #+29]
   \   0000005E   0x1904             ADDS     R4,R0,R4
   \   00000060   0xB2E4             UXTB     R4,R4
   \   00000062   0xE002             B.N      ??u8g_font_calc_str_pixel_width_5
   1159            }
   1160            else
   1161            {
   1162              w += u8g->glyph_dx;
   \                     ??u8g_font_calc_str_pixel_width_4: (+1)
   \   00000064   0xF995 0x001C      LDRSB    R0,[R5, #+28]
   \   00000068   0x1904             ADDS     R4,R0,R4
   1163            }
   1164            
   1165            
   1166            return w;
   \                     ??u8g_font_calc_str_pixel_width_5: (+1)
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0xB2C0             UXTB     R0,R0
   \                     ??u8g_font_calc_str_pixel_width_1: (+1)
   \   0000006E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1167          }
   1168          

   \                                 In section .text, align 2, keep-with-next
   1169          u8g_uint_t u8g_GetStrPixelWidth(u8g_t *u8g, const char *s)
   1170          {
   1171            return u8g_font_calc_str_pixel_width(u8g, s, u8g_font_get_char);
   \                     u8g_GetStrPixelWidth: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable6_4
   \   00000002   0x....             B.N      u8g_font_calc_str_pixel_width
   1172          }
   1173          

   \                                 In section .text, align 2, keep-with-next
   1174          u8g_uint_t u8g_GetStrPixelWidthP(u8g_t *u8g, const u8g_pgm_uint8_t *s)
   1175          {
   1176            return u8g_font_calc_str_pixel_width(u8g, (const char *)s, u8g_font_get_charP);
   \                     u8g_GetStrPixelWidthP: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable6_5
   \   00000002   0x....             B.N      u8g_font_calc_str_pixel_width
   1177          }
   1178          

   \                                 In section .text, align 2, keep-with-next
   1179          int8_t u8g_GetStrX(u8g_t *u8g, const char *s)
   1180          {
   \                     u8g_GetStrX: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1181            u8g_GetGlyph(u8g, *s);
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       u8g_GetGlyph
   1182            return u8g->glyph_x;  
   \   0000000E   0xF994 0x001D      LDRSB    R0,[R4, #+29]
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
   1183          }
   1184          

   \                                 In section .text, align 2, keep-with-next
   1185          int8_t u8g_GetStrXP(u8g_t *u8g, const u8g_pgm_uint8_t *s)
   1186          {
   \                     u8g_GetStrXP: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1187            u8g_GetGlyph(u8g, u8g_pgm_read(s));
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x.... 0x....      BL       u8g_GetGlyph
   1188            return u8g->glyph_x;  
   \   0000000A   0xF994 0x001D      LDRSB    R0,[R4, #+29]
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
   1189          }
   1190          
   1191          /*========================================================================*/
   1192          /* string width calculation */
   1193          

   \                                 In section .text, align 2, keep-with-next
   1194          u8g_uint_t u8g_GetStrWidth(u8g_t *u8g, const char *s)
   1195          {
   \                     u8g_GetStrWidth: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1196            u8g_uint_t  w;
   1197            uint8_t encoding;
   1198            
   1199            /* reset the total width to zero, this will be expanded during calculation */
   1200            w = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE006             B.N      ??u8g_GetStrWidth_0
   1201            
   1202            for(;;)
   1203            {
   1204              encoding = *s;
   1205              if ( encoding == 0 )
   1206                break;
   1207          
   1208              /* load glyph information */
   1209              u8g_GetGlyph(u8g, encoding);
   \                     ??u8g_GetStrWidth_1: (+1)
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       u8g_GetGlyph
   1210              w += u8g->glyph_dx;    
   \   00000010   0xF994 0x001C      LDRSB    R0,[R4, #+28]
   \   00000014   0x1986             ADDS     R6,R0,R6
   1211              
   1212              /* goto next char */
   1213              s++;
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \                     ??u8g_GetStrWidth_0: (+1)
   \   00000018   0x7829             LDRB     R1,[R5, #+0]
   \   0000001A   0x0008             MOVS     R0,R1
   \   0000001C   0xD1F5             BNE.N    ??u8g_GetStrWidth_1
   1214            }
   1215            
   1216            return w;  
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
   1217          }
   1218          
   1219          

   \                                 In section .text, align 2, keep-with-next
   1220          u8g_uint_t u8g_GetStrWidthP(u8g_t *u8g, const u8g_pgm_uint8_t *s)
   1221          {
   \                     u8g_GetStrWidthP: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1222            u8g_uint_t  w;
   1223            uint8_t encoding;
   1224            
   1225            /* reset the total width to zero, this will be expanded during calculation */
   1226            w = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE006             B.N      ??u8g_GetStrWidthP_0
   1227            
   1228            for(;;)
   1229            {
   1230              encoding = u8g_pgm_read(s);
   1231              if ( encoding == 0 )
   1232                break;
   1233          
   1234              /* load glyph information */
   1235              u8g_GetGlyph(u8g, encoding);
   \                     ??u8g_GetStrWidthP_1: (+1)
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       u8g_GetGlyph
   1236              w += u8g->glyph_dx;    
   \   00000010   0xF994 0x001C      LDRSB    R0,[R4, #+28]
   \   00000014   0x1986             ADDS     R6,R0,R6
   1237              
   1238              /* goto next char */
   1239              s++;
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \                     ??u8g_GetStrWidthP_0: (+1)
   \   00000018   0x7829             LDRB     R1,[R5, #+0]
   \   0000001A   0x0008             MOVS     R0,R1
   \   0000001C   0xD1F5             BNE.N    ??u8g_GetStrWidthP_1
   1240            }
   1241            
   1242            return w;  
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
   1243          }
   1244          
   1245          
   1246          /*========================================================================*/
   1247          /* calculation of font/glyph/string characteristics */
   1248          
   1249          
   1250          /*
   1251            Description:
   1252              Calculate parameter for the minimal bounding box on a given string
   1253            Output
   1254              buf->y_min          extend of the lower left edge if the string below (y_min<0) or above (y_min>0) baseline (descent)
   1255              buf->y_max          extend of the upper left edge if the string below (y_min<0) or above (y_min>0) baseline (ascent)
   1256              buf->w                 the width of the string
   1257          */
   1258          struct u8g_str_size_struct
   1259          {
   1260            int8_t y_min;         /* descent */
   1261            int8_t y_max;         /* ascent */
   1262            int8_t x, y;             /* the reference point of the font (negated!) */
   1263            u8g_uint_t w;         /* width of the overall string */
   1264          };
   1265          typedef struct u8g_str_size_struct u8g_str_size_t;
   1266          

   \                                 In section .text, align 2, keep-with-next
   1267          static void u8g_font_calc_str_min_box(u8g_t *u8g, const char *s, u8g_str_size_t *buf)
   1268          {
   \                     u8g_font_calc_str_min_box: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4614             MOV      R4,R2
   1269            /* u8g_glyph_t g; */
   1270            int8_t tmp;
   1271            
   1272            /* reset the total minimal width to zero, this will be expanded during calculation */
   1273            buf->w = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x7120             STRB     R0,[R4, #+4]
   1274              
   1275            /* check for empty string, width is already 0, but also reset y_min and y_max to 0 */
   1276            if ( *s == '\0' )
   \   0000000C   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??u8g_font_calc_str_min_box_0
   1277            {
   1278              buf->y_min = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7020             STRB     R0,[R4, #+0]
   1279              buf->y_max = 0;
   \   00000018   0x7060             STRB     R0,[R4, #+1]
   1280              buf->x = 0;
   \   0000001A   0x70A0             STRB     R0,[R4, #+2]
   1281              buf->y = 0;
   \   0000001C   0x70E0             STRB     R0,[R4, #+3]
   1282              return;
   \   0000001E   0xBD70             POP      {R4-R6,PC}
   1283            }
   1284            
   1285            /* reset y_min to the largest possible value. Later we search for the smallest value */
   1286            /* y_min contains the position [pixel] of the lower left edge of the glyph above (y_min>0) or below (y_min<0) baseline  */
   1287            buf->y_min = 127;
   \                     ??u8g_font_calc_str_min_box_0: (+1)
   \   00000020   0x207F             MOVS     R0,#+127
   \   00000022   0x7020             STRB     R0,[R4, #+0]
   1288            /* reset y_max to the smallest possible value. Later we search for the highest value */
   1289            /* y_max contains the position [pixel] of the upper left edge of the glyph above (y_max>0) or below (y_max<0) baseline  */
   1290            buf->y_max = -128;
   \   00000024   0xF06F 0x007F      MVN      R0,#+127
   \   00000028   0x7060             STRB     R0,[R4, #+1]
   1291          
   1292            /* get the glyph information of the first char. This must be valid, because we already checked for the empty string */
   1293            u8g_GetGlyph(u8g, *s);
   \   0000002A   0x7830             LDRB     R0,[R6, #+0]
   \   0000002C   0x4601             MOV      R1,R0
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       u8g_GetGlyph
   1294          
   1295            /* strlen(s) == 1:       width = width(s[0]) */
   1296            /* strlen(s) == 2:       width = - offx(s[0]) + deltax(s[0]) + offx(s[1]) + width(s[1]) */
   1297            /* strlen(s) == 3:       width = - offx(s[0]) + deltax(s[0]) + deltax(s[1]) + offx(s[2]) + width(s[2]) */
   1298            
   1299            /* assume that the string has size 2 or more, than start with negative offset-x */
   1300            /* for string with size 1, this will be nullified after the loop */
   1301            // buf->w = - u8g_font_GetGlyphBBXOffX(u8g->font, g);
   1302            buf->w = - u8g->glyph_x;
   \   00000034   0xF995 0x001D      LDRSB    R0,[R5, #+29]
   \   00000038   0x4240             RSBS     R0,R0,#+0
   \   0000003A   0x7120             STRB     R0,[R4, #+4]
   1303            
   1304            /* Also copy the position of the first glyph. This is the reference point of the string (negated) */
   1305            buf->x = u8g->glyph_x;
   \   0000003C   0x7F68             LDRB     R0,[R5, #+29]
   \   0000003E   0x70A0             STRB     R0,[R4, #+2]
   1306            buf->y = u8g->glyph_y;
   \   00000040   0x7FA8             LDRB     R0,[R5, #+30]
   \   00000042   0x70E0             STRB     R0,[R4, #+3]
   \   00000044   0xE008             B.N      ??u8g_font_calc_str_min_box_1
   1307            
   1308            for(;;)
   1309            {
   1310              
   1311              /* calculated y position of the upper left corner (y_max) and lower left corner (y_min) of the string */
   1312              /* relative to the base line */
   1313              
   1314              tmp = u8g->glyph_y;
   1315              if ( buf->y_min > tmp )
   1316                buf->y_min = tmp;
   1317              
   1318              tmp +=u8g->glyph_height;
   1319              if ( buf->y_max < tmp )
   1320                buf->y_max = tmp;
   1321              
   1322              /* check and stop if the end of the string is reached */
   1323              s++;
   1324              if ( *s == '\0' )
   1325                break;
   1326              
   1327              /* if there are still more characters, add the delta to the next glyph */
   1328              buf->w += u8g->glyph_dx;
   \                     ??u8g_font_calc_str_min_box_2: (+1)
   \   00000046   0xF995 0x001C      LDRSB    R0,[R5, #+28]
   \   0000004A   0x1841             ADDS     R1,R0,R1
   \   0000004C   0x7121             STRB     R1,[R4, #+4]
   1329              
   1330              /* load the next glyph information */
   1331              u8g_GetGlyph(u8g, *s);
   \   0000004E   0x7830             LDRB     R0,[R6, #+0]
   \   00000050   0x4601             MOV      R1,R0
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       u8g_GetGlyph
   \                     ??u8g_font_calc_str_min_box_1: (+1)
   \   00000058   0xF995 0x001E      LDRSB    R0,[R5, #+30]
   \   0000005C   0xF994 0x1000      LDRSB    R1,[R4, #+0]
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xDA00             BGE.N    ??u8g_font_calc_str_min_box_3
   \   00000064   0x7020             STRB     R0,[R4, #+0]
   \                     ??u8g_font_calc_str_min_box_3: (+1)
   \   00000066   0xF895 0x1020      LDRB     R1,[R5, #+32]
   \   0000006A   0x1808             ADDS     R0,R1,R0
   \   0000006C   0xF994 0x1001      LDRSB    R1,[R4, #+1]
   \   00000070   0x4602             MOV      R2,R0
   \   00000072   0xB252             SXTB     R2,R2
   \   00000074   0x4291             CMP      R1,R2
   \   00000076   0xDA00             BGE.N    ??u8g_font_calc_str_min_box_4
   \   00000078   0x7060             STRB     R0,[R4, #+1]
   \                     ??u8g_font_calc_str_min_box_4: (+1)
   \   0000007A   0x7921             LDRB     R1,[R4, #+4]
   \   0000007C   0xF916 0x0F01      LDRSB    R0,[R6, #+1]!
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD1E0             BNE.N    ??u8g_font_calc_str_min_box_2
   1332            }
   1333            
   1334            /* finally calculate the width of the last char */
   1335            /* if g was not updated in the for loop (strlen() == 1), then the initial offset x gets removed */
   1336            buf->w += u8g->glyph_width;
   \   00000084   0x7FE8             LDRB     R0,[R5, #+31]
   \   00000086   0x1841             ADDS     R1,R0,R1
   \   00000088   0x7121             STRB     R1,[R4, #+4]
   1337            // buf->w += u8g_font_GetGlyphBBXOffX(u8g->font, g);
   1338            
   1339            buf->w += u8g->glyph_x;
   \   0000008A   0xF995 0x001D      LDRSB    R0,[R5, #+29]
   \   0000008E   0x1841             ADDS     R1,R0,R1
   \   00000090   0x7121             STRB     R1,[R4, #+4]
   1340          }
   \   00000092   0xBD70             POP      {R4-R6,PC}       ;; return
   1341          
   1342          /* calculate minimal box */

   \                                 In section .text, align 2, keep-with-next
   1343          void u8g_font_box_min(u8g_t *u8g, const char *s, u8g_str_size_t *buf)
   1344          {
   1345            u8g_font_calc_str_min_box(u8g, s, buf);
   \                     u8g_font_box_min: (+1)
   \   00000000   0x....             B.N      u8g_font_calc_str_min_box
   1346          }
   1347          
   1348          /* calculate gA box, but do not calculate the overall width */

   \                                 In section .text, align 2, keep-with-next
   1349          void u8g_font_box_left_gA(u8g_t *u8g, const char *s, u8g_str_size_t *buf)
   1350          {
   1351            
   1352          }
   \                     u8g_font_box_left_gA: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1353          
   1354          /* calculate gA box, including overall width */

   \                                 In section .text, align 2, keep-with-next
   1355          void u8g_font_box_all_gA(u8g_t *u8g, const char *s, u8g_str_size_t *buf)
   1356          {
   1357            
   1358          }
   \                     u8g_font_box_all_gA: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1359          
   1360          

   \                                 In section .text, align 2, keep-with-next
   1361          static void u8g_font_get_str_box_fill_args(u8g_t *u8g, const char *s, u8g_str_size_t *buf, u8g_uint_t *x, u8g_uint_t *y, u8g_uint_t *width, u8g_uint_t *height)
   1362          {
   \                     u8g_font_get_str_box_fill_args: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x461F             MOV      R7,R3
   \   0000000A   0x9E08             LDR      R6,[SP, #+32]
   \   0000000C   0xF8DD 0x8024      LDR      R8,[SP, #+36]
   \   00000010   0x9C0A             LDR      R4,[SP, #+40]
   1363            /*
   1364            u8g_glyph_t g;
   1365            g =
   1366            */  
   1367            u8g_GetGlyph(u8g, *s);
   \   00000012   0x7808             LDRB     R0,[R1, #+0]
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0x4648             MOV      R0,R9
   \   00000018   0x.... 0x....      BL       u8g_GetGlyph
   1368            *x += u8g->glyph_x;
   \   0000001C   0x7839             LDRB     R1,[R7, #+0]
   \   0000001E   0xF999 0x001D      LDRSB    R0,[R9, #+29]
   \   00000022   0x1841             ADDS     R1,R0,R1
   \   00000024   0x7039             STRB     R1,[R7, #+0]
   1369            *width = buf->w;
   \   00000026   0x7928             LDRB     R0,[R5, #+4]
   \   00000028   0xF888 0x0000      STRB     R0,[R8, #+0]
   1370            *y -= buf->y_max;
   \   0000002C   0x7831             LDRB     R1,[R6, #+0]
   \   0000002E   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000032   0x1A09             SUBS     R1,R1,R0
   \   00000034   0x7031             STRB     R1,[R6, #+0]
   1371            /* +1 because y_max is a height, this compensates the next step */
   1372            //*y += 1;                      
   1373            /* because the reference point is one below the string, this compensates the previous step */
   1374            //*y -= 1;
   1375            *height = buf->y_max;
   \   00000036   0x7868             LDRB     R0,[R5, #+1]
   \   00000038   0x7020             STRB     R0,[R4, #+0]
   1376            *height -= buf->y_min;
   \   0000003A   0x4601             MOV      R1,R0
   \   0000003C   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000040   0x1A09             SUBS     R1,R1,R0
   \   00000042   0x7021             STRB     R1,[R4, #+0]
   1377          }
   \   00000044   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1378          
   1379          

   \                                 In section .text, align 2, keep-with-next
   1380          void u8g_GetStrMinBox(u8g_t *u8g, const char *s, u8g_uint_t *x, u8g_uint_t *y, u8g_uint_t *width, u8g_uint_t *height)
   1381          {
   \                     u8g_GetStrMinBox: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4605             MOV      R5,R0
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4617             MOV      R7,R2
   \   0000000C   0x4698             MOV      R8,R3
   \   0000000E   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   \   00000012   0x9C0D             LDR      R4,[SP, #+52]
   1382            u8g_str_size_t buf;
   1383            
   1384            if ( *s == '\0' )
   \   00000014   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD104             BNE.N    ??u8g_GetStrMinBox_0
   1385            {
   1386              *width= 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF889 0x0000      STRB     R0,[R9, #+0]
   1387              *height = 0;
   \   00000022   0x7020             STRB     R0,[R4, #+0]
   1388              return;
   \   00000024   0xE00E             B.N      ??u8g_GetStrMinBox_1
   1389            }
   1390            
   1391            u8g_font_calc_str_min_box(u8g, s, &buf);
   \                     ??u8g_GetStrMinBox_0: (+1)
   \   00000026   0xAA03             ADD      R2,SP,#+12
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       u8g_font_calc_str_min_box
   1392            u8g_font_get_str_box_fill_args(u8g, s, &buf, x, y, width, height);
   \   0000002E   0x9402             STR      R4,[SP, #+8]
   \   00000030   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   00000034   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000038   0x463B             MOV      R3,R7
   \   0000003A   0xAA03             ADD      R2,SP,#+12
   \   0000003C   0x4631             MOV      R1,R6
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       u8g_font_get_str_box_fill_args
   1393          }
   \                     ??u8g_GetStrMinBox_1: (+1)
   \   00000044   0xB005             ADD      SP,SP,#+20
   \   00000046   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1394          
   1395          

   \                                 In section .text, align 2, keep-with-next
   1396          void u8g_GetStrAMinBox(u8g_t *u8g, const char *s, u8g_uint_t *x, u8g_uint_t *y, u8g_uint_t *width, u8g_uint_t *height)
   1397          {
   \                     u8g_GetStrAMinBox: (+1)
   \   00000000   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4681             MOV      R9,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
   \   0000000E   0x9F0E             LDR      R7,[SP, #+56]
   \   00000010   0xF8DD 0x803C      LDR      R8,[SP, #+60]
   1398            u8g_str_size_t buf;
   1399            uint8_t cap_a;
   1400            
   1401            if ( *s == '\0' )
   \   00000014   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD104             BNE.N    ??u8g_GetStrAMinBox_0
   1402            {
   1403              *width= 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x7038             STRB     R0,[R7, #+0]
   1404              *height = 0;
   \   00000020   0xF888 0x0000      STRB     R0,[R8, #+0]
   1405              return;
   \   00000024   0xE019             B.N      ??u8g_GetStrAMinBox_1
   1406            }
   1407            
   1408            cap_a = u8g_font_GetCapitalAHeight(u8g->font);
   \                     ??u8g_GetStrAMinBox_0: (+1)
   \   00000026   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   0000002A   0x.... 0x....      BL       u8g_font_GetCapitalAHeight
   \   0000002E   0x4682             MOV      R10,R0
   1409            u8g_font_calc_str_min_box(u8g, s, &buf);
   \   00000030   0xAA03             ADD      R2,SP,#+12
   \   00000032   0x4621             MOV      R1,R4
   \   00000034   0x4648             MOV      R0,R9
   \   00000036   0x.... 0x....      BL       u8g_font_calc_str_min_box
   1410            if ( buf.y_max < cap_a )
   \   0000003A   0xF99D 0x000D      LDRSB    R0,[SP, #+13]
   \   0000003E   0x4550             CMP      R0,R10
   \   00000040   0xDA01             BGE.N    ??u8g_GetStrAMinBox_2
   1411              buf.y_max = cap_a;
   \   00000042   0xF88D 0xA00D      STRB     R10,[SP, #+13]
   1412            u8g_font_get_str_box_fill_args(u8g, s, &buf, x, y, width, height);
   \                     ??u8g_GetStrAMinBox_2: (+1)
   \   00000046   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \   0000004A   0x9701             STR      R7,[SP, #+4]
   \   0000004C   0x9600             STR      R6,[SP, #+0]
   \   0000004E   0x462B             MOV      R3,R5
   \   00000050   0xAA03             ADD      R2,SP,#+12
   \   00000052   0x4621             MOV      R1,R4
   \   00000054   0x4648             MOV      R0,R9
   \   00000056   0x.... 0x....      BL       u8g_font_get_str_box_fill_args
   1413          }
   \                     ??u8g_GetStrAMinBox_1: (+1)
   \   0000005A   0xB006             ADD      SP,SP,#+24
   \   0000005C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1414          

   \                                 In section .text, align 2, keep-with-next
   1415          void u8g_SetFont(u8g_t *u8g, const u8g_fntpgm_uint8_t  *font)
   1416          {
   \                     u8g_SetFont: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1417            if ( u8g->font != font )
   \   00000004   0x68A0             LDR      R0,[R4, #+8]
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD007             BEQ.N    ??u8g_SetFont_0
   1418            {
   1419              u8g->font = font;
   \   0000000A   0x60A1             STR      R1,[R4, #+8]
   1420              u8g_UpdateRefHeight(u8g);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       u8g_UpdateRefHeight
   1421              u8g_SetFontPosBaseline(u8g);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x....             B.N      u8g_SetFontPosBaseline
   1422            }
   1423          }
   \                     ??u8g_SetFont_0: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
   1424          
   1425          /*========================================================================*/
   1426          /* anti aliasing fonts */
   1427          

   \                                 In section .text, align 2, keep-with-next
   1428          int8_t u8g_draw_aa_glyph(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t encoding)
   1429          {
   \                     u8g_draw_aa_glyph: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4691             MOV      R9,R2
   1430            const u8g_pgm_uint8_t *data;
   1431            uint8_t w, h;
   1432            uint8_t i, j;
   1433            u8g_uint_t ix, iy;
   1434          
   1435            {
   1436              u8g_glyph_t g = u8g_GetGlyph(u8g, encoding);
   \   0000000A   0x4619             MOV      R1,R3
   \   0000000C   0x.... 0x....      BL       u8g_GetGlyph
   1437              if ( g == NULL  )
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??u8g_draw_aa_glyph_0
   1438                return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE048             B.N      ??u8g_draw_aa_glyph_1
   1439              data = u8g_font_GetGlyphDataStart(u8g->font, g);
   \                     ??u8g_draw_aa_glyph_0: (+1)
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x68B0             LDR      R0,[R6, #+8]
   \   0000001C   0x.... 0x....      BL       u8g_font_GetGlyphDataStart
   \   00000020   0x4607             MOV      R7,R0
   1440            }
   1441            
   1442            w = u8g->glyph_width;
   \   00000022   0x7FF4             LDRB     R4,[R6, #+31]
   1443            h = u8g->glyph_height;
   \   00000024   0xF896 0x8020      LDRB     R8,[R6, #+32]
   1444            
   1445            x += u8g->glyph_x;
   \   00000028   0xF996 0x001D      LDRSB    R0,[R6, #+29]
   \   0000002C   0x1945             ADDS     R5,R0,R5
   \   0000002E   0xF88D 0x5004      STRB     R5,[SP, #+4]
   1446            y -= u8g->glyph_y;
   1447            y--;
   \   00000032   0xF996 0x001E      LDRSB    R0,[R6, #+30]
   \   00000036   0xEBA9 0x0900      SUB      R9,R9,R0
   \   0000003A   0xF1A9 0x0501      SUB      R5,R9,#+1
   1448            
   1449            if ( u8g_IsBBXIntersection(u8g, x, y-h+1, w, h) == 0 )
   \   0000003E   0xEBA5 0x0508      SUB      R5,R5,R8
   \   00000042   0x1C6D             ADDS     R5,R5,#+1
   \   00000044   0x4640             MOV      R0,R8
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0x4623             MOV      R3,R4
   \   0000004A   0x462A             MOV      R2,R5
   \   0000004C   0xB2D2             UXTB     R2,R2
   \   0000004E   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0x.... 0x....      BL       u8g_IsBBXIntersection
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD024             BEQ.N    ??u8g_draw_aa_glyph_2
   1450              return u8g->glyph_dx;
   1451          
   1452            /* now, w is reused as bytes per line */
   1453            w += 3;
   1454            w /= 4;
   \   0000005C   0x1CE4             ADDS     R4,R4,#+3
   \   0000005E   0xB2E4             UXTB     R4,R4
   1455            
   1456            iy = y;
   1457            iy -= h;
   1458            iy++;
   1459          
   1460            for( j = 0; j < h; j++ )
   \   00000060   0xF04F 0x0900      MOV      R9,#+0
   \   00000064   0xE016             B.N      ??u8g_draw_aa_glyph_3
   1461            {
   1462              ix = x;
   1463              for( i = 0; i < w; i++ )
   1464              {
   1465                u8g_Draw4TPixel(u8g, ix, iy, 0, u8g_pgm_read(data));
   \                     ??u8g_draw_aa_glyph_4: (+1)
   \   00000066   0xF817 0x0B01      LDRB     R0,[R7], #+1
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x2300             MOVS     R3,#+0
   \   0000006E   0x462A             MOV      R2,R5
   \   00000070   0xB2D2             UXTB     R2,R2
   \   00000072   0x4651             MOV      R1,R10
   \   00000074   0xB2C9             UXTB     R1,R1
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       u8g_Draw4TPixel
   1466                data++;
   1467                ix+=4;
   \   0000007C   0xF10A 0x0A04      ADD      R10,R10,#+4
   1468              }
   \   00000080   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??u8g_draw_aa_glyph_5: (+1)
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0xB2C0             UXTB     R0,R0
   \   00000088   0xEBB0 0x0F94      CMP      R0,R4, LSR #+2
   \   0000008C   0xDBEB             BLT.N    ??u8g_draw_aa_glyph_4
   1469              iy++;
   \   0000008E   0x1C6D             ADDS     R5,R5,#+1
   \   00000090   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??u8g_draw_aa_glyph_3: (+1)
   \   00000094   0x4648             MOV      R0,R9
   \   00000096   0xB2C0             UXTB     R0,R0
   \   00000098   0x4540             CMP      R0,R8
   \   0000009A   0xDA04             BGE.N    ??u8g_draw_aa_glyph_2
   \   0000009C   0xF89D 0xA004      LDRB     R10,[SP, #+4]
   \   000000A0   0xF04F 0x0B00      MOV      R11,#+0
   \   000000A4   0xE7EE             B.N      ??u8g_draw_aa_glyph_5
   1470            }
   1471            return u8g->glyph_dx;
   \                     ??u8g_draw_aa_glyph_2: (+1)
   \   000000A6   0xF996 0x001C      LDRSB    R0,[R6, #+28]
   \                     ??u8g_draw_aa_glyph_1: (+1)
   \   000000AA   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   1472          }
   1473          

   \                                 In section .text, align 2, keep-with-next
   1474          int8_t u8g_DrawAAGlyph(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t encoding)
   1475          {
   \                     u8g_DrawAAGlyph: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   1476            y += u8g->font_calc_vref(u8g);
   \   0000000A   0x6A61             LDR      R1,[R4, #+36]
   \   0000000C   0x4788             BLX      R1
   \   0000000E   0x1986             ADDS     R6,R0,R6
   1477            return u8g_draw_aa_glyph(u8g, x, y, encoding);
   \   00000010   0x463B             MOV      R3,R7
   \   00000012   0x4632             MOV      R2,R6
   \   00000014   0xB2D2             UXTB     R2,R2
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000020   0x....             B.N      u8g_draw_aa_glyph
   1478          }
   1479          

   \                                 In section .text, align 2, keep-with-next
   1480          u8g_uint_t u8g_DrawAAStr(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, const char *s)
   1481          {
   \                     u8g_DrawAAStr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461C             MOV      R4,R3
   1482            u8g_uint_t t = 0;
   \   0000000C   0x2500             MOVS     R5,#+0
   1483            int8_t d;
   1484          
   1485            if ( u8g_font_GetFormat(u8g->font)  != 2 )
   \   0000000E   0x68B0             LDR      R0,[R6, #+8]
   \   00000010   0x.... 0x....      BL       u8g_font_GetFormat
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD001             BEQ.N    ??u8g_DrawAAStr_0
   1486              return 0;
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0xE016             B.N      ??u8g_DrawAAStr_1
   1487            //u8g_uint_t u8g_GetStrWidth(u8g, s);
   1488            //u8g_font_GetFontAscent(u8g->font)-u8g_font_GetFontDescent(u8g->font);
   1489            
   1490            y += u8g->font_calc_vref(u8g);
   \                     ??u8g_DrawAAStr_0: (+1)
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x6A71             LDR      R1,[R6, #+36]
   \   00000020   0x4788             BLX      R1
   \   00000022   0x4480             ADD      R8,R0,R8
   \   00000024   0xE00B             B.N      ??u8g_DrawAAStr_2
   1491            
   1492            while( *s != '\0' )
   1493            {
   1494              d = u8g_draw_aa_glyph(u8g, x, y, *s);
   \                     ??u8g_DrawAAStr_3: (+1)
   \   00000026   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   0000002A   0x4603             MOV      R3,R0
   \   0000002C   0x4642             MOV      R2,R8
   \   0000002E   0xB2D2             UXTB     R2,R2
   \   00000030   0x4639             MOV      R1,R7
   \   00000032   0xB2C9             UXTB     R1,R1
   \   00000034   0x4630             MOV      R0,R6
   \   00000036   0x.... 0x....      BL       u8g_draw_aa_glyph
   1495              x += d;
   \   0000003A   0x19C7             ADDS     R7,R0,R7
   1496              t += d;
   \   0000003C   0x1945             ADDS     R5,R0,R5
   1497              s++;
   1498            }
   \                     ??u8g_DrawAAStr_2: (+1)
   \   0000003E   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD1EF             BNE.N    ??u8g_DrawAAStr_3
   1499            return t;
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0xB2C0             UXTB     R0,R0
   \                     ??u8g_DrawAAStr_1: (+1)
   \   0000004A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1500          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     u8g_font_calc_vref_font

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     u8g_font_calc_vref_bottom

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     u8g_font_calc_vref_top

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     u8g_font_calc_vref_center

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     u8g_font_get_char

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     u8g_font_get_charP

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   u8g_CopyGlyphDataToCache
        16   -> u8g_font_GetFormat
      24   u8g_DrawAAGlyph
        24   -- Indirect call
         0   -> u8g_draw_aa_glyph
      24   u8g_DrawAAStr
        24   -- Indirect call
        24   -> u8g_draw_aa_glyph
        24   -> u8g_font_GetFormat
      24   u8g_DrawGlyph
        24   -- Indirect call
         0   -> u8g_draw_glyph
      24   u8g_DrawGlyph180
        24   -- Indirect call
         0   -> u8g_draw_glyph180
      24   u8g_DrawGlyph270
        24   -- Indirect call
         0   -> u8g_draw_glyph270
      24   u8g_DrawGlyph90
        24   -- Indirect call
         0   -> u8g_draw_glyph90
      24   u8g_DrawGlyphFontBBX
        24   -> u8g_GetFontBBXOffX
        24   -> u8g_GetFontBBXOffY
        24   -> u8g_draw_glyph
      24   u8g_DrawStr
        24   -- Indirect call
        24   -> u8g_draw_glyph
      24   u8g_DrawStr180
        24   -- Indirect call
        24   -> u8g_draw_glyph180
      24   u8g_DrawStr180P
        24   -- Indirect call
        24   -> u8g_DrawGlyph180
      24   u8g_DrawStr270
        24   -- Indirect call
        24   -> u8g_draw_glyph270
      24   u8g_DrawStr270P
        24   -- Indirect call
        24   -> u8g_DrawGlyph270
      24   u8g_DrawStr90
        24   -- Indirect call
        24   -> u8g_draw_glyph90
      24   u8g_DrawStr90P
        24   -- Indirect call
        24   -> u8g_DrawGlyph90
       8   u8g_DrawStrDir
         0   -> u8g_DrawStr
         0   -> u8g_DrawStr180
         0   -> u8g_DrawStr270
         0   -> u8g_DrawStr90
      32   u8g_DrawStrFontBBX
        32   -> u8g_DrawStrDir
        32   -> u8g_GetFontBBXOffX
        32   -> u8g_GetFontBBXOffY
      24   u8g_DrawStrP
        24   -- Indirect call
        24   -> u8g_draw_glyph
       0   u8g_FillEmptyGlyphCache
       0   u8g_GetFontBBXHeight
         0   -> u8g_font_GetBBXHeight
       0   u8g_GetFontBBXOffX
         0   -> u8g_font_GetBBXOffX
       0   u8g_GetFontBBXOffY
         0   -> u8g_font_GetBBXOffY
       0   u8g_GetFontBBXWidth
         0   -> u8g_font_GetBBXWidth
       0   u8g_GetFontCapitalAHeight
         0   -> u8g_font_GetCapitalAHeight
      40   u8g_GetGlyph
        40   -> u8g_CopyGlyphDataToCache
        40   -> u8g_FillEmptyGlyphCache
        40   -> u8g_font_GetEncoding65Pos
        40   -> u8g_font_GetEncoding97Pos
        40   -> u8g_font_GetFontEndEncoding
        40   -> u8g_font_GetFontGlyphStructureSize
        40   -> u8g_font_GetFontStartEncoding
        40   -> u8g_font_GetFormat
       8   u8g_GetGlyphDeltaX
         8   -> u8g_GetGlyph
      56   u8g_GetStrAMinBox
        56   -> u8g_font_GetCapitalAHeight
        56   -> u8g_font_calc_str_min_box
        56   -> u8g_font_get_str_box_fill_args
      48   u8g_GetStrMinBox
        48   -> u8g_font_calc_str_min_box
        48   -> u8g_font_get_str_box_fill_args
       0   u8g_GetStrPixelWidth
         0   -> u8g_font_calc_str_pixel_width
       0   u8g_GetStrPixelWidthP
         0   -> u8g_font_calc_str_pixel_width
      16   u8g_GetStrWidth
        16   -> u8g_GetGlyph
      16   u8g_GetStrWidthP
        16   -> u8g_GetGlyph
       8   u8g_GetStrX
         8   -> u8g_GetGlyph
       8   u8g_GetStrXP
         8   -> u8g_GetGlyph
       8   u8g_IsGlyph
         8   -> u8g_GetGlyph
       8   u8g_SetFont
         0   -> u8g_SetFontPosBaseline
         8   -> u8g_UpdateRefHeight
       0   u8g_SetFontLineSpacingFactor
         0   -> u8g_UpdateRefHeight
       0   u8g_SetFontPosBaseline
       0   u8g_SetFontPosBottom
       0   u8g_SetFontPosCenter
       0   u8g_SetFontPosTop
       0   u8g_SetFontRefHeightAll
         0   -> u8g_UpdateRefHeight
       0   u8g_SetFontRefHeightExtendedText
         0   -> u8g_UpdateRefHeight
       0   u8g_SetFontRefHeightText
         0   -> u8g_UpdateRefHeight
      16   u8g_UpdateRefHeight
        16   -> u8g_font_GetCapitalAHeight
        16   -> u8g_font_GetFontAscent
        16   -> u8g_font_GetFontDescent
        16   -> u8g_font_GetFontXAscent
        16   -> u8g_font_GetFontXDescent
        16   -> u8g_font_GetLowerGDescent
      48   u8g_draw_aa_glyph
        48   -> u8g_Draw4TPixel
        48   -> u8g_GetGlyph
        48   -> u8g_IsBBXIntersection
        48   -> u8g_font_GetGlyphDataStart
      48   u8g_draw_glyph
        48   -> u8g_Draw8Pixel
        48   -> u8g_GetGlyph
        48   -> u8g_IsBBXIntersection
        48   -> u8g_font_GetGlyphDataStart
      48   u8g_draw_glyph180
        48   -> u8g_Draw8Pixel
        48   -> u8g_GetGlyph
        48   -> u8g_IsBBXIntersection
        48   -> u8g_font_GetGlyphDataStart
      48   u8g_draw_glyph270
        48   -> u8g_Draw8Pixel
        48   -> u8g_GetGlyph
        48   -> u8g_IsBBXIntersection
        48   -> u8g_font_GetGlyphDataStart
      48   u8g_draw_glyph90
        48   -> u8g_Draw8Pixel
        48   -> u8g_GetGlyph
        48   -> u8g_IsBBXIntersection
        48   -> u8g_font_GetGlyphDataStart
       0   u8g_font_GetBBXHeight
         0   -> u8g_font_get_byte
       8   u8g_font_GetBBXOffX
         8   -> u8g_font_get_byte
       8   u8g_font_GetBBXOffY
         8   -> u8g_font_get_byte
       0   u8g_font_GetBBXWidth
         0   -> u8g_font_get_byte
       0   u8g_font_GetCapitalAHeight
         0   -> u8g_font_get_byte
       0   u8g_font_GetEncoding65Pos
         0   -> u8g_font_get_word
       0   u8g_font_GetEncoding97Pos
         0   -> u8g_font_get_word
       8   u8g_font_GetFontAscent
         8   -> u8g_font_get_byte
       8   u8g_font_GetFontDescent
         8   -> u8g_font_get_byte
       0   u8g_font_GetFontEndEncoding
         0   -> u8g_font_get_byte
       8   u8g_font_GetFontGlyphStructureSize
         8   -> u8g_font_GetFormat
       0   u8g_font_GetFontStartEncoding
         0   -> u8g_font_get_byte
       8   u8g_font_GetFontXAscent
         8   -> u8g_font_get_byte
       8   u8g_font_GetFontXDescent
         8   -> u8g_font_get_byte
       0   u8g_font_GetFormat
         0   -> u8g_font_get_byte
       8   u8g_font_GetGlyphDataStart
         8   -> u8g_font_GetFontGlyphStructureSize
       8   u8g_font_GetLowerGDescent
         8   -> u8g_font_get_byte
      24   u8g_font_GetSize
        24   -> u8g_font_GetFontEndEncoding
        24   -> u8g_font_GetFontGlyphStructureSize
        24   -> u8g_font_GetFontStartEncoding
        24   -> u8g_font_GetFormat
       0   u8g_font_box_all_gA
       0   u8g_font_box_left_gA
       0   u8g_font_box_min
         0   -> u8g_font_calc_str_min_box
      16   u8g_font_calc_str_min_box
        16   -> u8g_GetGlyph
      32   u8g_font_calc_str_pixel_width
        32   -- Indirect call
        32   -> u8g_GetGlyph
       0   u8g_font_calc_vref_bottom
       0   u8g_font_calc_vref_center
       0   u8g_font_calc_vref_font
       0   u8g_font_calc_vref_top
       0   u8g_font_get_byte
       0   u8g_font_get_char
       0   u8g_font_get_charP
      32   u8g_font_get_str_box_fill_args
        32   -> u8g_GetGlyph
       0   u8g_font_get_word


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
      88  u8g_CopyGlyphDataToCache
      34  u8g_DrawAAGlyph
      78  u8g_DrawAAStr
      34  u8g_DrawGlyph
      34  u8g_DrawGlyph180
      34  u8g_DrawGlyph270
      34  u8g_DrawGlyph90
      44  u8g_DrawGlyphFontBBX
      64  u8g_DrawStr
      64  u8g_DrawStr180
      60  u8g_DrawStr180P
      64  u8g_DrawStr270
      60  u8g_DrawStr270P
      64  u8g_DrawStr90
      60  u8g_DrawStr90P
      48  u8g_DrawStrDir
      54  u8g_DrawStrFontBBX
      58  u8g_DrawStrP
      16  u8g_FillEmptyGlyphCache
       4  u8g_GetFontBBXHeight
       4  u8g_GetFontBBXOffX
       4  u8g_GetFontBBXOffY
       4  u8g_GetFontBBXWidth
       4  u8g_GetFontCapitalAHeight
     192  u8g_GetGlyph
      22  u8g_GetGlyphDeltaX
      96  u8g_GetStrAMinBox
      74  u8g_GetStrMinBox
       4  u8g_GetStrPixelWidth
       4  u8g_GetStrPixelWidthP
      36  u8g_GetStrWidth
      36  u8g_GetStrWidthP
      20  u8g_GetStrX
      16  u8g_GetStrXP
      18  u8g_IsGlyph
      28  u8g_SetFont
       6  u8g_SetFontLineSpacingFactor
       6  u8g_SetFontPosBaseline
       6  u8g_SetFontPosBottom
       6  u8g_SetFontPosCenter
       6  u8g_SetFontPosTop
       8  u8g_SetFontRefHeightAll
       8  u8g_SetFontRefHeightExtendedText
       8  u8g_SetFontRefHeightText
     100  u8g_UpdateRefHeight
     174  u8g_draw_aa_glyph
     174  u8g_draw_glyph
     184  u8g_draw_glyph180
     178  u8g_draw_glyph270
     174  u8g_draw_glyph90
       4  u8g_font_GetBBXHeight
      12  u8g_font_GetBBXOffX
      12  u8g_font_GetBBXOffY
       4  u8g_font_GetBBXWidth
       4  u8g_font_GetCapitalAHeight
       4  u8g_font_GetEncoding65Pos
       4  u8g_font_GetEncoding97Pos
      12  u8g_font_GetFontAscent
      12  u8g_font_GetFontDescent
       4  u8g_font_GetFontEndEncoding
      22  u8g_font_GetFontGlyphStructureSize
       4  u8g_font_GetFontStartEncoding
      12  u8g_font_GetFontXAscent
      12  u8g_font_GetFontXDescent
       4  u8g_font_GetFormat
      12  u8g_font_GetGlyphDataStart
      12  u8g_font_GetLowerGDescent
      86  u8g_font_GetSize
       2  u8g_font_box_all_gA
       2  u8g_font_box_left_gA
       2  u8g_font_box_min
     148  u8g_font_calc_str_min_box
     114  u8g_font_calc_str_pixel_width
       8  u8g_font_calc_vref_bottom
      26  u8g_font_calc_vref_center
       4  u8g_font_calc_vref_font
      10  u8g_font_calc_vref_top
       4  u8g_font_get_byte
       6  u8g_font_get_char
       6  u8g_font_get_charP
      72  u8g_font_get_str_box_fill_args
      14  u8g_font_get_word

 
 3 274 bytes in section .text
 
 3 274 bytes of CODE memory

Errors: none
Warnings: none
